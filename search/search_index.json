{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"nRF Connect SDK Notes This site contains my notes for the official courses on Nordic Developer Academy . Note: In order to not exceed the filename length limit, please make sure to clone the repository as close to the root of your filesystem as possible.","title":"Home"},{"location":"#nrf-connect-sdk-notes","text":"This site contains my notes for the official courses on Nordic Developer Academy . Note: In order to not exceed the filename length limit, please make sure to clone the repository as close to the root of your filesystem as possible.","title":"nRF Connect SDK Notes"},{"location":"ble-01-minimal-skeleton/","text":"01 - Minimal BLE Skeleton Author: Tony Fu Date: 2025/4/3 Device: nRF52840 Dongle Toolchain: nRF Connect SDK v2.8.0 This example sets up the Bluetooth stack only \u2014 no advertising, no services, no connections. Useful as a clean starting point. Configuration: prj.conf # Enable basic logging CONFIG_LOG=y # Enable Bluetooth stack CONFIG_BT=y # Optional: Set device name (not used here but required for CONFIG_BT) CONFIG_BT_DEVICE_NAME=\"Minimal_BLE\" # Increase stack sizes for stability CONFIG_SYSTEM_WORKQUEUE_STACK_SIZE=2048 CONFIG_MAIN_STACK_SIZE=2048 Code Structure: main.c #include <zephyr/kernel.h> #include <zephyr/logging/log.h> #include <zephyr/bluetooth/bluetooth.h> LOG_MODULE_REGISTER(minimal_ble, LOG_LEVEL_INF); int main(void) { int err; LOG_INF(\"Minimal BLE Example Start\"); // Initialize the Bluetooth stack err = bt_enable(NULL); if (err) { LOG_ERR(\"Bluetooth init failed (err %d)\", err); return -1; } LOG_INF(\"Bluetooth initialized\"); // Idle loop while (1) { k_sleep(K_SECONDS(1)); } }","title":"BLE-Minimal Skeleton"},{"location":"ble-01-minimal-skeleton/#01-minimal-ble-skeleton","text":"Author: Tony Fu Date: 2025/4/3 Device: nRF52840 Dongle Toolchain: nRF Connect SDK v2.8.0 This example sets up the Bluetooth stack only \u2014 no advertising, no services, no connections. Useful as a clean starting point.","title":"01 - Minimal BLE Skeleton"},{"location":"ble-01-minimal-skeleton/#configuration-prjconf","text":"# Enable basic logging CONFIG_LOG=y # Enable Bluetooth stack CONFIG_BT=y # Optional: Set device name (not used here but required for CONFIG_BT) CONFIG_BT_DEVICE_NAME=\"Minimal_BLE\" # Increase stack sizes for stability CONFIG_SYSTEM_WORKQUEUE_STACK_SIZE=2048 CONFIG_MAIN_STACK_SIZE=2048","title":"Configuration: prj.conf"},{"location":"ble-01-minimal-skeleton/#code-structure-mainc","text":"#include <zephyr/kernel.h> #include <zephyr/logging/log.h> #include <zephyr/bluetooth/bluetooth.h> LOG_MODULE_REGISTER(minimal_ble, LOG_LEVEL_INF); int main(void) { int err; LOG_INF(\"Minimal BLE Example Start\"); // Initialize the Bluetooth stack err = bt_enable(NULL); if (err) { LOG_ERR(\"Bluetooth init failed (err %d)\", err); return -1; } LOG_INF(\"Bluetooth initialized\"); // Idle loop while (1) { k_sleep(K_SECONDS(1)); } }","title":"Code Structure: main.c"},{"location":"ble-02-advertising-simple/","text":"02 - BLE Advertising Simple Author: Tony Fu Date: 2025/4/3 Device: nRF52840 Dongle Toolchain: nRF Connect SDK v2.8.0 To advertise your device, you need to call bt_le_adv_start() with the right parameters. int bt_le_adv_start(const struct bt_le_adv_param *param, const struct bt_data *ad, size_t ad_len, const struct bt_data *sd, size_t sd_len); param : Advertising parameters (defines behavior) ad : Advertising data (broadcasted to all scanners) sd : Scan response data (optional, sent after scan request) Common Advertising Params BT_LE_ADV_CONN - Connectable undirected advertising, but still advertises to all devices after connected to a peer. This could be bad for power consumption and security. BT_LE_ADV_CONN_ONE_TIME - Connectable undirected advertising, but stops after the first connection. This is the recommended default for most applications. BT_LE_ADV_CONN_DIR - Connectable directed advertising, which is used when you know the peer address. This is faster and less power-hungry than undirected advertising. BT_LE_ADV_NCONN - Non-connectable undirected advertising, which is used when you don't want to be connected to. This is useful for beacons and other passive broadcasts. BT_LE_ADV_CONN_DIR_LOW_DUTY - Connectable directed advertising with a lower duty cycle, which is used when you don't expect to be connected to immediately but still want to reconnect with a known peer. BT_LE_ADV_NCONN_IDENTITY - Non-connectable advertising that uses the device's identity address, which is useful for testing and visibility. Note: To prevent tracking, advertising modes like BT_LE_ADV_CONN , BT_LE_ADV_CONN_ONE_TIME , and BT_LE_ADV_NCONN (params 1, 2, and 4) use Resolvable Private Addresses (RPAs) by default. RPAs are a privacy feature introduced in Bluetooth 4.2. They are generated using the device\u2019s identity address (public or static random) and a random value, and they typically change every 15 minutes. This allows trusted, bonded peers to resolve your identity, while third parties cannot track the device over time. RPA behavior is enabled by default when CONFIG_BT_PRIVACY=y , but it can be disabled if needed. To explicitly advertise with your identity address (e.g., for testing or directed advertising), use the BT_LE_ADV_OPT_USE_IDENTITY option. Advertising Data and Scan Response Data Advertising Data (ad[]) static const struct bt_data ad[] = { BT_DATA_BYTES(BT_DATA_FLAGS, (BT_LE_AD_GENERAL | BT_LE_AD_NO_BREDR)), BT_DATA(BT_DATA_NAME_COMPLETE, DEVICE_NAME, DEVICE_NAME_LEN), }; This example shows how to define advertising data using struct bt_data . struct bt_data { uint8_t type; uint8_t data_len; const uint8_t *data; }; However, we typically don't define `struct bt_data` directly. Instead, we use macros to simplify the process. ```c BT_DATA(type, data, data_len) // Use with a pointer and explicit size BT_DATA_BYTES(type, byte1, byte2...) // Inline declaration with raw bytes In advertising data, we must always include the following fields: BT_DATA_BYTES(BT_DATA_FLAGS, (BT_LE_AD_GENERAL | BT_LE_AD_NO_BREDR)) This is always used on Nordic devices because Nordic only supports BLE (not BR/EDR), and this is why we include <zephyr/bluetooth/gap.h> for the bitmasks. and BT_DATA(BT_DATA_NAME_COMPLETE, DEVICE_NAME, DEVICE_NAME_LEN) Scan Response Data (sd[]) Use scan response (sd) when you want to include optional, larger data like a full device name or a URL. Advertising data is always broadcast; scan response is only sent when a scanner asks for it, making it more power-efficient and less crowded. #define COMPANY_ID_CODE 0x0059 // Nordic Semiconductor typedef struct { uint16_t company_id; // Company ID uint8_t data[6]; // Custom Data } my_data_t; static const my_data_t my_data = { .company_id = COMPANY_ID_CODE, .data = {0x01, 0x02, 0x03, 0x04, 0x05, 0x06}}; When the advertising data is too large to fit in advertising packets, the scanner can request a scan response. This is not shown here. Common Advertising Data Types Common in ad[] (Advertising) Macro Description BT_DATA_FLAGS BLE flags (required) BT_DATA_NAME_COMPLETE Complete device name BT_DATA_UUID16_ALL List of 16-bit service UUIDs BT_DATA_UUID128_ALL List of 128-bit service UUIDs BT_DATA_MANUFACTURER_DATA Vendor-specific binary data Common in sd[] (Scan Response) Macro Description BT_DATA_URI URI string (e.g., website) BT_DATA_TX_POWER Transmission power (in dBm) BT_DATA_APPEARANCE Device appearance (e.g., watch) BT_DATA_NAME_SHORTENED Shortened name (if full name won't fit) More on service UUIDs later.","title":"BLE-Advertising Simple"},{"location":"ble-02-advertising-simple/#02-ble-advertising-simple","text":"Author: Tony Fu Date: 2025/4/3 Device: nRF52840 Dongle Toolchain: nRF Connect SDK v2.8.0 To advertise your device, you need to call bt_le_adv_start() with the right parameters. int bt_le_adv_start(const struct bt_le_adv_param *param, const struct bt_data *ad, size_t ad_len, const struct bt_data *sd, size_t sd_len); param : Advertising parameters (defines behavior) ad : Advertising data (broadcasted to all scanners) sd : Scan response data (optional, sent after scan request)","title":"02 - BLE Advertising Simple"},{"location":"ble-02-advertising-simple/#common-advertising-params","text":"BT_LE_ADV_CONN - Connectable undirected advertising, but still advertises to all devices after connected to a peer. This could be bad for power consumption and security. BT_LE_ADV_CONN_ONE_TIME - Connectable undirected advertising, but stops after the first connection. This is the recommended default for most applications. BT_LE_ADV_CONN_DIR - Connectable directed advertising, which is used when you know the peer address. This is faster and less power-hungry than undirected advertising. BT_LE_ADV_NCONN - Non-connectable undirected advertising, which is used when you don't want to be connected to. This is useful for beacons and other passive broadcasts. BT_LE_ADV_CONN_DIR_LOW_DUTY - Connectable directed advertising with a lower duty cycle, which is used when you don't expect to be connected to immediately but still want to reconnect with a known peer. BT_LE_ADV_NCONN_IDENTITY - Non-connectable advertising that uses the device's identity address, which is useful for testing and visibility. Note: To prevent tracking, advertising modes like BT_LE_ADV_CONN , BT_LE_ADV_CONN_ONE_TIME , and BT_LE_ADV_NCONN (params 1, 2, and 4) use Resolvable Private Addresses (RPAs) by default. RPAs are a privacy feature introduced in Bluetooth 4.2. They are generated using the device\u2019s identity address (public or static random) and a random value, and they typically change every 15 minutes. This allows trusted, bonded peers to resolve your identity, while third parties cannot track the device over time. RPA behavior is enabled by default when CONFIG_BT_PRIVACY=y , but it can be disabled if needed. To explicitly advertise with your identity address (e.g., for testing or directed advertising), use the BT_LE_ADV_OPT_USE_IDENTITY option.","title":"Common Advertising Params"},{"location":"ble-02-advertising-simple/#advertising-data-and-scan-response-data","text":"","title":"Advertising Data and Scan Response Data"},{"location":"ble-02-advertising-simple/#advertising-data-ad","text":"static const struct bt_data ad[] = { BT_DATA_BYTES(BT_DATA_FLAGS, (BT_LE_AD_GENERAL | BT_LE_AD_NO_BREDR)), BT_DATA(BT_DATA_NAME_COMPLETE, DEVICE_NAME, DEVICE_NAME_LEN), }; This example shows how to define advertising data using struct bt_data . struct bt_data { uint8_t type; uint8_t data_len; const uint8_t *data; }; However, we typically don't define `struct bt_data` directly. Instead, we use macros to simplify the process. ```c BT_DATA(type, data, data_len) // Use with a pointer and explicit size BT_DATA_BYTES(type, byte1, byte2...) // Inline declaration with raw bytes In advertising data, we must always include the following fields: BT_DATA_BYTES(BT_DATA_FLAGS, (BT_LE_AD_GENERAL | BT_LE_AD_NO_BREDR)) This is always used on Nordic devices because Nordic only supports BLE (not BR/EDR), and this is why we include <zephyr/bluetooth/gap.h> for the bitmasks. and BT_DATA(BT_DATA_NAME_COMPLETE, DEVICE_NAME, DEVICE_NAME_LEN)","title":"Advertising Data (ad[])"},{"location":"ble-02-advertising-simple/#scan-response-data-sd","text":"Use scan response (sd) when you want to include optional, larger data like a full device name or a URL. Advertising data is always broadcast; scan response is only sent when a scanner asks for it, making it more power-efficient and less crowded. #define COMPANY_ID_CODE 0x0059 // Nordic Semiconductor typedef struct { uint16_t company_id; // Company ID uint8_t data[6]; // Custom Data } my_data_t; static const my_data_t my_data = { .company_id = COMPANY_ID_CODE, .data = {0x01, 0x02, 0x03, 0x04, 0x05, 0x06}}; When the advertising data is too large to fit in advertising packets, the scanner can request a scan response. This is not shown here.","title":"Scan Response Data (sd[])"},{"location":"ble-02-advertising-simple/#common-advertising-data-types","text":"","title":"Common Advertising Data Types"},{"location":"ble-02-advertising-simple/#common-in-ad-advertising","text":"Macro Description BT_DATA_FLAGS BLE flags (required) BT_DATA_NAME_COMPLETE Complete device name BT_DATA_UUID16_ALL List of 16-bit service UUIDs BT_DATA_UUID128_ALL List of 128-bit service UUIDs BT_DATA_MANUFACTURER_DATA Vendor-specific binary data","title":"Common in ad[] (Advertising)"},{"location":"ble-02-advertising-simple/#common-in-sd-scan-response","text":"Macro Description BT_DATA_URI URI string (e.g., website) BT_DATA_TX_POWER Transmission power (in dBm) BT_DATA_APPEARANCE Device appearance (e.g., watch) BT_DATA_NAME_SHORTENED Shortened name (if full name won't fit) More on service UUIDs later.","title":"Common in sd[] (Scan Response)"},{"location":"ble-03-advert-connectable/","text":"03 - BLE Advertising: Connectable Author: Tony Fu Date: 2025/4/5 Device: nRF52840 Dongle Toolchain: nRF Connect SDK v2.8.0 To make a device connectable, we need to enable the Bluetooth peripheral role and set the advertising parameters accordingly. Add this to your prj.conf file: CONFIG_BT_PERIPHERAL=y In previous examples, we used the predefined macro BT_LE_ADV_NCONN for non-connectable advertising. To allow connections, we need different parameters like BT_LE_ADV_CONN_ONE_TIME . We can also define our own advertising parameters with the help of the BT_LE_ADV_PARAM() macro: BT_LE_ADV_PARAM(_options, _int_min, _int_max, _peer) _options : A bitmask of advertising options (e.g., connectable, use identity, etc.) _int_min , _int_max : Advertising interval (units of 0.625 ms) _peer : Peer address; set to NULL for undirected advertising Example parameters for connectable advertising: static const struct bt_le_adv_param *adv_param = BT_LE_ADV_PARAM( (BT_LE_ADV_OPT_CONNECTABLE | BT_LE_ADV_OPT_USE_IDENTITY), /* Connectable advertising and use identity address */ BT_GAP_ADV_FAST_INT_MIN_2, /* Min Advertising Interval 100 ms */ BT_GAP_ADV_FAST_INT_MAX_2, /* Max Advertising Interval 150 ms */ NULL); /* Set to NULL for undirected advertising */ Common options flags include: BT_LE_ADV_OPT_CONNECTABLE : Allow devices to connect BT_LE_ADV_OPT_ONE_TIME : Stop advertising after one connection BT_LE_ADV_OPT_USE_IDENTITY : Use the device's identity address (not RPA) BT_LE_ADV_OPT_USE_NAME : Automatically include the GAP device name BT_LE_ADV_OPT_SCANNABLE : Enable scan response data BT_LE_ADV_OPT_EXT_ADV : Use extended advertising features (for longer range or larger data) BT_LE_ADV_OPT_FILTER_SCAN_REQ : Only respond to scanners in the filter list BT_LE_ADV_OPT_FILTER_CONN : Only allow connections from filtered peers This setup allows your device to be discoverable and accept connections from central devices like phones or PCs. However, it will continue to advertise even after a connection is established, which may not be ideal for power consumption or security. To stop advertising after the first connection, add the BT_LE_ADV_OPT_ONE_TIME option. Advertising Intervals The advertising interval controls how often your device broadcasts its advertising packets. It is set using _int_min and _int_max in BT_LE_ADV_PARAM() and is specified in units of 0.625 ms. Valid range : 20 ms to 10.24 seconds Resolution : 0.625 ms steps You can set: - min == max \u2192 Fixed interval (allowed) - min < max \u2192 Interval chosen randomly within that range (typical) A small random delay (0\u201310 ms) is added automatically to help avoid collisions between devices using similar intervals. Guidelines Short intervals (~20\u2013100 ms) : Fast discovery, higher power consumption Medium intervals (~150\u2013500 ms) : Balanced power and discovery time (good default) Long intervals (>1 s) : Low power, slower to be discovered Choose an interval based on your application: - For wearables or low-power sensors , favor longer intervals - For pairing mode or quick reconnection , use shorter intervals Some constants are defined in zephyr/bluetooth/gap.h for common intervals: GAP Advertising Parameters These are predefined intervals for legacy advertisement (connectable or scannable), used by many macros like BT_LE_ADV_CONN . Macro Hex Time (ms) BT_GAP_ADV_FAST_INT_MIN_1 0x0030 30 BT_GAP_ADV_FAST_INT_MAX_1 0x0060 60 BT_GAP_ADV_FAST_INT_MIN_2 0x00a0 100 BT_GAP_ADV_FAST_INT_MAX_2 0x00f0 150 BT_GAP_ADV_SLOW_INT_MIN 0x0640 1000 BT_GAP_ADV_SLOW_INT_MAX 0x0780 1200 GAP Periodic Advertising Parameters Periodic advertising is a Bluetooth Low Energy feature introduced in Bluetooth 5 that allows a device to broadcast data at fixed, predictable intervals without requiring a connection. Unlike legacy advertising, which is sent on the primary channels and may be missed if the scanner isn't listening at the right time, periodic advertising uses a synchronizable schedule and is transmitted on secondary channels. This allows scanners to synchronize with the advertiser and receive updates reliably with lower power consumption. It's ideal for broadcasting sensor data , location beacons , or status updates where frequent connections aren't needed but consistent updates are. Macro Hex Time (ms) BT_GAP_PER_ADV_FAST_INT_MIN_1 0x0018 30 BT_GAP_PER_ADV_FAST_INT_MAX_1 0x0030 60 BT_GAP_PER_ADV_FAST_INT_MIN_2 0x0050 100 BT_GAP_PER_ADV_FAST_INT_MAX_2 0x0078 150 BT_GAP_PER_ADV_SLOW_INT_MIN 0x0320 1000 BT_GAP_PER_ADV_SLOW_INT_MAX 0x03C0 1200 GAP Scan Parameters These define standard scan intervals and windows. The interval is how often scanning starts, and the window is how long each scan lasts. Macro Hex Time (ms) BT_GAP_SCAN_FAST_INTERVAL_MIN 0x0030 30 BT_GAP_SCAN_FAST_INTERVAL 0x0060 60 BT_GAP_SCAN_FAST_WINDOW 0x0030 30 BT_GAP_SCAN_SLOW_INTERVAL_1 0x0800 1280 BT_GAP_SCAN_SLOW_WINDOW_1 0x0012 11.25 BT_GAP_SCAN_SLOW_INTERVAL_2 0x1000 2560 BT_GAP_SCAN_SLOW_WINDOW_2 0x0012 11.25 GAP Initial Connection Parameters These define intervals used when initiating a connection (i.e., when a central connects to a peripheral). Macro Hex Time (ms) BT_GAP_INIT_CONN_INT_MIN 0x0018 30 BT_GAP_INIT_CONN_INT_MAX 0x0028 50 Additional Notes on Timing Coordination When both the advertiser and scanner are under your control, you can optimize their timing parameters to strike a balance between discovery speed , power consumption , and reliability . This is especially useful in scenarios like proprietary ecosystems, closed systems, or when designing both ends of a BLE link (e.g., a wearable + smartphone app). Understanding Scan Interval and Scan Window Scan interval is how often the scanner initiates a scan cycle. Scan window is how long the scanner listens during each scan interval. Both range from 2.5 ms to 10.24 seconds in 0.625 ms steps. In each scan interval, the scanner will scan one of the three primary advertising channels. After the interval ends, it switches to the next channel. If the scan window is equal to the scan interval, the scanner is scanning continuously (100% duty cycle). If the window is shorter than the interval, it means the scanner is off part of the time \u2014 which saves power. For example, if scan interval = 100 ms and window = 20 ms, the scanner is listening only 20% of the time. Coordinating With Advertising Intervals To improve the chances of the scanner receiving advertising packets: The advertising interval should be shorter than or equal to the scan interval. This increases the probability that an advertisement will occur during the scan window. A good rule of thumb is: advertising interval \u2264 scan interval - scan window This ensures that at least one advertisement falls within an active scan window over multiple cycles. You can also align timing using multiples, such as: - Scan interval = 3 \u00d7 advertising interval - Scan window = 50\u201380% of scan interval (for reasonable duty cycle) This is not a strict rule, but it helps statistically reduce missed advertisements due to phase misalignment. Example Timing Coordination Parameter Typical Value Advertising interval 100 ms ( 0x00A0 ) Scan interval 300 ms ( 0x018C ) Scan window 150 ms ( 0x00F0 ) This setup provides good discovery speed and balances scanner energy usage. Notes on Scan Response Timing Scan response packets are only sent if the advertiser receives a scan request . This scan request must be sent while the advertiser is listening , and only during active scanning. The non-scanning time (between windows) is not used for scan response \u2014 in fact, nothing happens during those gaps. This means larger scan windows increase the chance of triggering a scan response successfully. Power Considerations Scanning uses more power than advertising \u2014 so the scanner (usually the central) should be the device with more available energy (e.g., a phone). Peripheral devices (e.g., sensors, wearables) can advertise less frequently to save power and rely on burst scanning from the central. Summary Guidelines Ensure advertising interval \u2264 scan interval Keep scan window large enough to catch at least one advertisement Use scan window \u2248 50\u2013100% of scan interval for faster discovery For low power devices, increase advertising interval and let central scan more aggressively Aside: BLE Address Types Before we continue, let's take a moment to explore the different types of Bluetooth LE addresses. Every BLE device is identified by a 48-bit address , and they are grouped into two main categories: public and random . Random addresses are further split into static , resolvable private , and non-resolvable private types. The type used affects how your device is identified, whether it can be tracked, and whether connections or bonding are possible. 1. Public Address A globally unique address assigned by the manufacturer and stored in the device's hardware (e.g., in FICR on nRF chips). Used automatically unless you override it with a random address or enable privacy. Get the default public address: bt_addr_le_t addr; bt_id_get(&addr, NULL); 2. Random Static Address Does not change across boots \u2014 stable identity. Must follow BLE spec: the most significant two bits of the first byte must be 11 (so the first byte must be between 0xC0 and 0xFF ). Commonly used when you don't have a public address block but need a consistent identity. Set a static random address manually: #include <zephyr/bluetooth/addr.h> bt_addr_le_t addr; bt_addr_le_from_str(\"FF:00:11:22:33:44\", \"random\", &addr); addr.a.val[5] |= 0xC0; // Make sure MSBs are '11' to mark as static random int id = bt_id_create(&addr, NULL); // Must be called before bt_enable() In production, you might derive a unique static random address from the device\u2019s public address or store a pre-generated one in flash/UICR. 3. Resolvable Private Address (RPA) Changes periodically (by default every 15 minutes), but can be resolved by bonded peers using an Identity Resolving Key (IRK). Enables privacy without sacrificing the ability to reconnect or bond. I am currently not sure how to set the RPA manually, but it should be automatically generated by the stack when you enable privacy ( CONFIG_BT_PRIVACY=y ). 4. Non-Resolvable Private Address (NRPA) Also changes periodically, but cannot be resolved \u2014 not bondable or connectable. Useful for anonymous broadcasting (e.g., a privacy-focused beacon). A new NRPA is generated every time you start advertising. Set NRPA explicitly: static const struct bt_le_adv_param *adv_param = BT_LE_ADV_PARAM( BT_LE_ADV_OPT_USE_NRPA, 160, 160, NULL); Connection Callbacks To handle Bluetooth connections in Zephyr, we use the bt_conn_cb structure. This lets us register callback functions to track connection events like when a device connects or disconnects. First, include the necessary header: #include <zephyr/bluetooth/conn.h> Then, declare a connection reference to track the active connection: static struct bt_conn *my_conn = NULL; Basic Callbacks void on_connected(struct bt_conn *conn, uint8_t err) { if (err) { LOG_ERR(\"Connection failed (err %u)\", err); return; } my_conn = bt_conn_ref(conn); } void on_disconnected(struct bt_conn *conn, uint8_t reason) { LOG_INF(\"Disconnected (reason 0x%02x)\", reason); if (my_conn) { bt_conn_unref(my_conn); my_conn = NULL; } } bt_conn_ref() increases the reference count so the connection stays valid. bt_conn_unref() is called on disconnection to release the reference. bt_conn_get_dst() gets the peer device\u2019s address. Although tracking bt_conn isn't strictly necessary in this example, it becomes important when supporting multiple simultaneous connections . Keeping a reference to each connection allows you to target specific peers\u2014for example, sending data only to one device or applying per-connection security settings. Most Zephyr Bluetooth APIs accept NULL as the bt_conn argument, which simply means \u201csend to all connected peers.\u201d But for more advanced use cases, managing and using specific bt_conn pointers is essential for precise control. Registering Callbacks static struct bt_conn_cb connection_callbacks = { .connected = on_connected, .disconnected = on_disconnected, }; bt_conn_cb_register(&connection_callbacks); You must register your callback structure before or after enabling Bluetooth, and before expecting any connection events. Other Available Callbacks in bt_conn_cb You can optionally implement more callbacks: recycled : Called when a connection object is returned to the pool. le_param_req : Called when the peer requests to update connection parameters. Return true to accept or false to reject. le_param_updated : Notifies when connection parameters are updated (interval, latency, timeout). identity_resolved : (If SMP enabled) Notifies when a peer's identity address is resolved from an RPA. security_changed : (If SMP or Classic enabled) Called when connection security changes. remote_info_available : Called when info about the peer (features, roles) is available. le_phy_updated : Notifies when PHY is changed (1M, 2M, coded). le_data_len_updated : Called when the maximum payload size changes. tx_power_report : Reports transmit power changes. subrate_changed : Called when connection subrate settings change. These are mostly optional and only needed for advanced use cases. Connection and Disconnection Error Codes Both on_connected() and on_disconnected() callbacks report errors using HCI error codes defined by the Bluetooth Core Specification. These are standard codes used across the Bluetooth stack to indicate why a connection failed or was terminated. In on_connected() , the err parameter is 0 on success, or an HCI error (e.g., 0x3E for \"Connection Failed to be Established\"). In on_disconnected() , the reason parameter is also an HCI error code (e.g., 0x13 for \"Remote User Terminated Connection\"). These codes help identify common issues such as timeouts, user-initiated disconnects, or parameter mismatches. You can refer to the official list of controller error codes here: \ud83d\udd17 Bluetooth Core Spec v5.4 \u2013 Controller Error Codes","title":"BLE-Advertising Connectable"},{"location":"ble-03-advert-connectable/#03-ble-advertising-connectable","text":"Author: Tony Fu Date: 2025/4/5 Device: nRF52840 Dongle Toolchain: nRF Connect SDK v2.8.0 To make a device connectable, we need to enable the Bluetooth peripheral role and set the advertising parameters accordingly. Add this to your prj.conf file: CONFIG_BT_PERIPHERAL=y In previous examples, we used the predefined macro BT_LE_ADV_NCONN for non-connectable advertising. To allow connections, we need different parameters like BT_LE_ADV_CONN_ONE_TIME . We can also define our own advertising parameters with the help of the BT_LE_ADV_PARAM() macro: BT_LE_ADV_PARAM(_options, _int_min, _int_max, _peer) _options : A bitmask of advertising options (e.g., connectable, use identity, etc.) _int_min , _int_max : Advertising interval (units of 0.625 ms) _peer : Peer address; set to NULL for undirected advertising Example parameters for connectable advertising: static const struct bt_le_adv_param *adv_param = BT_LE_ADV_PARAM( (BT_LE_ADV_OPT_CONNECTABLE | BT_LE_ADV_OPT_USE_IDENTITY), /* Connectable advertising and use identity address */ BT_GAP_ADV_FAST_INT_MIN_2, /* Min Advertising Interval 100 ms */ BT_GAP_ADV_FAST_INT_MAX_2, /* Max Advertising Interval 150 ms */ NULL); /* Set to NULL for undirected advertising */ Common options flags include: BT_LE_ADV_OPT_CONNECTABLE : Allow devices to connect BT_LE_ADV_OPT_ONE_TIME : Stop advertising after one connection BT_LE_ADV_OPT_USE_IDENTITY : Use the device's identity address (not RPA) BT_LE_ADV_OPT_USE_NAME : Automatically include the GAP device name BT_LE_ADV_OPT_SCANNABLE : Enable scan response data BT_LE_ADV_OPT_EXT_ADV : Use extended advertising features (for longer range or larger data) BT_LE_ADV_OPT_FILTER_SCAN_REQ : Only respond to scanners in the filter list BT_LE_ADV_OPT_FILTER_CONN : Only allow connections from filtered peers This setup allows your device to be discoverable and accept connections from central devices like phones or PCs. However, it will continue to advertise even after a connection is established, which may not be ideal for power consumption or security. To stop advertising after the first connection, add the BT_LE_ADV_OPT_ONE_TIME option.","title":"03 - BLE Advertising: Connectable"},{"location":"ble-03-advert-connectable/#advertising-intervals","text":"The advertising interval controls how often your device broadcasts its advertising packets. It is set using _int_min and _int_max in BT_LE_ADV_PARAM() and is specified in units of 0.625 ms. Valid range : 20 ms to 10.24 seconds Resolution : 0.625 ms steps You can set: - min == max \u2192 Fixed interval (allowed) - min < max \u2192 Interval chosen randomly within that range (typical) A small random delay (0\u201310 ms) is added automatically to help avoid collisions between devices using similar intervals.","title":"Advertising Intervals"},{"location":"ble-03-advert-connectable/#guidelines","text":"Short intervals (~20\u2013100 ms) : Fast discovery, higher power consumption Medium intervals (~150\u2013500 ms) : Balanced power and discovery time (good default) Long intervals (>1 s) : Low power, slower to be discovered Choose an interval based on your application: - For wearables or low-power sensors , favor longer intervals - For pairing mode or quick reconnection , use shorter intervals Some constants are defined in zephyr/bluetooth/gap.h for common intervals:","title":"Guidelines"},{"location":"ble-03-advert-connectable/#gap-advertising-parameters","text":"These are predefined intervals for legacy advertisement (connectable or scannable), used by many macros like BT_LE_ADV_CONN . Macro Hex Time (ms) BT_GAP_ADV_FAST_INT_MIN_1 0x0030 30 BT_GAP_ADV_FAST_INT_MAX_1 0x0060 60 BT_GAP_ADV_FAST_INT_MIN_2 0x00a0 100 BT_GAP_ADV_FAST_INT_MAX_2 0x00f0 150 BT_GAP_ADV_SLOW_INT_MIN 0x0640 1000 BT_GAP_ADV_SLOW_INT_MAX 0x0780 1200","title":"GAP Advertising Parameters"},{"location":"ble-03-advert-connectable/#gap-periodic-advertising-parameters","text":"Periodic advertising is a Bluetooth Low Energy feature introduced in Bluetooth 5 that allows a device to broadcast data at fixed, predictable intervals without requiring a connection. Unlike legacy advertising, which is sent on the primary channels and may be missed if the scanner isn't listening at the right time, periodic advertising uses a synchronizable schedule and is transmitted on secondary channels. This allows scanners to synchronize with the advertiser and receive updates reliably with lower power consumption. It's ideal for broadcasting sensor data , location beacons , or status updates where frequent connections aren't needed but consistent updates are. Macro Hex Time (ms) BT_GAP_PER_ADV_FAST_INT_MIN_1 0x0018 30 BT_GAP_PER_ADV_FAST_INT_MAX_1 0x0030 60 BT_GAP_PER_ADV_FAST_INT_MIN_2 0x0050 100 BT_GAP_PER_ADV_FAST_INT_MAX_2 0x0078 150 BT_GAP_PER_ADV_SLOW_INT_MIN 0x0320 1000 BT_GAP_PER_ADV_SLOW_INT_MAX 0x03C0 1200","title":"GAP Periodic Advertising Parameters"},{"location":"ble-03-advert-connectable/#gap-scan-parameters","text":"These define standard scan intervals and windows. The interval is how often scanning starts, and the window is how long each scan lasts. Macro Hex Time (ms) BT_GAP_SCAN_FAST_INTERVAL_MIN 0x0030 30 BT_GAP_SCAN_FAST_INTERVAL 0x0060 60 BT_GAP_SCAN_FAST_WINDOW 0x0030 30 BT_GAP_SCAN_SLOW_INTERVAL_1 0x0800 1280 BT_GAP_SCAN_SLOW_WINDOW_1 0x0012 11.25 BT_GAP_SCAN_SLOW_INTERVAL_2 0x1000 2560 BT_GAP_SCAN_SLOW_WINDOW_2 0x0012 11.25","title":"GAP Scan Parameters"},{"location":"ble-03-advert-connectable/#gap-initial-connection-parameters","text":"These define intervals used when initiating a connection (i.e., when a central connects to a peripheral). Macro Hex Time (ms) BT_GAP_INIT_CONN_INT_MIN 0x0018 30 BT_GAP_INIT_CONN_INT_MAX 0x0028 50","title":"GAP Initial Connection Parameters"},{"location":"ble-03-advert-connectable/#additional-notes-on-timing-coordination","text":"When both the advertiser and scanner are under your control, you can optimize their timing parameters to strike a balance between discovery speed , power consumption , and reliability . This is especially useful in scenarios like proprietary ecosystems, closed systems, or when designing both ends of a BLE link (e.g., a wearable + smartphone app).","title":"Additional Notes on Timing Coordination"},{"location":"ble-03-advert-connectable/#understanding-scan-interval-and-scan-window","text":"Scan interval is how often the scanner initiates a scan cycle. Scan window is how long the scanner listens during each scan interval. Both range from 2.5 ms to 10.24 seconds in 0.625 ms steps. In each scan interval, the scanner will scan one of the three primary advertising channels. After the interval ends, it switches to the next channel. If the scan window is equal to the scan interval, the scanner is scanning continuously (100% duty cycle). If the window is shorter than the interval, it means the scanner is off part of the time \u2014 which saves power. For example, if scan interval = 100 ms and window = 20 ms, the scanner is listening only 20% of the time.","title":"Understanding Scan Interval and Scan Window"},{"location":"ble-03-advert-connectable/#coordinating-with-advertising-intervals","text":"To improve the chances of the scanner receiving advertising packets: The advertising interval should be shorter than or equal to the scan interval. This increases the probability that an advertisement will occur during the scan window. A good rule of thumb is: advertising interval \u2264 scan interval - scan window This ensures that at least one advertisement falls within an active scan window over multiple cycles. You can also align timing using multiples, such as: - Scan interval = 3 \u00d7 advertising interval - Scan window = 50\u201380% of scan interval (for reasonable duty cycle) This is not a strict rule, but it helps statistically reduce missed advertisements due to phase misalignment.","title":"Coordinating With Advertising Intervals"},{"location":"ble-03-advert-connectable/#example-timing-coordination","text":"Parameter Typical Value Advertising interval 100 ms ( 0x00A0 ) Scan interval 300 ms ( 0x018C ) Scan window 150 ms ( 0x00F0 ) This setup provides good discovery speed and balances scanner energy usage.","title":"Example Timing Coordination"},{"location":"ble-03-advert-connectable/#notes-on-scan-response-timing","text":"Scan response packets are only sent if the advertiser receives a scan request . This scan request must be sent while the advertiser is listening , and only during active scanning. The non-scanning time (between windows) is not used for scan response \u2014 in fact, nothing happens during those gaps. This means larger scan windows increase the chance of triggering a scan response successfully.","title":"Notes on Scan Response Timing"},{"location":"ble-03-advert-connectable/#power-considerations","text":"Scanning uses more power than advertising \u2014 so the scanner (usually the central) should be the device with more available energy (e.g., a phone). Peripheral devices (e.g., sensors, wearables) can advertise less frequently to save power and rely on burst scanning from the central.","title":"Power Considerations"},{"location":"ble-03-advert-connectable/#summary-guidelines","text":"Ensure advertising interval \u2264 scan interval Keep scan window large enough to catch at least one advertisement Use scan window \u2248 50\u2013100% of scan interval for faster discovery For low power devices, increase advertising interval and let central scan more aggressively","title":"Summary Guidelines"},{"location":"ble-03-advert-connectable/#aside-ble-address-types","text":"Before we continue, let's take a moment to explore the different types of Bluetooth LE addresses. Every BLE device is identified by a 48-bit address , and they are grouped into two main categories: public and random . Random addresses are further split into static , resolvable private , and non-resolvable private types. The type used affects how your device is identified, whether it can be tracked, and whether connections or bonding are possible.","title":"Aside: BLE Address Types"},{"location":"ble-03-advert-connectable/#1-public-address","text":"A globally unique address assigned by the manufacturer and stored in the device's hardware (e.g., in FICR on nRF chips). Used automatically unless you override it with a random address or enable privacy.","title":"1. Public Address"},{"location":"ble-03-advert-connectable/#get-the-default-public-address","text":"bt_addr_le_t addr; bt_id_get(&addr, NULL);","title":"Get the default public address:"},{"location":"ble-03-advert-connectable/#2-random-static-address","text":"Does not change across boots \u2014 stable identity. Must follow BLE spec: the most significant two bits of the first byte must be 11 (so the first byte must be between 0xC0 and 0xFF ). Commonly used when you don't have a public address block but need a consistent identity.","title":"2. Random Static Address"},{"location":"ble-03-advert-connectable/#set-a-static-random-address-manually","text":"#include <zephyr/bluetooth/addr.h> bt_addr_le_t addr; bt_addr_le_from_str(\"FF:00:11:22:33:44\", \"random\", &addr); addr.a.val[5] |= 0xC0; // Make sure MSBs are '11' to mark as static random int id = bt_id_create(&addr, NULL); // Must be called before bt_enable() In production, you might derive a unique static random address from the device\u2019s public address or store a pre-generated one in flash/UICR.","title":"Set a static random address manually:"},{"location":"ble-03-advert-connectable/#3-resolvable-private-address-rpa","text":"Changes periodically (by default every 15 minutes), but can be resolved by bonded peers using an Identity Resolving Key (IRK). Enables privacy without sacrificing the ability to reconnect or bond. I am currently not sure how to set the RPA manually, but it should be automatically generated by the stack when you enable privacy ( CONFIG_BT_PRIVACY=y ).","title":"3. Resolvable Private Address (RPA)"},{"location":"ble-03-advert-connectable/#4-non-resolvable-private-address-nrpa","text":"Also changes periodically, but cannot be resolved \u2014 not bondable or connectable. Useful for anonymous broadcasting (e.g., a privacy-focused beacon). A new NRPA is generated every time you start advertising.","title":"4. Non-Resolvable Private Address (NRPA)"},{"location":"ble-03-advert-connectable/#set-nrpa-explicitly","text":"static const struct bt_le_adv_param *adv_param = BT_LE_ADV_PARAM( BT_LE_ADV_OPT_USE_NRPA, 160, 160, NULL);","title":"Set NRPA explicitly:"},{"location":"ble-03-advert-connectable/#connection-callbacks","text":"To handle Bluetooth connections in Zephyr, we use the bt_conn_cb structure. This lets us register callback functions to track connection events like when a device connects or disconnects. First, include the necessary header: #include <zephyr/bluetooth/conn.h> Then, declare a connection reference to track the active connection: static struct bt_conn *my_conn = NULL;","title":"Connection Callbacks"},{"location":"ble-03-advert-connectable/#basic-callbacks","text":"void on_connected(struct bt_conn *conn, uint8_t err) { if (err) { LOG_ERR(\"Connection failed (err %u)\", err); return; } my_conn = bt_conn_ref(conn); } void on_disconnected(struct bt_conn *conn, uint8_t reason) { LOG_INF(\"Disconnected (reason 0x%02x)\", reason); if (my_conn) { bt_conn_unref(my_conn); my_conn = NULL; } } bt_conn_ref() increases the reference count so the connection stays valid. bt_conn_unref() is called on disconnection to release the reference. bt_conn_get_dst() gets the peer device\u2019s address. Although tracking bt_conn isn't strictly necessary in this example, it becomes important when supporting multiple simultaneous connections . Keeping a reference to each connection allows you to target specific peers\u2014for example, sending data only to one device or applying per-connection security settings. Most Zephyr Bluetooth APIs accept NULL as the bt_conn argument, which simply means \u201csend to all connected peers.\u201d But for more advanced use cases, managing and using specific bt_conn pointers is essential for precise control.","title":"Basic Callbacks"},{"location":"ble-03-advert-connectable/#registering-callbacks","text":"static struct bt_conn_cb connection_callbacks = { .connected = on_connected, .disconnected = on_disconnected, }; bt_conn_cb_register(&connection_callbacks); You must register your callback structure before or after enabling Bluetooth, and before expecting any connection events.","title":"Registering Callbacks"},{"location":"ble-03-advert-connectable/#other-available-callbacks-in-bt_conn_cb","text":"You can optionally implement more callbacks: recycled : Called when a connection object is returned to the pool. le_param_req : Called when the peer requests to update connection parameters. Return true to accept or false to reject. le_param_updated : Notifies when connection parameters are updated (interval, latency, timeout). identity_resolved : (If SMP enabled) Notifies when a peer's identity address is resolved from an RPA. security_changed : (If SMP or Classic enabled) Called when connection security changes. remote_info_available : Called when info about the peer (features, roles) is available. le_phy_updated : Notifies when PHY is changed (1M, 2M, coded). le_data_len_updated : Called when the maximum payload size changes. tx_power_report : Reports transmit power changes. subrate_changed : Called when connection subrate settings change. These are mostly optional and only needed for advanced use cases.","title":"Other Available Callbacks in bt_conn_cb"},{"location":"ble-03-advert-connectable/#connection-and-disconnection-error-codes","text":"Both on_connected() and on_disconnected() callbacks report errors using HCI error codes defined by the Bluetooth Core Specification. These are standard codes used across the Bluetooth stack to indicate why a connection failed or was terminated. In on_connected() , the err parameter is 0 on success, or an HCI error (e.g., 0x3E for \"Connection Failed to be Established\"). In on_disconnected() , the reason parameter is also an HCI error code (e.g., 0x13 for \"Remote User Terminated Connection\"). These codes help identify common issues such as timeouts, user-initiated disconnects, or parameter mismatches. You can refer to the official list of controller error codes here: \ud83d\udd17 Bluetooth Core Spec v5.4 \u2013 Controller Error Codes","title":"Connection and Disconnection Error Codes"},{"location":"ble-04-conn-params/","text":"04 - BLE Connection Parameters Author: Tony Fu Date: 2025/4/6 Device: nRF52840 Dongle Toolchain: nRF Connect SDK v2.8.0 Core Connection Parameters These parameters were part of the original Bluetooth LE specification , and are exchanged during connection establishment. They define the timing and reliability of the connection. 1. Connection Interval Time between consecutive connection events (when devices wake up to communicate). Typical range: 7.5 ms to 4 s, in steps of 1.25 ms. Lower values = lower latency, higher power use. Higher values = longer sleep time, lower power use. 2. Supervision Timeout Max time allowed without successful packet reception before the connection is considered lost. Typical range: 100 ms to 32 s, in steps of 10 ms. Must be > (1 + peripheral latency) \u00d7 connection interval \u00d7 2. 3. Peripheral Latency Number of connection events the peripheral can skip if it has nothing to send. Typical values: 0\u2013499 (unitless). Allows the peripheral to save power while remaining in the connection. Note: The name is misleading \u2014 this is not a time duration , but a count of skipped events. In Action In the on_connect callback, we can print the 3 connection parameters: static void on_conn_established(struct bt_conn *conn, uint8_t err) { // ... other code active_conn = bt_conn_ref(conn); struct bt_conn_info info; if (bt_conn_get_info(conn, &info) == 0) { double int_ms = info.le.interval * 1.25; uint16_t timeout_ms = info.le.timeout * 10; LOG_INF(\"Initial conn params: %.2f ms, latency %u, timeout %u ms\", int_ms, info.le.latency, timeout_ms); } // ... other code } Note: Floating point math is not enabled by default, so we need to add CONFIG_FPU=y to the prj.conf file. Those parameters are typically first determined by the central device, and then the peripheral can request changes. To define our (i.e., the peripheral's) connection parameters, we can override the default values in the prj.conf file: # Set preferred connection parameters (units: 1.25ms for interval, 10ms for timeout) CONFIG_BT_PERIPHERAL_PREF_MIN_INT=320 CONFIG_BT_PERIPHERAL_PREF_MAX_INT=400 CONFIG_BT_PERIPHERAL_PREF_LATENCY=3 CONFIG_BT_PERIPHERAL_PREF_TIMEOUT=500 CONFIG_BT_GAP_AUTO_UPDATE_CONN_PARAMS=y The last line may be redundant, as it is enabled by default. It allows the peripheral to request a change in connection parameters after the initial connection. To get notified of the new parameters, we can implement the on_conn_param_update callback: static void handle_conn_param_change(struct bt_conn *conn, uint16_t interval, uint16_t latency, uint16_t timeout) { double interval_ms = interval * 1.25; uint16_t timeout_ms = timeout * 10; LOG_INF(\"Params changed: %.2f ms, latency %u, timeout %u ms\", interval_ms, latency, timeout_ms); } PHY Radio Modes The default mode is 1M PHY (1 Mbps), which is used for compatibility. 2M PHY (2 Mbps): Doubles throughput, reduces time on air, but may shorten range. Coded PHY : Increases range using redundancy, but at a lower data rate (125 kbps or 500 kbps). In Action First, we need to enable the PHY feature in the prj.conf file: CONFIG_BT_USER_PHY_UPDATE=y We can set the PHY mode again in the on_connect callback: static void on_conn_established(struct bt_conn *conn, uint8_t err) { // ... other code const struct bt_conn_le_phy_param phy_pref = { .options = BT_CONN_LE_PHY_OPT_NONE, .pref_rx_phy = BT_GAP_LE_PHY_2M, .pref_tx_phy = BT_GAP_LE_PHY_2M, }; int err = bt_conn_le_phy_update(conn, &phy_pref); if (err) { LOG_ERR(\"PHY update failed (%d)\", err); } // ... other code } To get notified of the PHY change, we can implement the on_phy_update callback: static void handle_phy_change(struct bt_conn *conn, struct bt_conn_le_phy_info *info) { switch (info->tx_phy) { case BT_CONN_LE_TX_POWER_PHY_1M: LOG_INF(\"PHY switched to 1M\"); break; case BT_CONN_LE_TX_POWER_PHY_2M: LOG_INF(\"PHY switched to 2M\"); break; case BT_CONN_LE_TX_POWER_PHY_CODED_S8: LOG_INF(\"PHY switched to Long Range\"); break; default: LOG_INF(\"PHY changed to unknown mode\"); break; } } Data Length vs MTU To understand how these differ, it's helpful to recall the Bluetooth LE stack layers : - GATT (Generic Attribute Profile): Application layer. You usually interact here. - L2CAP : Handles segmentation and reassembly of packets. - Link Layer : The lowest level; handles actual radio transmission. MTU (Maximum Transmission Unit) Maximum size of a single GATT operation (covered in next page). Default: 23 bytes. Can be increased after connection using MTU Exchange . Operates at the GATT / L2CAP level . You configure the maximum value with: Kconfig CONFIG_BT_L2CAP_TX_MTU=247 Data Length Maximum size of a single Link Layer PDU (packet). Default: 27 bytes. With BLE 4.2+, it can go up to 251 bytes . Controlled via Data Length Extension (DLE) . Even with a high MTU, a small data length will result in packet fragmentation . Configure this with: Kconfig CONFIG_BT_CTLR_DATA_LENGTH_MAX=251 CONFIG_BT_BUF_ACL_TX_SIZE=251 CONFIG_BT_BUF_ACL_RX_SIZE=251 Negotiating MTU and Data Length in Code Make sure data length updates are enabled: CONFIG_BT_USER_DATA_LEN_UPDATE=y Then, in your on_connected() callback: // Request a data length update (TX only) struct bt_conn_le_data_len_param len_params = { .tx_max_len = BT_GAP_DATA_LEN_MAX, // Usually 251 .tx_max_time = BT_GAP_DATA_TIME_MAX, // Usually 0x4290 (17040 \u00b5s) }; int err = bt_conn_le_data_len_update(conn, &len_params); if (err) { LOG_ERR(\"Failed to update data length (%d)\", err); } Why only TX? Because you can only propose values for your side of the connection. The peer will reply with what it supports for both TX and RX. The callback later gives you the final values for both ends. To negotiate the MTU: // Start MTU exchange \u2014 no need to specify desired MTU static struct bt_gatt_exchange_params params = { .func = mtu_exchange_cb // Called when negotiation is done }; err = bt_gatt_exchange_mtu(conn, &params); if (err) { LOG_ERR(\"MTU exchange failed (%d)\", err); } \ud83d\udcdd Why don't we set a value in params ? You don\u2019t pass the MTU manually. The stack reads CONFIG_BT_L2CAP_TX_MTU and automatically includes that in the ATT_Exchange_MTU_Request . The negotiated MTU is then: c min(our_mtu, peer_mtu) The callback: static void mtu_exchange_cb(struct bt_conn *conn, uint8_t err, struct bt_gatt_exchange_params *params) { if (!err) { uint16_t app_mtu = bt_gatt_get_mtu(conn) - 3; // 3 bytes = ATT header LOG_INF(\"MTU negotiated: %u bytes\", app_mtu); } else { LOG_ERR(\"MTU exchange failed (ATT err %u)\", err); } } Result: Callback confirms what was accepted static void handle_data_len_change(struct bt_conn *conn, struct bt_conn_le_data_len_info *info) { LOG_INF(\"Data len: TX=%u (%uus), RX=%u (%uus)\", info->tx_max_len, info->tx_max_time, info->rx_max_len, info->rx_max_time); } \ud83d\udcdd This tells you what both sides agreed on after negotiation \u2014 your request vs. what the peer supports. - TX: What you send - RX: What you receive","title":"BLE-Connection Parameters"},{"location":"ble-04-conn-params/#04-ble-connection-parameters","text":"Author: Tony Fu Date: 2025/4/6 Device: nRF52840 Dongle Toolchain: nRF Connect SDK v2.8.0","title":"04 - BLE Connection Parameters"},{"location":"ble-04-conn-params/#core-connection-parameters","text":"These parameters were part of the original Bluetooth LE specification , and are exchanged during connection establishment. They define the timing and reliability of the connection.","title":"Core Connection Parameters"},{"location":"ble-04-conn-params/#1-connection-interval","text":"Time between consecutive connection events (when devices wake up to communicate). Typical range: 7.5 ms to 4 s, in steps of 1.25 ms. Lower values = lower latency, higher power use. Higher values = longer sleep time, lower power use.","title":"1. Connection Interval"},{"location":"ble-04-conn-params/#2-supervision-timeout","text":"Max time allowed without successful packet reception before the connection is considered lost. Typical range: 100 ms to 32 s, in steps of 10 ms. Must be > (1 + peripheral latency) \u00d7 connection interval \u00d7 2.","title":"2. Supervision Timeout"},{"location":"ble-04-conn-params/#3-peripheral-latency","text":"Number of connection events the peripheral can skip if it has nothing to send. Typical values: 0\u2013499 (unitless). Allows the peripheral to save power while remaining in the connection. Note: The name is misleading \u2014 this is not a time duration , but a count of skipped events.","title":"3. Peripheral Latency"},{"location":"ble-04-conn-params/#in-action","text":"In the on_connect callback, we can print the 3 connection parameters: static void on_conn_established(struct bt_conn *conn, uint8_t err) { // ... other code active_conn = bt_conn_ref(conn); struct bt_conn_info info; if (bt_conn_get_info(conn, &info) == 0) { double int_ms = info.le.interval * 1.25; uint16_t timeout_ms = info.le.timeout * 10; LOG_INF(\"Initial conn params: %.2f ms, latency %u, timeout %u ms\", int_ms, info.le.latency, timeout_ms); } // ... other code } Note: Floating point math is not enabled by default, so we need to add CONFIG_FPU=y to the prj.conf file. Those parameters are typically first determined by the central device, and then the peripheral can request changes. To define our (i.e., the peripheral's) connection parameters, we can override the default values in the prj.conf file: # Set preferred connection parameters (units: 1.25ms for interval, 10ms for timeout) CONFIG_BT_PERIPHERAL_PREF_MIN_INT=320 CONFIG_BT_PERIPHERAL_PREF_MAX_INT=400 CONFIG_BT_PERIPHERAL_PREF_LATENCY=3 CONFIG_BT_PERIPHERAL_PREF_TIMEOUT=500 CONFIG_BT_GAP_AUTO_UPDATE_CONN_PARAMS=y The last line may be redundant, as it is enabled by default. It allows the peripheral to request a change in connection parameters after the initial connection. To get notified of the new parameters, we can implement the on_conn_param_update callback: static void handle_conn_param_change(struct bt_conn *conn, uint16_t interval, uint16_t latency, uint16_t timeout) { double interval_ms = interval * 1.25; uint16_t timeout_ms = timeout * 10; LOG_INF(\"Params changed: %.2f ms, latency %u, timeout %u ms\", interval_ms, latency, timeout_ms); }","title":"In Action"},{"location":"ble-04-conn-params/#phy-radio-modes","text":"The default mode is 1M PHY (1 Mbps), which is used for compatibility. 2M PHY (2 Mbps): Doubles throughput, reduces time on air, but may shorten range. Coded PHY : Increases range using redundancy, but at a lower data rate (125 kbps or 500 kbps).","title":"PHY Radio Modes"},{"location":"ble-04-conn-params/#in-action_1","text":"First, we need to enable the PHY feature in the prj.conf file: CONFIG_BT_USER_PHY_UPDATE=y We can set the PHY mode again in the on_connect callback: static void on_conn_established(struct bt_conn *conn, uint8_t err) { // ... other code const struct bt_conn_le_phy_param phy_pref = { .options = BT_CONN_LE_PHY_OPT_NONE, .pref_rx_phy = BT_GAP_LE_PHY_2M, .pref_tx_phy = BT_GAP_LE_PHY_2M, }; int err = bt_conn_le_phy_update(conn, &phy_pref); if (err) { LOG_ERR(\"PHY update failed (%d)\", err); } // ... other code } To get notified of the PHY change, we can implement the on_phy_update callback: static void handle_phy_change(struct bt_conn *conn, struct bt_conn_le_phy_info *info) { switch (info->tx_phy) { case BT_CONN_LE_TX_POWER_PHY_1M: LOG_INF(\"PHY switched to 1M\"); break; case BT_CONN_LE_TX_POWER_PHY_2M: LOG_INF(\"PHY switched to 2M\"); break; case BT_CONN_LE_TX_POWER_PHY_CODED_S8: LOG_INF(\"PHY switched to Long Range\"); break; default: LOG_INF(\"PHY changed to unknown mode\"); break; } }","title":"In Action"},{"location":"ble-04-conn-params/#data-length-vs-mtu","text":"To understand how these differ, it's helpful to recall the Bluetooth LE stack layers : - GATT (Generic Attribute Profile): Application layer. You usually interact here. - L2CAP : Handles segmentation and reassembly of packets. - Link Layer : The lowest level; handles actual radio transmission.","title":"Data Length vs MTU"},{"location":"ble-04-conn-params/#mtu-maximum-transmission-unit","text":"Maximum size of a single GATT operation (covered in next page). Default: 23 bytes. Can be increased after connection using MTU Exchange . Operates at the GATT / L2CAP level . You configure the maximum value with: Kconfig CONFIG_BT_L2CAP_TX_MTU=247","title":"MTU (Maximum Transmission Unit)"},{"location":"ble-04-conn-params/#data-length","text":"Maximum size of a single Link Layer PDU (packet). Default: 27 bytes. With BLE 4.2+, it can go up to 251 bytes . Controlled via Data Length Extension (DLE) . Even with a high MTU, a small data length will result in packet fragmentation . Configure this with: Kconfig CONFIG_BT_CTLR_DATA_LENGTH_MAX=251 CONFIG_BT_BUF_ACL_TX_SIZE=251 CONFIG_BT_BUF_ACL_RX_SIZE=251","title":"Data Length"},{"location":"ble-04-conn-params/#negotiating-mtu-and-data-length-in-code","text":"Make sure data length updates are enabled: CONFIG_BT_USER_DATA_LEN_UPDATE=y Then, in your on_connected() callback: // Request a data length update (TX only) struct bt_conn_le_data_len_param len_params = { .tx_max_len = BT_GAP_DATA_LEN_MAX, // Usually 251 .tx_max_time = BT_GAP_DATA_TIME_MAX, // Usually 0x4290 (17040 \u00b5s) }; int err = bt_conn_le_data_len_update(conn, &len_params); if (err) { LOG_ERR(\"Failed to update data length (%d)\", err); } Why only TX? Because you can only propose values for your side of the connection. The peer will reply with what it supports for both TX and RX. The callback later gives you the final values for both ends. To negotiate the MTU: // Start MTU exchange \u2014 no need to specify desired MTU static struct bt_gatt_exchange_params params = { .func = mtu_exchange_cb // Called when negotiation is done }; err = bt_gatt_exchange_mtu(conn, &params); if (err) { LOG_ERR(\"MTU exchange failed (%d)\", err); } \ud83d\udcdd Why don't we set a value in params ? You don\u2019t pass the MTU manually. The stack reads CONFIG_BT_L2CAP_TX_MTU and automatically includes that in the ATT_Exchange_MTU_Request . The negotiated MTU is then: c min(our_mtu, peer_mtu) The callback: static void mtu_exchange_cb(struct bt_conn *conn, uint8_t err, struct bt_gatt_exchange_params *params) { if (!err) { uint16_t app_mtu = bt_gatt_get_mtu(conn) - 3; // 3 bytes = ATT header LOG_INF(\"MTU negotiated: %u bytes\", app_mtu); } else { LOG_ERR(\"MTU exchange failed (ATT err %u)\", err); } }","title":"Negotiating MTU and Data Length in Code"},{"location":"ble-04-conn-params/#result-callback-confirms-what-was-accepted","text":"static void handle_data_len_change(struct bt_conn *conn, struct bt_conn_le_data_len_info *info) { LOG_INF(\"Data len: TX=%u (%uus), RX=%u (%uus)\", info->tx_max_len, info->tx_max_time, info->rx_max_len, info->rx_max_time); } \ud83d\udcdd This tells you what both sides agreed on after negotiation \u2014 your request vs. what the peer supports. - TX: What you send - RX: What you receive","title":"Result: Callback confirms what was accepted"},{"location":"ble-05-gatt-client/","text":"05 - BLE GATT Client-Initiated Operations Author: Tony Fu Date: 2025/4/6 Device: nRF52840 Dongle Toolchain: nRF Connect SDK v2.8.0 In the GATT protocol, the server holds the data. The client can request the server to perform operations such as read , write , or write without response \u2014 these are known as client-initiated operations . Alternatively, the client can subscribe to notifications or indications , which are server-initiated operations . This note focuses on client-initiated operations . The server-side implementation will be covered in a later note. We will walk through how to define a custom 128-bit UUID GATT service with both readable and writable characteristics in Zephyr, using the Nordic SDK style. 1. Create a File: my_service.h This header will define the UUIDs, callback types, and initialization function needed for the custom service. 2. Encode the UUIDs Using BT_UUID_128_ENCODE Zephyr provides a helper macro to define a 128-bit UUID: BT_UUID_128_ENCODE(w32, w1, w2, w3, w48) This macro converts your UUID into little-endian byte order suitable for Zephyr\u2019s internal structures. It's commonly used when defining: - Service UUIDs - Characteristic UUIDs - Advertising UUIDs Parameters: Param Size Description w32 32b First field of the UUID w1 16b Second field w2 16b Third field w3 16b Fourth field w48 48b Final field (usually vendor part) Just take your UUID, replace the dashes with commas, and prefix each value with 0x . Example: If your 128-bit UUID is: 12345678-9abc-def0-1234-56789abcdef0 You can encode it like: #define BT_UUID_MY_SERVICE_VAL \\ BT_UUID_128_ENCODE(0x12345678, 0x9abc, 0xdef0, 0x1234, 0x56789abcdef0) And then define characteristics with similar base UUIDs: #define BT_UUID_MY_CHAR_READ_VAL \\ BT_UUID_128_ENCODE(0x12345678, 0x9abc, 0xdef0, 0x1234, 0x56789abcdef1) #define BT_UUID_MY_CHAR_WRITE_VAL \\ BT_UUID_128_ENCODE(0x12345678, 0x9abc, 0xdef0, 0x1234, 0x56789abcdef2) \ud83d\udca1 Naming convention (rule of thumb): - The first few fields can vary by purpose (e.g., 1 service, multiple characteristics). - The final 48 bits are often treated as the vendor-defined base. - No strict rules \u2014 just make sure they\u2019re unique. 3. Declare the UUIDs Encoding a UUID gives you a byte array. To use them in APIs like BT_GATT_PRIMARY_SERVICE() or BT_GATT_CHARACTERISTIC() , you must wrap them with BT_UUID_DECLARE_128() : #define BT_UUID_MY_SERVICE BT_UUID_DECLARE_128(BT_UUID_MY_SERVICE_VAL) #define BT_UUID_MY_CHAR_READ BT_UUID_DECLARE_128(BT_UUID_MY_CHAR_READ_VAL) #define BT_UUID_MY_CHAR_WRITE BT_UUID_DECLARE_128(BT_UUID_MY_CHAR_WRITE_VAL) This declares each UUID as a const struct bt_uuid * that can be used with Zephyr\u2019s GATT API. 4. Create a File: my_service.c This file implements the callbacks, the internal state, and defines the GATT service. 5. Implement the Read Callback Include the needed headers: #include <zephyr/bluetooth/bluetooth.h> #include <zephyr/bluetooth/gatt.h> Implement the read callback: static uint8_t stored_value; static ssize_t on_read(struct bt_conn *conn, const struct bt_gatt_attr *attr, void *buf, uint16_t len, uint16_t offset) { LOG_INF(\"Read request received\"); return bt_gatt_attr_read(conn, attr, buf, len, offset, &stored_value, sizeof(stored_value)); } bt_gatt_attr_read() is a helper that reads from a memory buffer and does bounds checking for you. 6. Implement the Write Callback static struct my_service_cb service_cb; static ssize_t on_write(struct bt_conn *conn, const struct bt_gatt_attr *attr, const void *buf, uint16_t len, uint16_t offset, uint8_t flags) { if (offset != 0 || len != 1) { return BT_GATT_ERR(BT_ATT_ERR_INVALID_ATTRIBUTE_LEN); } uint8_t val = *((uint8_t *)buf); stored_value = val; LOG_INF(\"New value written: %d\", stored_value); if (service_cb.on_write) { service_cb.on_write(val); } return len; } You can choose to act immediately on the written value, or store it for later use. 7. Define a Callback Struct and Init Function Define the callback type and storage: typedef void (*my_write_cb_t)(uint8_t new_value); struct my_service_cb { my_write_cb_t on_write; }; Then implement a simple init function: int my_service_init(struct my_service_cb *cb) { if (cb) { service_cb = *cb; } LOG_INF(\"Custom service initialized\"); return 0; } This lets users register custom application logic on writes. 8. Define the GATT Service Declare your service and characteristics using BT_GATT_SERVICE_DEFINE : BT_GATT_SERVICE_DEFINE(my_svc, BT_GATT_PRIMARY_SERVICE(BT_UUID_MY_SERVICE), BT_GATT_CHARACTERISTIC(BT_UUID_MY_CHAR_READ, BT_GATT_CHRC_READ, BT_GATT_PERM_READ, on_read, NULL, &stored_value), BT_GATT_CHARACTERISTIC(BT_UUID_MY_CHAR_WRITE, BT_GATT_CHRC_WRITE, BT_GATT_PERM_WRITE, NULL, on_write, NULL) ); 9. Use the Service in main.c Register your service in main() : #include \"my_service.h\" void my_write_handler(uint8_t value) { LOG_INF(\"Value changed by client to %d\", value); } void main(void) { bt_enable(NULL); struct my_service_cb cb = { .on_write = my_write_handler, }; my_service_init(&cb); bt_le_adv_start(BT_LE_ADV_CONN, ad, ARRAY_SIZE(ad), sd, ARRAY_SIZE(sd)); }","title":"BLE-GATT Client Operations"},{"location":"ble-05-gatt-client/#05-ble-gatt-client-initiated-operations","text":"Author: Tony Fu Date: 2025/4/6 Device: nRF52840 Dongle Toolchain: nRF Connect SDK v2.8.0 In the GATT protocol, the server holds the data. The client can request the server to perform operations such as read , write , or write without response \u2014 these are known as client-initiated operations . Alternatively, the client can subscribe to notifications or indications , which are server-initiated operations . This note focuses on client-initiated operations . The server-side implementation will be covered in a later note. We will walk through how to define a custom 128-bit UUID GATT service with both readable and writable characteristics in Zephyr, using the Nordic SDK style.","title":"05 - BLE GATT Client-Initiated Operations"},{"location":"ble-05-gatt-client/#1-create-a-file-my_serviceh","text":"This header will define the UUIDs, callback types, and initialization function needed for the custom service.","title":"1. Create a File: my_service.h"},{"location":"ble-05-gatt-client/#2-encode-the-uuids-using-bt_uuid_128_encode","text":"Zephyr provides a helper macro to define a 128-bit UUID: BT_UUID_128_ENCODE(w32, w1, w2, w3, w48) This macro converts your UUID into little-endian byte order suitable for Zephyr\u2019s internal structures. It's commonly used when defining: - Service UUIDs - Characteristic UUIDs - Advertising UUIDs","title":"2. Encode the UUIDs Using BT_UUID_128_ENCODE"},{"location":"ble-05-gatt-client/#parameters","text":"Param Size Description w32 32b First field of the UUID w1 16b Second field w2 16b Third field w3 16b Fourth field w48 48b Final field (usually vendor part) Just take your UUID, replace the dashes with commas, and prefix each value with 0x .","title":"Parameters:"},{"location":"ble-05-gatt-client/#example","text":"If your 128-bit UUID is: 12345678-9abc-def0-1234-56789abcdef0 You can encode it like: #define BT_UUID_MY_SERVICE_VAL \\ BT_UUID_128_ENCODE(0x12345678, 0x9abc, 0xdef0, 0x1234, 0x56789abcdef0) And then define characteristics with similar base UUIDs: #define BT_UUID_MY_CHAR_READ_VAL \\ BT_UUID_128_ENCODE(0x12345678, 0x9abc, 0xdef0, 0x1234, 0x56789abcdef1) #define BT_UUID_MY_CHAR_WRITE_VAL \\ BT_UUID_128_ENCODE(0x12345678, 0x9abc, 0xdef0, 0x1234, 0x56789abcdef2) \ud83d\udca1 Naming convention (rule of thumb): - The first few fields can vary by purpose (e.g., 1 service, multiple characteristics). - The final 48 bits are often treated as the vendor-defined base. - No strict rules \u2014 just make sure they\u2019re unique.","title":"Example:"},{"location":"ble-05-gatt-client/#3-declare-the-uuids","text":"Encoding a UUID gives you a byte array. To use them in APIs like BT_GATT_PRIMARY_SERVICE() or BT_GATT_CHARACTERISTIC() , you must wrap them with BT_UUID_DECLARE_128() : #define BT_UUID_MY_SERVICE BT_UUID_DECLARE_128(BT_UUID_MY_SERVICE_VAL) #define BT_UUID_MY_CHAR_READ BT_UUID_DECLARE_128(BT_UUID_MY_CHAR_READ_VAL) #define BT_UUID_MY_CHAR_WRITE BT_UUID_DECLARE_128(BT_UUID_MY_CHAR_WRITE_VAL) This declares each UUID as a const struct bt_uuid * that can be used with Zephyr\u2019s GATT API.","title":"3. Declare the UUIDs"},{"location":"ble-05-gatt-client/#4-create-a-file-my_servicec","text":"This file implements the callbacks, the internal state, and defines the GATT service.","title":"4. Create a File: my_service.c"},{"location":"ble-05-gatt-client/#5-implement-the-read-callback","text":"Include the needed headers: #include <zephyr/bluetooth/bluetooth.h> #include <zephyr/bluetooth/gatt.h> Implement the read callback: static uint8_t stored_value; static ssize_t on_read(struct bt_conn *conn, const struct bt_gatt_attr *attr, void *buf, uint16_t len, uint16_t offset) { LOG_INF(\"Read request received\"); return bt_gatt_attr_read(conn, attr, buf, len, offset, &stored_value, sizeof(stored_value)); } bt_gatt_attr_read() is a helper that reads from a memory buffer and does bounds checking for you.","title":"5. Implement the Read Callback"},{"location":"ble-05-gatt-client/#6-implement-the-write-callback","text":"static struct my_service_cb service_cb; static ssize_t on_write(struct bt_conn *conn, const struct bt_gatt_attr *attr, const void *buf, uint16_t len, uint16_t offset, uint8_t flags) { if (offset != 0 || len != 1) { return BT_GATT_ERR(BT_ATT_ERR_INVALID_ATTRIBUTE_LEN); } uint8_t val = *((uint8_t *)buf); stored_value = val; LOG_INF(\"New value written: %d\", stored_value); if (service_cb.on_write) { service_cb.on_write(val); } return len; } You can choose to act immediately on the written value, or store it for later use.","title":"6. Implement the Write Callback"},{"location":"ble-05-gatt-client/#7-define-a-callback-struct-and-init-function","text":"Define the callback type and storage: typedef void (*my_write_cb_t)(uint8_t new_value); struct my_service_cb { my_write_cb_t on_write; }; Then implement a simple init function: int my_service_init(struct my_service_cb *cb) { if (cb) { service_cb = *cb; } LOG_INF(\"Custom service initialized\"); return 0; } This lets users register custom application logic on writes.","title":"7. Define a Callback Struct and Init Function"},{"location":"ble-05-gatt-client/#8-define-the-gatt-service","text":"Declare your service and characteristics using BT_GATT_SERVICE_DEFINE : BT_GATT_SERVICE_DEFINE(my_svc, BT_GATT_PRIMARY_SERVICE(BT_UUID_MY_SERVICE), BT_GATT_CHARACTERISTIC(BT_UUID_MY_CHAR_READ, BT_GATT_CHRC_READ, BT_GATT_PERM_READ, on_read, NULL, &stored_value), BT_GATT_CHARACTERISTIC(BT_UUID_MY_CHAR_WRITE, BT_GATT_CHRC_WRITE, BT_GATT_PERM_WRITE, NULL, on_write, NULL) );","title":"8. Define the GATT Service"},{"location":"ble-05-gatt-client/#9-use-the-service-in-mainc","text":"Register your service in main() : #include \"my_service.h\" void my_write_handler(uint8_t value) { LOG_INF(\"Value changed by client to %d\", value); } void main(void) { bt_enable(NULL); struct my_service_cb cb = { .on_write = my_write_handler, }; my_service_init(&cb); bt_le_adv_start(BT_LE_ADV_CONN, ad, ARRAY_SIZE(ad), sd, ARRAY_SIZE(sd)); }","title":"9. Use the Service in main.c"},{"location":"ble-06-gatt-server/","text":"06 - BLE GATT Server-Initiated Operations Author: Tony Fu Date: 2025/4/6 Device: nRF52840 Dongle Toolchain: nRF Connect SDK v2.8.0 Before diving into server-initiated operations like notifications and indications , it\u2019s important to understand the layers beneath them: ATT and GATT . These layers form the foundation of BLE\u2019s server-client communication model. We want to get comfortable with GATT , as it\u2019s the layer most application developers interact with. But beneath GATT lies ATT , which provides the raw data transport mechanism. ATT (Attribute Protocol) ATT defines a minimal protocol for exposing data as a list of attributes on the server. Each attribute is a generic container that GATT builds upon (services, characteristics, descriptors). An ATT attribute consists of: Field Size Description Handle 2 bytes A unique ID for the attribute on the server. Used by clients to reference it. Type 2 or 16 bytes A UUID that indicates what kind of attribute this is (e.g., service, characteristic). Permission \u2014 Access control: read, write, notify, etc. Value Variable Actual data content (e.g., the characteristic's value). Common Attribute Types These are 16-bit standardized UUIDs defined by the Bluetooth SIG. They are used to define structure within a GATT service: Type (UUID) Description Meaning 0x2800 Primary Service Marks the beginning of a primary service declaration. 0x2801 Secondary Service Used to define a secondary (helper) service that is referenced by another. 0x2803 Characteristic Declaration Describes a characteristic: includes properties, handle, and UUID. 0x2901 Characteristic User Description Human-readable label (e.g., \"Heart Rate\" ). Shown in GUIs. 0x2902 Client Characteristic Configuration (CCCD) Lets clients enable notifications or indications for a characteristic. GATT uses these generic ATT attributes to structure and organize the data. The type of a characteristic is defined by its UUID, which can be a 16-bit or 128-bit value. Attribute Permissions Each attribute has a set of permissions that control how clients are allowed to interact with it \u2014 such as whether it can be read, written, or requires a secure connection. These permissions are enforced by the ATT server , regardless of what the characteristic claims to support (via its properties). Here's a mapping of common permissions: Permission Description Zephyr Macro Plain Read Client can read the attribute value. BT_GATT_PERM_READ Plain Write Client can write a new value. BT_GATT_PERM_WRITE Encrypted Read Read only allowed over an encrypted connection. BT_GATT_PERM_READ_ENCRYPT Encrypted Write Write only allowed over an encrypted connection. BT_GATT_PERM_WRITE_ENCRYPT Authenticated Read Read allowed only after authentication (e.g., MITM pairing). BT_GATT_PERM_READ_AUTHEN Authenticated Write Write allowed only after authentication (e.g., MITM pairing). BT_GATT_PERM_WRITE_AUTHEN LESC Read Read requires LE Secure Connections. BT_GATT_PERM_READ_LESC LESC Write Write requires LE Secure Connections. BT_GATT_PERM_WRITE_LESC Prepare Write Attribute supports queued writes (long/atomic writes). BT_GATT_PERM_PREPARE_WRITE \ud83d\udd10 When no appropriate permissions are granted (e.g., no BT_GATT_PERM_READ ), the server will reject the client\u2019s operation with an ATT error like Read Not Permitted . This permission layer acts independently from characteristic properties , which simply advertise what can be done \u2014 permissions control what is actually allowed at runtime. Also, here is a quick note on the different security levels (will be covered in more detail later): Encrypted access means the connection must be encrypted (e.g., after pairing). This protects data from passive eavesdropping. Authenticated access goes a step further \u2014 the connection must be encrypted and use an authenticated key (typically generated with MITM protection, like passkey entry). This defends against impersonation attacks. LESC (LE Secure Connections) is a newer pairing method introduced in Bluetooth 4.2. It uses Elliptic Curve Diffie-Hellman (ECDH) for key exchange and offers stronger protection against passive and active attacks compared to older methods. GATT (Generic Attribute Profile) The Generic Attribute Profile (GATT) defines how the low-level attributes defined by the ATT protocol are grouped and interpreted to represent meaningful data. While ATT is concerned purely with the format and transport of attributes (each with a handle, type, permissions, and value), GATT gives structure to those attributes by organizing them into logical groupings like services , characteristics , and descriptors . At its core, GATT uses multiple ATT attributes to represent each component: A Service is a collection of related characteristics (e.g., the Heart Rate Service). A Characteristic represents a data item (e.g., current heart rate) and is made up of three attributes: a declaration , a value , and optional descriptors . A Descriptor is additional metadata about a characteristic, such as a human-readable label or client configuration (e.g., enabling notifications). Each attribute is given a handle, type, permssions, and value. Handles are assgined by the server and can vary between different BLE stacks, but it is worth discussing the other three fields in more detail: 1. Service Declaration Type Permission Value 0x2800 (Primary) or 0x2801 (Secondary) Read UUID of the service (e.g., 0x180F for Battery Service) 2. Characteristic Declaration Type Permission Value 0x2803 (Characteristic Declaration) Read - Properties (1 byte): Bitfield indicating allowed operations (e.g., Read, Write, Notify). - Value Handle (2 bytes): Handle pointing to the Characteristic Value attribute. - Characteristic UUID (2 or 16 bytes): UUID of the characteristic. 3. Characteristic Value Type (UUID of Characteristic) Permission Value The UUID of the characteristic (e.g., 0x2A19 for Battery Level) Depends on characteristic (e.g., Read, Write, Notify) Raw data (e.g., sensor reading, config byte). This is the actual payload a client interacts with. 4. Descriptor Attribute (optional) Type Permission Value e.g., 0x2901 (User Description), 0x2902 (CCCD) Depends on descriptor: - 0x2901 : Read - 0x2902 : Read/Write - User Description (0x2901) : Human-readable name of the characteristic (e.g., \"Temperature\"). - CCCD (0x2902) : 2-byte bitfield that enables notifications and/or indications. - Others: May define triggers, ranges, or valid formats. Service-Initiated Operations: Indication and Notification Indication and notification are operations used to push data from a GATT server to a client. Notification is a lightweight, unacknowledged data push. It is suitable for non-critical or frequently changing data, such as sensor streams or status updates. Notifications are fast but not guaranteed to arrive. Indication is a reliable, acknowledged mechanism. Each indication must be confirmed by the client before the next can be sent. This makes it ideal for critical data or state changes that must be received. Use notification for speed and simplicity. Use indication when reliability is essential. In Action Purpose of this example This example demonstrates how to create a custom GATT service with three characteristics: Command characteristic (Write): receives a control byte from a client (e.g., phone). Critical characteristic (Indicate): used to send important data that requires acknowledgment. Non-critical characteristic (Notify): used to send less important, best-effort data. The purpose is to test how a peripheral (nRF52840 dongle) can push different types of data to a central (like a phone), depending on a command it receives. Writing 0x00 triggers a notification, while any non-zero value triggers an indication. Steps to implement Step 1. Declare UUIDs Custom 128-bit UUIDs are declared for the service and each of the three characteristics. This is just like what we have done in the previous example. #include <zephyr/types.h> #include <zephyr/bluetooth/uuid.h> #define BT_UUID_TEST_SERVICE_VAL BT_UUID_128_ENCODE(0x12345678, 0x9abc, 0xdef0, 0x1234, 0x56789abcdef0) #define BT_UUID_TEST_CMD_VAL BT_UUID_128_ENCODE(0x12345678, 0x9abc, 0xdef0, 0x1234, 0x56789abcdef1) #define BT_UUID_TEST_CRITICAL_VAL BT_UUID_128_ENCODE(0x12345678, 0x9abc, 0xdef0, 0x1234, 0x56789abcdef2) #define BT_UUID_TEST_NONCRITICAL_VAL BT_UUID_128_ENCODE(0x12345678, 0x9abc, 0xdef0, 0x1234, 0x56789abcdef3) #define BT_UUID_TEST_SERVICE BT_UUID_DECLARE_128(BT_UUID_TEST_SERVICE_VAL) #define BT_UUID_TEST_CMD BT_UUID_DECLARE_128(BT_UUID_TEST_CMD_VAL) #define BT_UUID_TEST_CRITICAL BT_UUID_DECLARE_128(BT_UUID_TEST_CRITICAL_VAL) #define BT_UUID_TEST_NONCRITICAL BT_UUID_DECLARE_128(BT_UUID_TEST_NONCRITICAL_VAL) Step 2. Define the service and characteristics Here we define the service and its characteristics using BT_GATT_SERVICE_DEFINE . Each characteristic is assigned appropriate properties ( WRITE , INDICATE , NOTIFY ) and permissions. BT_GATT_SERVICE_DEFINE(test_svc, BT_GATT_PRIMARY_SERVICE(BT_UUID_TEST_SERVICE), BT_GATT_CHARACTERISTIC(BT_UUID_TEST_CMD, BT_GATT_CHRC_WRITE, BT_GATT_PERM_WRITE, NULL, write_cmd, NULL), BT_GATT_CHARACTERISTIC(BT_UUID_TEST_CRITICAL, BT_GATT_CHRC_INDICATE, BT_GATT_PERM_NONE, NULL, NULL, NULL), BT_GATT_CCC(critical_ccc_cfg_changed, BT_GATT_PERM_READ | BT_GATT_PERM_WRITE), BT_GATT_CHARACTERISTIC(BT_UUID_TEST_NONCRITICAL, BT_GATT_CHRC_NOTIFY, BT_GATT_PERM_NONE, NULL, NULL, NULL), BT_GATT_CCC(noncritical_ccc_cfg_changed, BT_GATT_PERM_READ | BT_GATT_PERM_WRITE) ); Note : BT_GATT_CCC adds a Client Characteristic Configuration Descriptor, which allows the client to enable or disable notifications/indications. Step 3. Define the CCCD callback functions These callbacks are used in the previous step to handle changes in the CCCD values. static bool notify_enabled; static bool indicate_enabled; static void critical_ccc_cfg_changed(const struct bt_gatt_attr *attr, uint16_t value) { indicate_enabled = (value == BT_GATT_CCC_INDICATE); LOG_INF(\"Indicate enabled: %s\", indicate_enabled ? \"true\" : \"false\"); } static void noncritical_ccc_cfg_changed(const struct bt_gatt_attr *attr, uint16_t value) { notify_enabled = (value == BT_GATT_CCC_NOTIFY); LOG_INF(\"Notify enabled: %s\", notify_enabled ? \"true\" : \"false\"); } Step 4. Define the write callback function The write callback interprets the value written by the client and sends either a notification or an indication. static struct bt_gatt_indicate_params ind_params; static uint8_t dummy_cmd; static ssize_t write_cmd(struct bt_conn *conn, const struct bt_gatt_attr *attr, const void *buf, uint16_t len, uint16_t offset, uint8_t flags) { if (len != sizeof(uint8_t)) { return BT_GATT_ERR(BT_ATT_ERR_INVALID_ATTRIBUTE_LEN); } dummy_cmd = *((uint8_t *)buf); const uint32_t dummy_data = 0xAABBCCDD; if (dummy_cmd) { // Indicate critical data if (!indicate_enabled) { LOG_WRN(\"Indications not enabled\"); return -EACCES; } LOG_INF(\"Indicating critical data: %x\", dummy_data); ind_params.attr = &test_svc.attrs[3]; ind_params.func = indicate_cb; ind_params.data = &dummy_data; ind_params.len = sizeof(dummy_data); return bt_gatt_indicate(NULL, &ind_params); } else { // Notify non-critical data if (!notify_enabled) { LOG_WRN(\"Notifications not enabled\"); return -EACCES; } LOG_INF(\"Notifying non-critical data: %x\", dummy_data); return bt_gatt_notify(NULL, &test_svc.attrs[6], &dummy_data, sizeof(dummy_data)); } } Note : - bt_gatt_indicate() uses a parameter structure because it handles asynchronous acknowledgment. - bt_gatt_notify() is simpler\u2014no acknowledgment, no callback, just send. - The attr indices for .attrs[3] and .attrs[6] refer to the characteristic declaration attribute , not the value or CCCD. Remember: - Service declaration = 1 attribute - Each characteristic = 2 attributes (declaration + value) - Optional CCCD = 1 attribute - So manually counting the offsets is required unless dynamic lookup is used. Step 5. Define the indication callback This is called after the client acknowledges the indication. static void indicate_cb(struct bt_conn *conn, struct bt_gatt_indicate_params *params, uint8_t err) { LOG_DBG(\"Indication result: %s\", err == 0U ? \"success\" : \"fail\"); }","title":"BLE-GATT Server Operations"},{"location":"ble-06-gatt-server/#06-ble-gatt-server-initiated-operations","text":"Author: Tony Fu Date: 2025/4/6 Device: nRF52840 Dongle Toolchain: nRF Connect SDK v2.8.0 Before diving into server-initiated operations like notifications and indications , it\u2019s important to understand the layers beneath them: ATT and GATT . These layers form the foundation of BLE\u2019s server-client communication model. We want to get comfortable with GATT , as it\u2019s the layer most application developers interact with. But beneath GATT lies ATT , which provides the raw data transport mechanism.","title":"06 - BLE GATT Server-Initiated Operations"},{"location":"ble-06-gatt-server/#att-attribute-protocol","text":"ATT defines a minimal protocol for exposing data as a list of attributes on the server. Each attribute is a generic container that GATT builds upon (services, characteristics, descriptors). An ATT attribute consists of: Field Size Description Handle 2 bytes A unique ID for the attribute on the server. Used by clients to reference it. Type 2 or 16 bytes A UUID that indicates what kind of attribute this is (e.g., service, characteristic). Permission \u2014 Access control: read, write, notify, etc. Value Variable Actual data content (e.g., the characteristic's value).","title":"ATT (Attribute Protocol)"},{"location":"ble-06-gatt-server/#common-attribute-types","text":"These are 16-bit standardized UUIDs defined by the Bluetooth SIG. They are used to define structure within a GATT service: Type (UUID) Description Meaning 0x2800 Primary Service Marks the beginning of a primary service declaration. 0x2801 Secondary Service Used to define a secondary (helper) service that is referenced by another. 0x2803 Characteristic Declaration Describes a characteristic: includes properties, handle, and UUID. 0x2901 Characteristic User Description Human-readable label (e.g., \"Heart Rate\" ). Shown in GUIs. 0x2902 Client Characteristic Configuration (CCCD) Lets clients enable notifications or indications for a characteristic. GATT uses these generic ATT attributes to structure and organize the data. The type of a characteristic is defined by its UUID, which can be a 16-bit or 128-bit value.","title":"Common Attribute Types"},{"location":"ble-06-gatt-server/#attribute-permissions","text":"Each attribute has a set of permissions that control how clients are allowed to interact with it \u2014 such as whether it can be read, written, or requires a secure connection. These permissions are enforced by the ATT server , regardless of what the characteristic claims to support (via its properties). Here's a mapping of common permissions: Permission Description Zephyr Macro Plain Read Client can read the attribute value. BT_GATT_PERM_READ Plain Write Client can write a new value. BT_GATT_PERM_WRITE Encrypted Read Read only allowed over an encrypted connection. BT_GATT_PERM_READ_ENCRYPT Encrypted Write Write only allowed over an encrypted connection. BT_GATT_PERM_WRITE_ENCRYPT Authenticated Read Read allowed only after authentication (e.g., MITM pairing). BT_GATT_PERM_READ_AUTHEN Authenticated Write Write allowed only after authentication (e.g., MITM pairing). BT_GATT_PERM_WRITE_AUTHEN LESC Read Read requires LE Secure Connections. BT_GATT_PERM_READ_LESC LESC Write Write requires LE Secure Connections. BT_GATT_PERM_WRITE_LESC Prepare Write Attribute supports queued writes (long/atomic writes). BT_GATT_PERM_PREPARE_WRITE \ud83d\udd10 When no appropriate permissions are granted (e.g., no BT_GATT_PERM_READ ), the server will reject the client\u2019s operation with an ATT error like Read Not Permitted . This permission layer acts independently from characteristic properties , which simply advertise what can be done \u2014 permissions control what is actually allowed at runtime. Also, here is a quick note on the different security levels (will be covered in more detail later): Encrypted access means the connection must be encrypted (e.g., after pairing). This protects data from passive eavesdropping. Authenticated access goes a step further \u2014 the connection must be encrypted and use an authenticated key (typically generated with MITM protection, like passkey entry). This defends against impersonation attacks. LESC (LE Secure Connections) is a newer pairing method introduced in Bluetooth 4.2. It uses Elliptic Curve Diffie-Hellman (ECDH) for key exchange and offers stronger protection against passive and active attacks compared to older methods.","title":"Attribute Permissions"},{"location":"ble-06-gatt-server/#gatt-generic-attribute-profile","text":"The Generic Attribute Profile (GATT) defines how the low-level attributes defined by the ATT protocol are grouped and interpreted to represent meaningful data. While ATT is concerned purely with the format and transport of attributes (each with a handle, type, permissions, and value), GATT gives structure to those attributes by organizing them into logical groupings like services , characteristics , and descriptors . At its core, GATT uses multiple ATT attributes to represent each component: A Service is a collection of related characteristics (e.g., the Heart Rate Service). A Characteristic represents a data item (e.g., current heart rate) and is made up of three attributes: a declaration , a value , and optional descriptors . A Descriptor is additional metadata about a characteristic, such as a human-readable label or client configuration (e.g., enabling notifications). Each attribute is given a handle, type, permssions, and value. Handles are assgined by the server and can vary between different BLE stacks, but it is worth discussing the other three fields in more detail:","title":"GATT (Generic Attribute Profile)"},{"location":"ble-06-gatt-server/#1-service-declaration","text":"Type Permission Value 0x2800 (Primary) or 0x2801 (Secondary) Read UUID of the service (e.g., 0x180F for Battery Service)","title":"1. Service Declaration"},{"location":"ble-06-gatt-server/#2-characteristic-declaration","text":"Type Permission Value 0x2803 (Characteristic Declaration) Read - Properties (1 byte): Bitfield indicating allowed operations (e.g., Read, Write, Notify). - Value Handle (2 bytes): Handle pointing to the Characteristic Value attribute. - Characteristic UUID (2 or 16 bytes): UUID of the characteristic.","title":"2. Characteristic Declaration"},{"location":"ble-06-gatt-server/#3-characteristic-value","text":"Type (UUID of Characteristic) Permission Value The UUID of the characteristic (e.g., 0x2A19 for Battery Level) Depends on characteristic (e.g., Read, Write, Notify) Raw data (e.g., sensor reading, config byte). This is the actual payload a client interacts with.","title":"3. Characteristic Value"},{"location":"ble-06-gatt-server/#4-descriptor-attribute-optional","text":"Type Permission Value e.g., 0x2901 (User Description), 0x2902 (CCCD) Depends on descriptor: - 0x2901 : Read - 0x2902 : Read/Write - User Description (0x2901) : Human-readable name of the characteristic (e.g., \"Temperature\"). - CCCD (0x2902) : 2-byte bitfield that enables notifications and/or indications. - Others: May define triggers, ranges, or valid formats.","title":"4. Descriptor Attribute (optional)"},{"location":"ble-06-gatt-server/#service-initiated-operations-indication-and-notification","text":"Indication and notification are operations used to push data from a GATT server to a client. Notification is a lightweight, unacknowledged data push. It is suitable for non-critical or frequently changing data, such as sensor streams or status updates. Notifications are fast but not guaranteed to arrive. Indication is a reliable, acknowledged mechanism. Each indication must be confirmed by the client before the next can be sent. This makes it ideal for critical data or state changes that must be received. Use notification for speed and simplicity. Use indication when reliability is essential.","title":"Service-Initiated Operations: Indication and Notification"},{"location":"ble-06-gatt-server/#in-action","text":"","title":"In Action"},{"location":"ble-06-gatt-server/#purpose-of-this-example","text":"This example demonstrates how to create a custom GATT service with three characteristics: Command characteristic (Write): receives a control byte from a client (e.g., phone). Critical characteristic (Indicate): used to send important data that requires acknowledgment. Non-critical characteristic (Notify): used to send less important, best-effort data. The purpose is to test how a peripheral (nRF52840 dongle) can push different types of data to a central (like a phone), depending on a command it receives. Writing 0x00 triggers a notification, while any non-zero value triggers an indication.","title":"Purpose of this example"},{"location":"ble-06-gatt-server/#steps-to-implement","text":"","title":"Steps to implement"},{"location":"ble-06-gatt-server/#step-1-declare-uuids","text":"Custom 128-bit UUIDs are declared for the service and each of the three characteristics. This is just like what we have done in the previous example. #include <zephyr/types.h> #include <zephyr/bluetooth/uuid.h> #define BT_UUID_TEST_SERVICE_VAL BT_UUID_128_ENCODE(0x12345678, 0x9abc, 0xdef0, 0x1234, 0x56789abcdef0) #define BT_UUID_TEST_CMD_VAL BT_UUID_128_ENCODE(0x12345678, 0x9abc, 0xdef0, 0x1234, 0x56789abcdef1) #define BT_UUID_TEST_CRITICAL_VAL BT_UUID_128_ENCODE(0x12345678, 0x9abc, 0xdef0, 0x1234, 0x56789abcdef2) #define BT_UUID_TEST_NONCRITICAL_VAL BT_UUID_128_ENCODE(0x12345678, 0x9abc, 0xdef0, 0x1234, 0x56789abcdef3) #define BT_UUID_TEST_SERVICE BT_UUID_DECLARE_128(BT_UUID_TEST_SERVICE_VAL) #define BT_UUID_TEST_CMD BT_UUID_DECLARE_128(BT_UUID_TEST_CMD_VAL) #define BT_UUID_TEST_CRITICAL BT_UUID_DECLARE_128(BT_UUID_TEST_CRITICAL_VAL) #define BT_UUID_TEST_NONCRITICAL BT_UUID_DECLARE_128(BT_UUID_TEST_NONCRITICAL_VAL)","title":"Step 1. Declare UUIDs"},{"location":"ble-06-gatt-server/#step-2-define-the-service-and-characteristics","text":"Here we define the service and its characteristics using BT_GATT_SERVICE_DEFINE . Each characteristic is assigned appropriate properties ( WRITE , INDICATE , NOTIFY ) and permissions. BT_GATT_SERVICE_DEFINE(test_svc, BT_GATT_PRIMARY_SERVICE(BT_UUID_TEST_SERVICE), BT_GATT_CHARACTERISTIC(BT_UUID_TEST_CMD, BT_GATT_CHRC_WRITE, BT_GATT_PERM_WRITE, NULL, write_cmd, NULL), BT_GATT_CHARACTERISTIC(BT_UUID_TEST_CRITICAL, BT_GATT_CHRC_INDICATE, BT_GATT_PERM_NONE, NULL, NULL, NULL), BT_GATT_CCC(critical_ccc_cfg_changed, BT_GATT_PERM_READ | BT_GATT_PERM_WRITE), BT_GATT_CHARACTERISTIC(BT_UUID_TEST_NONCRITICAL, BT_GATT_CHRC_NOTIFY, BT_GATT_PERM_NONE, NULL, NULL, NULL), BT_GATT_CCC(noncritical_ccc_cfg_changed, BT_GATT_PERM_READ | BT_GATT_PERM_WRITE) ); Note : BT_GATT_CCC adds a Client Characteristic Configuration Descriptor, which allows the client to enable or disable notifications/indications.","title":"Step 2. Define the service and characteristics"},{"location":"ble-06-gatt-server/#step-3-define-the-cccd-callback-functions","text":"These callbacks are used in the previous step to handle changes in the CCCD values. static bool notify_enabled; static bool indicate_enabled; static void critical_ccc_cfg_changed(const struct bt_gatt_attr *attr, uint16_t value) { indicate_enabled = (value == BT_GATT_CCC_INDICATE); LOG_INF(\"Indicate enabled: %s\", indicate_enabled ? \"true\" : \"false\"); } static void noncritical_ccc_cfg_changed(const struct bt_gatt_attr *attr, uint16_t value) { notify_enabled = (value == BT_GATT_CCC_NOTIFY); LOG_INF(\"Notify enabled: %s\", notify_enabled ? \"true\" : \"false\"); }","title":"Step 3. Define the CCCD callback functions"},{"location":"ble-06-gatt-server/#step-4-define-the-write-callback-function","text":"The write callback interprets the value written by the client and sends either a notification or an indication. static struct bt_gatt_indicate_params ind_params; static uint8_t dummy_cmd; static ssize_t write_cmd(struct bt_conn *conn, const struct bt_gatt_attr *attr, const void *buf, uint16_t len, uint16_t offset, uint8_t flags) { if (len != sizeof(uint8_t)) { return BT_GATT_ERR(BT_ATT_ERR_INVALID_ATTRIBUTE_LEN); } dummy_cmd = *((uint8_t *)buf); const uint32_t dummy_data = 0xAABBCCDD; if (dummy_cmd) { // Indicate critical data if (!indicate_enabled) { LOG_WRN(\"Indications not enabled\"); return -EACCES; } LOG_INF(\"Indicating critical data: %x\", dummy_data); ind_params.attr = &test_svc.attrs[3]; ind_params.func = indicate_cb; ind_params.data = &dummy_data; ind_params.len = sizeof(dummy_data); return bt_gatt_indicate(NULL, &ind_params); } else { // Notify non-critical data if (!notify_enabled) { LOG_WRN(\"Notifications not enabled\"); return -EACCES; } LOG_INF(\"Notifying non-critical data: %x\", dummy_data); return bt_gatt_notify(NULL, &test_svc.attrs[6], &dummy_data, sizeof(dummy_data)); } } Note : - bt_gatt_indicate() uses a parameter structure because it handles asynchronous acknowledgment. - bt_gatt_notify() is simpler\u2014no acknowledgment, no callback, just send. - The attr indices for .attrs[3] and .attrs[6] refer to the characteristic declaration attribute , not the value or CCCD. Remember: - Service declaration = 1 attribute - Each characteristic = 2 attributes (declaration + value) - Optional CCCD = 1 attribute - So manually counting the offsets is required unless dynamic lookup is used.","title":"Step 4. Define the write callback function"},{"location":"ble-06-gatt-server/#step-5-define-the-indication-callback","text":"This is called after the client acknowledges the indication. static void indicate_cb(struct bt_conn *conn, struct bt_gatt_indicate_params *params, uint8_t err) { LOG_DBG(\"Indication result: %s\", err == 0U ? \"success\" : \"fail\"); }","title":"Step 5. Define the indication callback"},{"location":"ble-07-security-modes/","text":"07 - BLE Security Modes Author: Tony Fu Date: 2025/4/13 Device: nRF52840 Dongle Toolchain: nRF Connect SDK v2.8.0 Common BLE Security Threats Here are some common threats to BLE security: Identity Tracking ( ID ) Tracking a device over time using its Bluetooth address. Prevented by using resolvable private addresses with the IRK (Identity Resolving Key) to obscure the device identity. Passive Eavesdropping ( PE ) An attacker silently listens to data over the air. Prevented by encrypting the connection. Man-in-the-Middle ( MITM ) An attacker impersonates both peers, relaying and potentially modifying messages. Prevented by authenticated pairing methods that confirm peer identity (e.g., Passkey Entry, Numeric Comparison). BLE Security Levels Security Level Description Protects Against Level 1 No security: no encryption, no authentication. None Level 2 Encrypted link using unauthenticated pairing (e.g., Just Works). PE Level 3 Encrypted link with authenticated pairing (e.g., Passkey, OOB with Legacy). PE, basic MITM Level 4 Encrypted link with LE Secure Connections + authentication . PE, MITM, ID (with privacy) Notes: All connections start at Level 1 , then upgrade during pairing. Just Works leads to Level 2 \u2014 encrypted but not authenticated. Passkey Entry or OOB leads to Level 3 . Level 4 requires both devices to support LE Secure Connections and use authenticated pairing. Privacy (ID protection) is separate from these levels but essential to combat identity tracking . Connecting vs Pairing vs Bonding Before diving into BLE security modes, it's important to understand three foundational terms: connecting , pairing , and bonding . These steps form the basis of how two Bluetooth devices establish trust. While connecting simply creates a communication link, pairing is the beginning of any real security\u2014it\u2019s when encryption keys are generated and exchanged. Bonding builds on pairing by storing that trust for future sessions. Connecting Establishes a temporary link between two BLE devices. No security by default. Pairing Establishes trusted relationship for the current session. Negotiates and exchanges encryption keys. Enables secure data transfer (encryption, authentication). Bonding Saves pairing information (keys) to non-volatile memory . Allows devices to reconnect securely without re-pairing . Typically happens automatically after successful pairing if both devices support it. In short: Connect \u2192 Pair \u2192 Bond (optional but persistent) . More on Pairing The pairing process can be further divided into three distinct phases: Phase 1: Pairing Feature Exchange Initiated by the central device via a Pairing Request . The peripheral responds with a Pairing Response . Devices exchange their: I/O capabilities (e.g., keyboard, display, none). OOB and MITM flags (to determine required security). Supported authentication and encryption options . Whether they wish to bond or just pair temporarily. Based on this information, the devices will choose an appropriate pairing method in Phase 2. Phase 2: Key Generation and Authentication Devices perform cryptographic operations to generate encryption keys. Depending on the pairing mode: Legacy Pairing : Generates a Short Term Key (STK) from a Temporary Key (TK) . LE Secure Connections : Uses Elliptic Curve Diffie-Hellman (ECDH) to generate a Long Term Key (LTK) directly and securely. The actual pairing method used depends on capabilities and flags: Just Works (unauthenticated) Passkey Entry (user types in/display 6-digit code) Out-of-Band (OOB) (e.g., via NFC) Numeric Comparison (LE Secure Connections only) This phase determines how secure the pairing is \u2014 especially whether it's protected against MITM attacks. Phase 3: Key Distribution (only if bonding) If bonding is agreed upon, devices exchange and store keys: LTK (used to encrypt future connections) IRK (Identity Resolving Key for address privacy) CSRK (for signed data, optional) These keys are saved to non-volatile memory so that future reconnections can skip pairing and resume secure communication immediately. More on Phase 2: Pairing Methods The method used to perform pairing directly affects the security level . Method Authentication Requires User Interaction MITM Protection Available In Just Works \u274c No Minimal (accept prompt) \u274c No Legacy & LE Secure Connections Passkey Entry \u2705 Yes Yes (input or display) \u2705 Yes Legacy & LE Secure Connections Out of Band (OOB) \u2705 Yes External channel (e.g., NFC) \u2705 Yes Legacy & LE Secure Connections Numeric Comparison \u2705 Yes Yes (compare 6-digit number) \u2705 Yes LE Secure Connections only Details Just Works The simplest pairing method. Devices derive encryption keys without authentication. Used when neither device has a display or keyboard (e.g., most wearables). Susceptible to MITM attacks , as the user cannot verify peer identity. Results in Security Level 2 (unauthenticated encryption). Passkey Entry A 6-digit passkey is shown on one device and entered on the other. Which device displays or inputs depends on I/O capabilities. Provides authenticated pairing , resistant to MITM. Yields Security Level 3 (authenticated encryption). Out of Band (OOB) Key material is exchanged over an external medium (e.g., NFC , QR codes). Ideal for devices with limited BLE I/O but secure secondary channels. Only one device needs to support OOB for it to be used (in Secure Connections). Provides MITM protection, assuming the OOB channel is trusted. Numeric Comparison Both devices display the same 6-digit number. The user confirms if the numbers match (presses \u201cYes\u201d). Ensures that no attacker is relaying the connection. Only available in LE Secure Connections . Offers strong MITM protection and Security Level 4 . How Pairing Method is Selected Pairing method selection is automatic and based on: - Devices' I/O capabilities - OOB and MITM flags exchanged in Phase 1 - Support for LE Secure Connections If OOB is supported , it is chosen. Otherwise, if MITM is required , Passkey Entry or Numeric Comparison is used. If neither applies, Just Works is used by default. In Action In this section, we\u2019ll define two writable characteristics: - One that requires encryption to access - Another that requires authentication When you try to write to either from your phone app, the device will prompt you to pair, depending on the required security level. 1. Enable pairing support Enable the Security Manager Protocol (SMP) in your prj.conf : CONFIG_BT_SMP=y 2. Declare the characteristic UUIDs Just like in previous examples, define custom UUIDs for the service and its characteristics: #define BT_UUID_TEST_SERVICE_VAL BT_UUID_128_ENCODE(0x12345678, 0x9abc, 0xdef0, 0x1234, 0x56789abcdef0) #define BT_UUID_TEST_ENCRYPT_VAL BT_UUID_128_ENCODE(0x12345678, 0x9abc, 0xdef0, 0x1234, 0x56789abcdef1) #define BT_UUID_TEST_SERVICE BT_UUID_DECLARE_128(BT_UUID_TEST_SERVICE_VAL) #define BT_UUID_TEST_ENCRYPT BT_UUID_DECLARE_128(BT_UUID_TEST_ENCRYPT_VAL) 3. Define the characteristics We use BT_GATT_PERM_WRITE_ENCRYPT to require link encryption for writing: BT_GATT_SERVICE_DEFINE(my_svc, BT_GATT_PRIMARY_SERVICE(BT_UUID_TEST_SERVICE), // Encrypted write characteristic BT_GATT_CHARACTERISTIC(BT_UUID_TEST_ENCRYPT, BT_GATT_CHRC_WRITE, BT_GATT_PERM_WRITE_ENCRYPT, NULL, encrypt_write, NULL), ); 4. Implement the write handler Same as earlier examples (not shown here). It will be called once security is sufficient. 5. Track security level changes Use the security_changed callback to monitor when the connection is encrypted or authenticated: static void on_security_changed(struct bt_conn *conn, bt_security_t level, enum bt_security_err err) { char peer_addr[BT_ADDR_LE_STR_LEN]; bt_addr_le_to_str(bt_conn_get_dst(conn), peer_addr, sizeof(peer_addr)); if (err == 0) { LOG_INF(\"Link secured with %s (level %u)\", peer_addr, level); } else { LOG_WRN(\"Security setup failed with %s (level %u, err %d)\", peer_addr, level, err); } } struct bt_conn_cb connection_callbacks = { .connected = on_connected, .disconnected = on_disconnected, .security_changed = on_security_changed, }; 6. Attempt a write When you try to write to the encrypted characteristic, the phone will prompt you to pair. Once encrypted, the connection will be promoted to Security Level 2 . 7. Unpair before moving on To start fresh: - On your phone, unpair the device via Bluetooth settings. - In firmware, clear bonding info with: bt_unpair(BT_ID_DEFAULT, NULL); 8. Add an authenticated characteristic Now define a second characteristic that requires authentication : #define BT_UUID_TEST_AUTHEN_VAL BT_UUID_128_ENCODE(0x12345678, 0x9abc, 0xdef0, 0x1234, 0x56789abcdef2) #define BT_UUID_TEST_AUTHEN BT_UUID_DECLARE_128(BT_UUID_TEST_AUTHEN_VAL) BT_GATT_SERVICE_DEFINE(my_svc, BT_GATT_PRIMARY_SERVICE(BT_UUID_TEST_SERVICE), // Encrypted write characteristic BT_GATT_CHARACTERISTIC(BT_UUID_TEST_ENCRYPT, BT_GATT_CHRC_WRITE, BT_GATT_PERM_WRITE_ENCRYPT, NULL, encrypt_write, NULL), // Authenticated write characteristic BT_GATT_CHARACTERISTIC(BT_UUID_TEST_AUTHEN, BT_GATT_CHRC_WRITE, BT_GATT_PERM_WRITE_AUTHEN, NULL, authen_write, NULL), ); 9. Display the passkey To complete an authenticated pairing, we need to show the user a passkey. This is done using the authentication callbacks: static void display_passkey(struct bt_conn *conn, unsigned int passkey) { char peer_addr[BT_ADDR_LE_STR_LEN]; bt_addr_le_to_str(bt_conn_get_dst(conn), peer_addr, sizeof(peer_addr)); LOG_INF(\"Enter passkey on %s: %06u\", peer_addr, passkey); } static void cancel_authentication(struct bt_conn *conn) { char peer_addr[BT_ADDR_LE_STR_LEN]; bt_addr_le_to_str(bt_conn_get_dst(conn), peer_addr, sizeof(peer_addr)); LOG_INF(\"Pairing canceled by remote: %s\", peer_addr); } static const struct bt_conn_auth_cb auth_callbacks = { .passkey_display = display_passkey, .cancel = cancel_authentication, }; 10. Register authentication handlers Don't forget to register your callbacks during initialization: int main(void) { bt_unpair(BT_ID_DEFAULT, NULL); bt_conn_auth_cb_register(&auth_callbacks); bt_conn_cb_register(&connection_callbacks); bt_enable(NULL); // Other setup... }","title":"BLE-Security Modes"},{"location":"ble-07-security-modes/#07-ble-security-modes","text":"Author: Tony Fu Date: 2025/4/13 Device: nRF52840 Dongle Toolchain: nRF Connect SDK v2.8.0","title":"07 - BLE Security Modes"},{"location":"ble-07-security-modes/#common-ble-security-threats","text":"Here are some common threats to BLE security:","title":"Common BLE Security Threats"},{"location":"ble-07-security-modes/#identity-tracking-id","text":"Tracking a device over time using its Bluetooth address. Prevented by using resolvable private addresses with the IRK (Identity Resolving Key) to obscure the device identity.","title":"Identity Tracking (ID)"},{"location":"ble-07-security-modes/#passive-eavesdropping-pe","text":"An attacker silently listens to data over the air. Prevented by encrypting the connection.","title":"Passive Eavesdropping (PE)"},{"location":"ble-07-security-modes/#man-in-the-middle-mitm","text":"An attacker impersonates both peers, relaying and potentially modifying messages. Prevented by authenticated pairing methods that confirm peer identity (e.g., Passkey Entry, Numeric Comparison).","title":"Man-in-the-Middle (MITM)"},{"location":"ble-07-security-modes/#ble-security-levels","text":"Security Level Description Protects Against Level 1 No security: no encryption, no authentication. None Level 2 Encrypted link using unauthenticated pairing (e.g., Just Works). PE Level 3 Encrypted link with authenticated pairing (e.g., Passkey, OOB with Legacy). PE, basic MITM Level 4 Encrypted link with LE Secure Connections + authentication . PE, MITM, ID (with privacy)","title":"BLE Security Levels"},{"location":"ble-07-security-modes/#notes","text":"All connections start at Level 1 , then upgrade during pairing. Just Works leads to Level 2 \u2014 encrypted but not authenticated. Passkey Entry or OOB leads to Level 3 . Level 4 requires both devices to support LE Secure Connections and use authenticated pairing. Privacy (ID protection) is separate from these levels but essential to combat identity tracking .","title":"Notes:"},{"location":"ble-07-security-modes/#connecting-vs-pairing-vs-bonding","text":"Before diving into BLE security modes, it's important to understand three foundational terms: connecting , pairing , and bonding . These steps form the basis of how two Bluetooth devices establish trust. While connecting simply creates a communication link, pairing is the beginning of any real security\u2014it\u2019s when encryption keys are generated and exchanged. Bonding builds on pairing by storing that trust for future sessions. Connecting Establishes a temporary link between two BLE devices. No security by default. Pairing Establishes trusted relationship for the current session. Negotiates and exchanges encryption keys. Enables secure data transfer (encryption, authentication). Bonding Saves pairing information (keys) to non-volatile memory . Allows devices to reconnect securely without re-pairing . Typically happens automatically after successful pairing if both devices support it. In short: Connect \u2192 Pair \u2192 Bond (optional but persistent) .","title":"Connecting vs Pairing vs Bonding"},{"location":"ble-07-security-modes/#more-on-pairing","text":"The pairing process can be further divided into three distinct phases:","title":"More on Pairing"},{"location":"ble-07-security-modes/#phase-1-pairing-feature-exchange","text":"Initiated by the central device via a Pairing Request . The peripheral responds with a Pairing Response . Devices exchange their: I/O capabilities (e.g., keyboard, display, none). OOB and MITM flags (to determine required security). Supported authentication and encryption options . Whether they wish to bond or just pair temporarily. Based on this information, the devices will choose an appropriate pairing method in Phase 2.","title":"Phase 1: Pairing Feature Exchange"},{"location":"ble-07-security-modes/#phase-2-key-generation-and-authentication","text":"Devices perform cryptographic operations to generate encryption keys. Depending on the pairing mode: Legacy Pairing : Generates a Short Term Key (STK) from a Temporary Key (TK) . LE Secure Connections : Uses Elliptic Curve Diffie-Hellman (ECDH) to generate a Long Term Key (LTK) directly and securely. The actual pairing method used depends on capabilities and flags: Just Works (unauthenticated) Passkey Entry (user types in/display 6-digit code) Out-of-Band (OOB) (e.g., via NFC) Numeric Comparison (LE Secure Connections only) This phase determines how secure the pairing is \u2014 especially whether it's protected against MITM attacks.","title":"Phase 2: Key Generation and Authentication"},{"location":"ble-07-security-modes/#phase-3-key-distribution-only-if-bonding","text":"If bonding is agreed upon, devices exchange and store keys: LTK (used to encrypt future connections) IRK (Identity Resolving Key for address privacy) CSRK (for signed data, optional) These keys are saved to non-volatile memory so that future reconnections can skip pairing and resume secure communication immediately.","title":"Phase 3: Key Distribution (only if bonding)"},{"location":"ble-07-security-modes/#more-on-phase-2-pairing-methods","text":"The method used to perform pairing directly affects the security level . Method Authentication Requires User Interaction MITM Protection Available In Just Works \u274c No Minimal (accept prompt) \u274c No Legacy & LE Secure Connections Passkey Entry \u2705 Yes Yes (input or display) \u2705 Yes Legacy & LE Secure Connections Out of Band (OOB) \u2705 Yes External channel (e.g., NFC) \u2705 Yes Legacy & LE Secure Connections Numeric Comparison \u2705 Yes Yes (compare 6-digit number) \u2705 Yes LE Secure Connections only","title":"More on Phase 2: Pairing Methods"},{"location":"ble-07-security-modes/#details","text":"","title":"Details"},{"location":"ble-07-security-modes/#just-works","text":"The simplest pairing method. Devices derive encryption keys without authentication. Used when neither device has a display or keyboard (e.g., most wearables). Susceptible to MITM attacks , as the user cannot verify peer identity. Results in Security Level 2 (unauthenticated encryption).","title":"Just Works"},{"location":"ble-07-security-modes/#passkey-entry","text":"A 6-digit passkey is shown on one device and entered on the other. Which device displays or inputs depends on I/O capabilities. Provides authenticated pairing , resistant to MITM. Yields Security Level 3 (authenticated encryption).","title":"Passkey Entry"},{"location":"ble-07-security-modes/#out-of-band-oob","text":"Key material is exchanged over an external medium (e.g., NFC , QR codes). Ideal for devices with limited BLE I/O but secure secondary channels. Only one device needs to support OOB for it to be used (in Secure Connections). Provides MITM protection, assuming the OOB channel is trusted.","title":"Out of Band (OOB)"},{"location":"ble-07-security-modes/#numeric-comparison","text":"Both devices display the same 6-digit number. The user confirms if the numbers match (presses \u201cYes\u201d). Ensures that no attacker is relaying the connection. Only available in LE Secure Connections . Offers strong MITM protection and Security Level 4 .","title":"Numeric Comparison"},{"location":"ble-07-security-modes/#how-pairing-method-is-selected","text":"Pairing method selection is automatic and based on: - Devices' I/O capabilities - OOB and MITM flags exchanged in Phase 1 - Support for LE Secure Connections If OOB is supported , it is chosen. Otherwise, if MITM is required , Passkey Entry or Numeric Comparison is used. If neither applies, Just Works is used by default.","title":"How Pairing Method is Selected"},{"location":"ble-07-security-modes/#in-action","text":"In this section, we\u2019ll define two writable characteristics: - One that requires encryption to access - Another that requires authentication When you try to write to either from your phone app, the device will prompt you to pair, depending on the required security level.","title":"In Action"},{"location":"ble-07-security-modes/#1-enable-pairing-support","text":"Enable the Security Manager Protocol (SMP) in your prj.conf : CONFIG_BT_SMP=y","title":"1. Enable pairing support"},{"location":"ble-07-security-modes/#2-declare-the-characteristic-uuids","text":"Just like in previous examples, define custom UUIDs for the service and its characteristics: #define BT_UUID_TEST_SERVICE_VAL BT_UUID_128_ENCODE(0x12345678, 0x9abc, 0xdef0, 0x1234, 0x56789abcdef0) #define BT_UUID_TEST_ENCRYPT_VAL BT_UUID_128_ENCODE(0x12345678, 0x9abc, 0xdef0, 0x1234, 0x56789abcdef1) #define BT_UUID_TEST_SERVICE BT_UUID_DECLARE_128(BT_UUID_TEST_SERVICE_VAL) #define BT_UUID_TEST_ENCRYPT BT_UUID_DECLARE_128(BT_UUID_TEST_ENCRYPT_VAL)","title":"2. Declare the characteristic UUIDs"},{"location":"ble-07-security-modes/#3-define-the-characteristics","text":"We use BT_GATT_PERM_WRITE_ENCRYPT to require link encryption for writing: BT_GATT_SERVICE_DEFINE(my_svc, BT_GATT_PRIMARY_SERVICE(BT_UUID_TEST_SERVICE), // Encrypted write characteristic BT_GATT_CHARACTERISTIC(BT_UUID_TEST_ENCRYPT, BT_GATT_CHRC_WRITE, BT_GATT_PERM_WRITE_ENCRYPT, NULL, encrypt_write, NULL), );","title":"3. Define the characteristics"},{"location":"ble-07-security-modes/#4-implement-the-write-handler","text":"Same as earlier examples (not shown here). It will be called once security is sufficient.","title":"4. Implement the write handler"},{"location":"ble-07-security-modes/#5-track-security-level-changes","text":"Use the security_changed callback to monitor when the connection is encrypted or authenticated: static void on_security_changed(struct bt_conn *conn, bt_security_t level, enum bt_security_err err) { char peer_addr[BT_ADDR_LE_STR_LEN]; bt_addr_le_to_str(bt_conn_get_dst(conn), peer_addr, sizeof(peer_addr)); if (err == 0) { LOG_INF(\"Link secured with %s (level %u)\", peer_addr, level); } else { LOG_WRN(\"Security setup failed with %s (level %u, err %d)\", peer_addr, level, err); } } struct bt_conn_cb connection_callbacks = { .connected = on_connected, .disconnected = on_disconnected, .security_changed = on_security_changed, };","title":"5. Track security level changes"},{"location":"ble-07-security-modes/#6-attempt-a-write","text":"When you try to write to the encrypted characteristic, the phone will prompt you to pair. Once encrypted, the connection will be promoted to Security Level 2 .","title":"6. Attempt a write"},{"location":"ble-07-security-modes/#7-unpair-before-moving-on","text":"To start fresh: - On your phone, unpair the device via Bluetooth settings. - In firmware, clear bonding info with: bt_unpair(BT_ID_DEFAULT, NULL);","title":"7. Unpair before moving on"},{"location":"ble-07-security-modes/#8-add-an-authenticated-characteristic","text":"Now define a second characteristic that requires authentication : #define BT_UUID_TEST_AUTHEN_VAL BT_UUID_128_ENCODE(0x12345678, 0x9abc, 0xdef0, 0x1234, 0x56789abcdef2) #define BT_UUID_TEST_AUTHEN BT_UUID_DECLARE_128(BT_UUID_TEST_AUTHEN_VAL) BT_GATT_SERVICE_DEFINE(my_svc, BT_GATT_PRIMARY_SERVICE(BT_UUID_TEST_SERVICE), // Encrypted write characteristic BT_GATT_CHARACTERISTIC(BT_UUID_TEST_ENCRYPT, BT_GATT_CHRC_WRITE, BT_GATT_PERM_WRITE_ENCRYPT, NULL, encrypt_write, NULL), // Authenticated write characteristic BT_GATT_CHARACTERISTIC(BT_UUID_TEST_AUTHEN, BT_GATT_CHRC_WRITE, BT_GATT_PERM_WRITE_AUTHEN, NULL, authen_write, NULL), );","title":"8. Add an authenticated characteristic"},{"location":"ble-07-security-modes/#9-display-the-passkey","text":"To complete an authenticated pairing, we need to show the user a passkey. This is done using the authentication callbacks: static void display_passkey(struct bt_conn *conn, unsigned int passkey) { char peer_addr[BT_ADDR_LE_STR_LEN]; bt_addr_le_to_str(bt_conn_get_dst(conn), peer_addr, sizeof(peer_addr)); LOG_INF(\"Enter passkey on %s: %06u\", peer_addr, passkey); } static void cancel_authentication(struct bt_conn *conn) { char peer_addr[BT_ADDR_LE_STR_LEN]; bt_addr_le_to_str(bt_conn_get_dst(conn), peer_addr, sizeof(peer_addr)); LOG_INF(\"Pairing canceled by remote: %s\", peer_addr); } static const struct bt_conn_auth_cb auth_callbacks = { .passkey_display = display_passkey, .cancel = cancel_authentication, };","title":"9. Display the passkey"},{"location":"ble-07-security-modes/#10-register-authentication-handlers","text":"Don't forget to register your callbacks during initialization: int main(void) { bt_unpair(BT_ID_DEFAULT, NULL); bt_conn_auth_cb_register(&auth_callbacks); bt_conn_cb_register(&connection_callbacks); bt_enable(NULL); // Other setup... }","title":"10. Register authentication handlers"},{"location":"ble-08-whitelisting/","text":"08 - BLE Whitelisting Author: Tony Fu Date: 2025/04/26 Device: nRF52840 DK Toolchain: nRF Connect SDK v3.0.0 Note that I have switched from using the nRF52840 Dongle to the nRF52840 DK for this project. This change is because CONFIG_SETTINGS is incompatible with the Dongle. The issue appears to be that the default storage location for the settings subsystem overlaps with the pre-programmed bootloader on the Dongle. The bootloader occupies the range 0xE0000 to 0x100000 (1 MB), while the default application build writes settings data starting at 0xFE000 , which falls within the bootloader region. This leads to flash corruption and a non-functional device (the COM port disappears, and the boot fails). Here is a post on the Zephyr forum that explains the issue in more detail. Bonding with Persistent Storage To store Bluetooth bond information across device resets (power cycles), we must enable several configuration options in prj.conf : CONFIG_BT_SETTINGS=y CONFIG_FLASH=y CONFIG_FLASH_PAGE_LAYOUT=y CONFIG_FLASH_MAP=y CONFIG_NVS=y CONFIG_SETTINGS_NVS=y CONFIG_SETTINGS=y Setting Purpose CONFIG_BT_SETTINGS Allows the Bluetooth stack to save and restore bonding and identity information (like keys) using the settings subsystem. Without this, bonds are lost on reset. CONFIG_FLASH Provides low-level flash driver support needed to write/read from non-volatile memory. CONFIG_FLASH_PAGE_LAYOUT Abstracts how flash memory is divided into pages, allowing the system to know how to manage writes and erasures correctly. Important for portable flash handling. CONFIG_FLASH_MAP Provides logical partitioning of the flash. Required to map certain parts of flash for NVS (and others like MCUBoot, if used). CONFIG_NVS Enables a simple key-value storage system over flash, suitable for small frequent updates like Bluetooth bonding information. CONFIG_SETTINGS_NVS Makes the settings subsystem use NVS as the storage backend (instead of, for example, FCB or other flash drivers). CONFIG_SETTINGS Provides a general system for saving and loading configuration values. The Bluetooth stack uses it under the hood to store keys and other persistent information. Then, in your main.c file, you need to include the settings header: #include <zephyr/settings/settings.h> and call the following functions in your main() function to initialize the settings subsystem and load the stored settings: bt_enable(NULL); settings_load(); start_advertising(); Whitelisting (a.k.a. Filter Accept List) Whitelisting restricts which devices can connect to your Bluetooth advertiser. It is based on a list of trusted (bonded) devices, called the Filter Accept List (FAL). When a device is bonded, its address is added to the FAL. When a device tries to connect, the Bluetooth stack checks if it is in the FAL. To enable whitelisting, add these configurations in your prj.conf : CONFIG_BT_FILTER_ACCEPT_LIST=y CONFIG_BT_PRIVACY=y CONFIG_BT_MAX_PAIRED=3 Config Purpose CONFIG_BT_FILTER_ACCEPT_LIST Enables the use of an internal list of allowed devices for scanning and connection filtering. CONFIG_BT_PRIVACY Enables the use of Resolvable Private Addresses (RPAs) to protect user identity and avoid static MAC addresses. This helps when using whitelisting, because bonded devices can still recognize each other even if their addresses change. CONFIG_BT_MAX_PAIRED Limits how many bonded devices can be stored and managed by the Bluetooth stack. Advertising with Whitelisting To actually use the FAL, you must configure your advertising parameters to filter both: - Scan Requests (devices trying to get more info like UUIDs) - Connection Requests (devices trying to establish a link) You do this by adding two advertising options: BT_LE_ADV_OPT_FILTER_SCAN_REQ : only allow devices in the whitelist to send scan requests. BT_LE_ADV_OPT_FILTER_CONN : only allow devices in the whitelist to initiate connections. You can define your whitelist-enabled advertising like this: #define BT_LE_ADV_CONN_ACCEPT_LIST \\ BT_LE_ADV_PARAM(BT_LE_ADV_OPT_CONN | BT_LE_ADV_OPT_FILTER_CONN | BT_LE_ADV_OPT_FILTER_SCAN_REQ, \\ BT_GAP_ADV_FAST_INT_MIN_2, BT_GAP_ADV_FAST_INT_MAX_2, NULL) This ensures that only known, bonded devices can see your scan response and initiate a connection. Adding Devices to the Whitelist Before using the Filter Accept List (whitelist) during advertising, you must populate it with the addresses of bonded devices. This process is typically done after Bluetooth is initialized but before starting advertising. static void add_bonded_device_to_whitelist(const struct bt_bond_info *bond, void *context) { int *added_count = context; if (*added_count < 0) { return; } int ret = bt_le_filter_accept_list_add(&bond->addr); if (ret) { LOG_INF(\"Failed to add device to whitelist (err: %d)\", ret); *added_count = -EIO; } else { (*added_count)++; LOG_INF(\"Device added to whitelist: %02X %02X\", bond->addr.a.val[0], bond->addr.a.val[1]); } } We will use this callback function below to add bonded devices to the whitelist: static int configure_whitelist(uint8_t id) { int ret = bt_le_filter_accept_list_clear(); if (ret) { LOG_INF(\"Whitelist clear failed (err: %d)\", ret); return ret; } int bonded_devices = 0; bt_foreach_bond(id, add_bonded_device_to_whitelist, &bonded_devices); return bonded_devices; } This function: 1. Clears any existing whitelist. 2. Iterates over all bonded devices ( bt_foreach_bond() ). 3. Adds each bonded device to the whitelist. 4. Returns the number of devices added. Now we just need to call configure_whitelist() before starting advertising: Erasing Bonding Information Sometimes you need to remove all stored bonds, for example when: - Resetting the device for new users. - Testing new pairing procedures. You can erase all bonding information with a simple API call: int ret = bt_unpair(BT_ID_DEFAULT, BT_ADDR_LE_ANY); BT_ID_DEFAULT specifies the local identity (usually 0 unless you use multiple identities). BT_ADDR_LE_ANY means \"remove all bonded devices\" (wildcard address). If successful, all paired devices are forgotten, and the whitelist (if any) must be rebuilt. After erasing bonds, you should also clear the FAL to ensure no stale entries remain. Also, you should go to the Bluetooth settings of your central device (e.g., phone) and remove the bond from there as well.","title":"BLE-Whitelisting"},{"location":"ble-08-whitelisting/#08-ble-whitelisting","text":"Author: Tony Fu Date: 2025/04/26 Device: nRF52840 DK Toolchain: nRF Connect SDK v3.0.0 Note that I have switched from using the nRF52840 Dongle to the nRF52840 DK for this project. This change is because CONFIG_SETTINGS is incompatible with the Dongle. The issue appears to be that the default storage location for the settings subsystem overlaps with the pre-programmed bootloader on the Dongle. The bootloader occupies the range 0xE0000 to 0x100000 (1 MB), while the default application build writes settings data starting at 0xFE000 , which falls within the bootloader region. This leads to flash corruption and a non-functional device (the COM port disappears, and the boot fails). Here is a post on the Zephyr forum that explains the issue in more detail.","title":"08 - BLE Whitelisting"},{"location":"ble-08-whitelisting/#bonding-with-persistent-storage","text":"To store Bluetooth bond information across device resets (power cycles), we must enable several configuration options in prj.conf : CONFIG_BT_SETTINGS=y CONFIG_FLASH=y CONFIG_FLASH_PAGE_LAYOUT=y CONFIG_FLASH_MAP=y CONFIG_NVS=y CONFIG_SETTINGS_NVS=y CONFIG_SETTINGS=y Setting Purpose CONFIG_BT_SETTINGS Allows the Bluetooth stack to save and restore bonding and identity information (like keys) using the settings subsystem. Without this, bonds are lost on reset. CONFIG_FLASH Provides low-level flash driver support needed to write/read from non-volatile memory. CONFIG_FLASH_PAGE_LAYOUT Abstracts how flash memory is divided into pages, allowing the system to know how to manage writes and erasures correctly. Important for portable flash handling. CONFIG_FLASH_MAP Provides logical partitioning of the flash. Required to map certain parts of flash for NVS (and others like MCUBoot, if used). CONFIG_NVS Enables a simple key-value storage system over flash, suitable for small frequent updates like Bluetooth bonding information. CONFIG_SETTINGS_NVS Makes the settings subsystem use NVS as the storage backend (instead of, for example, FCB or other flash drivers). CONFIG_SETTINGS Provides a general system for saving and loading configuration values. The Bluetooth stack uses it under the hood to store keys and other persistent information. Then, in your main.c file, you need to include the settings header: #include <zephyr/settings/settings.h> and call the following functions in your main() function to initialize the settings subsystem and load the stored settings: bt_enable(NULL); settings_load(); start_advertising();","title":"Bonding with Persistent Storage"},{"location":"ble-08-whitelisting/#whitelisting-aka-filter-accept-list","text":"Whitelisting restricts which devices can connect to your Bluetooth advertiser. It is based on a list of trusted (bonded) devices, called the Filter Accept List (FAL). When a device is bonded, its address is added to the FAL. When a device tries to connect, the Bluetooth stack checks if it is in the FAL. To enable whitelisting, add these configurations in your prj.conf : CONFIG_BT_FILTER_ACCEPT_LIST=y CONFIG_BT_PRIVACY=y CONFIG_BT_MAX_PAIRED=3 Config Purpose CONFIG_BT_FILTER_ACCEPT_LIST Enables the use of an internal list of allowed devices for scanning and connection filtering. CONFIG_BT_PRIVACY Enables the use of Resolvable Private Addresses (RPAs) to protect user identity and avoid static MAC addresses. This helps when using whitelisting, because bonded devices can still recognize each other even if their addresses change. CONFIG_BT_MAX_PAIRED Limits how many bonded devices can be stored and managed by the Bluetooth stack.","title":"Whitelisting (a.k.a. Filter Accept List)"},{"location":"ble-08-whitelisting/#advertising-with-whitelisting","text":"To actually use the FAL, you must configure your advertising parameters to filter both: - Scan Requests (devices trying to get more info like UUIDs) - Connection Requests (devices trying to establish a link) You do this by adding two advertising options: BT_LE_ADV_OPT_FILTER_SCAN_REQ : only allow devices in the whitelist to send scan requests. BT_LE_ADV_OPT_FILTER_CONN : only allow devices in the whitelist to initiate connections. You can define your whitelist-enabled advertising like this: #define BT_LE_ADV_CONN_ACCEPT_LIST \\ BT_LE_ADV_PARAM(BT_LE_ADV_OPT_CONN | BT_LE_ADV_OPT_FILTER_CONN | BT_LE_ADV_OPT_FILTER_SCAN_REQ, \\ BT_GAP_ADV_FAST_INT_MIN_2, BT_GAP_ADV_FAST_INT_MAX_2, NULL) This ensures that only known, bonded devices can see your scan response and initiate a connection.","title":"Advertising with Whitelisting"},{"location":"ble-08-whitelisting/#adding-devices-to-the-whitelist","text":"Before using the Filter Accept List (whitelist) during advertising, you must populate it with the addresses of bonded devices. This process is typically done after Bluetooth is initialized but before starting advertising. static void add_bonded_device_to_whitelist(const struct bt_bond_info *bond, void *context) { int *added_count = context; if (*added_count < 0) { return; } int ret = bt_le_filter_accept_list_add(&bond->addr); if (ret) { LOG_INF(\"Failed to add device to whitelist (err: %d)\", ret); *added_count = -EIO; } else { (*added_count)++; LOG_INF(\"Device added to whitelist: %02X %02X\", bond->addr.a.val[0], bond->addr.a.val[1]); } } We will use this callback function below to add bonded devices to the whitelist: static int configure_whitelist(uint8_t id) { int ret = bt_le_filter_accept_list_clear(); if (ret) { LOG_INF(\"Whitelist clear failed (err: %d)\", ret); return ret; } int bonded_devices = 0; bt_foreach_bond(id, add_bonded_device_to_whitelist, &bonded_devices); return bonded_devices; } This function: 1. Clears any existing whitelist. 2. Iterates over all bonded devices ( bt_foreach_bond() ). 3. Adds each bonded device to the whitelist. 4. Returns the number of devices added. Now we just need to call configure_whitelist() before starting advertising:","title":"Adding Devices to the Whitelist"},{"location":"ble-08-whitelisting/#erasing-bonding-information","text":"Sometimes you need to remove all stored bonds, for example when: - Resetting the device for new users. - Testing new pairing procedures. You can erase all bonding information with a simple API call: int ret = bt_unpair(BT_ID_DEFAULT, BT_ADDR_LE_ANY); BT_ID_DEFAULT specifies the local identity (usually 0 unless you use multiple identities). BT_ADDR_LE_ANY means \"remove all bonded devices\" (wildcard address). If successful, all paired devices are forgotten, and the whitelist (if any) must be rebuilt. After erasing bonds, you should also clear the FAL to ensure no stale entries remain. Also, you should go to the Bluetooth settings of your central device (e.g., phone) and remove the bond from there as well.","title":"Erasing Bonding Information"},{"location":"nfc-01-simple-text/","text":"NFC 01: Introduction to NFC Author: Tony Fu Date: 2025/04/27 Device: nRF52840 DK Toolchain: nRF Connect SDK v3.0.0 What is NFC? NFC stands for Near Field Communication. It allows two devices to communicate when they are very close, usually within a few centimeters. It is based on magnetic induction, not normal radio waves like Wi-Fi or Bluetooth. It is designed for very short-range and fast interactions. It does not need pairing or long setup. One device usually acts as a passive tag (it does not need power), and the other acts as an active reader (it powers the communication). Some devices, like phones, can do both. NFC Device Roles In NFC communication, devices have specific roles: Tag (Passive) A tag stores data. It does not create its own signal. It waits to be powered by a reader. Example: an NFC sticker, a smart card, or an nRF board acting as a tag. Reader/Writer (Active) A reader generates a magnetic field. It reads data from or writes data to a tag. Example: a smartphone reading a poster or tapping to pay. Peer-to-Peer (Both Active) Two devices can talk to each other by taking turns. Both generate fields and exchange data. Example: two phones sharing a contact by tapping together. Most nRF boards can only act as a tag. NFC Tag Types When using NFC, devices can either act as a polling device (reader) or a tag (listener). We will focus only on the tag role in this subsection. A tag is a passive NFC device. It does not generate its own electromagnetic field but waits for a polling device like a smartphone to scan it. When scanned, the tag responds by modulating the field. The tag contains simple data, such as a URL or text. Most of Nordic Semiconductor's nRF5 Series devices have a built-in NFC Tag peripheral. This peripheral operates using NFC-A technology (i.e., following the ISO/IEC 14443 Type A standard). NFC-A is the most widely used NFC signaling method and is compatible with most smartphones. The nRF Connect SDK provides libraries to emulate two kinds of NFC tag protocols: Type 2 Tag Based on the NFC Forum Type 2 specification. These tags are simple, lightweight, and fast enough for basic NFC applications like sharing URLs, text messages, or launching apps. Type 4 Tag Based on the NFC Forum Type 4 specification. These tags can store more data, support security features like authentication, and can be used for advanced tasks such as emulating access cards or payment cards. The nRF5 SDK or nRF Connect SDK includes precompiled libraries for both Type 2 and Type 4 Tag emulation. These libraries communicate with the hardware through the NFCT driver inside the nrfxlib module. Other NFC tag types defined by the NFC Forum include: Type 1 Tag The earliest NFC tag type. Very simple. Low speed and small memory. Not common today. Type 3 Tag More complex. Supports higher data rates. Originally designed for specific applications like transit cards in Japan. Type 5 Tag Newer standard. Often used for long-range RFID and NFC applications. Less common in consumer devices. Table comparing the NFC Tag Types: Tag Type Memory Size Speed Special Features Common Use Type 1 Small Slow Basic functionality, simple locking Rare today, early posters Type 2 Small to Medium Medium Lightweight, flexible, widely supported Stickers, marketing, simple IoT devices Type 3 Medium to Large Medium to High Complex, peer-to-peer possible Transit systems (e.g., FeliCa cards in Japan) Type 4 Medium to Large High Secure messaging, encryption, smartcard support Access cards, payment prototypes Type 5 Variable Medium to High Long-range NFC and RFID integration Industrial applications, asset tracking NDEF: NFC Data Exchange Format Purpose : A standardized data format to encapsulate typed data in NFC communications. Defined by : NFC Forum. Usage : For reading/writing data on NFC tags and peer-to-peer communication. Structure: NDEF Message : A container that holds one or more NDEF Records. NDEF Record : Basic unit of NDEF data, with a header and a payload. Record Header Fields: MB (Message Begin) : Set in the first record. ME (Message End) : Set in the last record. CF (Chunk Flag) : For chunked payloads. SR (Short Record) : Indicates 1-byte payload length (payload < 256 bytes). IL (ID Length Present) : Indicates presence of an ID field. TNF (Type Name Format) : 3-bit field indicating record type. Record Fields: Type : Describes payload type (e.g., text, URI). ID : Optional identifier for the record. Payload : Actual data (e.g., text string, URL). Common TNF Values: 0x01 \u2013 Well-known type (e.g., Text, URI) 0x02 \u2013 MIME media type 0x04 \u2013 External type Common Record Types: Text : Type = \"T\", Payload = language code + UTF text. URI : Type = \"U\", Payload = prefix byte + URI string. Encoding Example (Text): Payload = [lang code len][lang code][UTF-8 text] In Action This code sets up NFC Type 2 Tag emulation on the nRF52840 DK using Nordic's NFC stack. It builds an NDEF message containing a single well-known Text record with the payload \"Hello World!\" encoded in UTF-8. When a phone or NFC reader enters the field, the tag is activated and the message is transmitted. Step 1: Configure the NFC Stack # NFC Type 2 Tag support via Nordic's nrfxlib backend CONFIG_NFC_T2T_NRFXLIB=y # Enable core NDEF functionality CONFIG_NFC_NDEF=y # Enable NDEF message handling CONFIG_NFC_NDEF_MSG=y # Enable support for NDEF record structures CONFIG_NFC_NDEF_RECORD=y # Enable helper macros/functions for text records CONFIG_NFC_NDEF_TEXT_RECORD=y These options enable both the low-level Type 2 Tag emulation ( nfc_t2t_* APIs) and high-level NDEF message construction utilities (such as text and URI record encoding). Step 2: Handle NFC Events #include <nfc_t2t_lib.h> static void nfc_event_handler(void *ctx, nfc_t2t_event_t evt, const uint8_t *data, size_t len) { switch (evt) { case NFC_T2T_EVENT_FIELD_ON: printk(\"Phone detected\\n\"); break; case NFC_T2T_EVENT_FIELD_OFF: printk(\"Phone removed\\n\"); break; default: break; } } This callback receives NFC field events. NFC_T2T_EVENT_FIELD_ON : Indicates that a reader (e.g., a phone) is nearby and the tag is powered. NFC_T2T_EVENT_FIELD_OFF : The reader has moved away; the field is gone. Other events like NFC_T2T_EVENT_DATA_READ (when a reader completes reading) and NFC_T2T_EVENT_STOPPED (when the emulation is explicitly stopped) exist but are optional for basic use. You can handle these for more advanced flows like logging reads or cleaning up. and later in main we can register this handler with the NFC stack: int main(void) { int err = nfc_t2t_setup(nfc_event_handler, NULL); // More code not shown here... } Here, the second argument is a user-defined context pointer. It can be used to pass additional data to the event handler if needed. In this case, we set it to NULL since we don't need any extra context. Step 3: Encode NDEF Message To broadcast data over NFC, we must encode it into an NDEF (NFC Data Exchange Format) message. This step shows how to build a basic NDEF message containing a single Text Record using Nordic\u2019s NFC library. 0. Include Required Headers #include <nfc/ndef/msg.h> #include <nfc/ndef/text_rec.h> 1. Define a Text Record NFC_NDEF_TEXT_RECORD_DESC_DEF(text_rec, UTF_8, \"en\", 2, \"Hello World!\", 12); This macro: Creates a nfc_ndef_record_desc (record descriptor) and its payload. Parameters: UTF_8 : Specifies text encoding. \"en\", 2 : Language code (\"en\" for English) and its length. \"Hello World!\", 12 : Text string and its length. Use NFC_NDEF_TEXT_RECORD_DESC(text_rec) to access the descriptor later. 2. Define the NDEF Message NFC_NDEF_MSG_DEF(ndef_msg, 1); This macro: Declares an NDEF message descriptor with capacity for 1 record. Creates an internal array to hold pointers to record descriptors. Use NFC_NDEF_MSG(ndef_msg) to refer to the message instance. 3. Add the Record to the Message nfc_ndef_msg_record_add(&NFC_NDEF_MSG(ndef_msg), &NFC_NDEF_TEXT_RECORD_DESC(text_rec)); This function: Appends the previously defined text record to the message. Returns 0 on success or a negative error code. 4. Encode the Message to a Buffer nfc_ndef_msg_encode(&NFC_NDEF_MSG(ndef_msg), buf, buf_len); This function: Serializes the message into a raw binary format for NFC transmission. buf is the output buffer; buf_len is input/output (available space / encoded length). The buffer must be large enough to hold the message (128 bytes is usually enough for simple records). Total Code Snippet #include <nfc/ndef/msg.h> #include <nfc/ndef/text_rec.h> static int create_text_payload(uint8_t *buf, uint32_t *buf_len) { NFC_NDEF_TEXT_RECORD_DESC_DEF(text_rec, UTF_8, \"en\", 2, \"Hello World!\", 12); NFC_NDEF_MSG_DEF(ndef_msg, 1); int ret = nfc_ndef_msg_record_add(&NFC_NDEF_MSG(ndef_msg), &NFC_NDEF_TEXT_RECORD_DESC(text_rec)); if (ret < 0) { return ret; } return nfc_ndef_msg_encode(&NFC_NDEF_MSG(ndef_msg), buf, buf_len); } Step 4: Register Payload for Read Once the NDEF message is encoded, it must be registered with the NFC stack so that it can be sent to a reader during a READ operation. if (nfc_t2t_payload_set(nfc_data_buf, payload_len) < 0) { printk(\"Unable to load NFC data\\n\"); goto error; } nfc_t2t_payload_set() tells the NFC Type 2 Tag library which data to serve to the reader. nfc_data_buf is a pointer to the encoded NDEF message in RAM. payload_len is the size of that buffer in bytes. The function wraps the raw NDEF data with the necessary Type-Length-Value (TLV) headers internally. The pointer must remain valid as long as NFC is active. Step 5: Start NFC Emulation After configuring the message and registering the payload, NFC emulation must be activated to begin responding to NFC readers. if (nfc_t2t_emulation_start() < 0) { printk(\"Emulation start failed\\n\"); goto error; } nfc_t2t_emulation_start() enables the NFC hardware and starts field sensing. Once started, events like FIELD_ON , FIELD_OFF , and DATA_READ will be delivered to the user-defined callback. Returns 0 on success; returns an error if already started or hardware is busy. This call marks the final step to make the tag discoverable and readable by external devices.","title":"NFC-Introduction"},{"location":"nfc-01-simple-text/#nfc-01-introduction-to-nfc","text":"Author: Tony Fu Date: 2025/04/27 Device: nRF52840 DK Toolchain: nRF Connect SDK v3.0.0","title":"NFC 01: Introduction to NFC"},{"location":"nfc-01-simple-text/#what-is-nfc","text":"NFC stands for Near Field Communication. It allows two devices to communicate when they are very close, usually within a few centimeters. It is based on magnetic induction, not normal radio waves like Wi-Fi or Bluetooth. It is designed for very short-range and fast interactions. It does not need pairing or long setup. One device usually acts as a passive tag (it does not need power), and the other acts as an active reader (it powers the communication). Some devices, like phones, can do both.","title":"What is NFC?"},{"location":"nfc-01-simple-text/#nfc-device-roles","text":"In NFC communication, devices have specific roles:","title":"NFC Device Roles"},{"location":"nfc-01-simple-text/#tag-passive","text":"A tag stores data. It does not create its own signal. It waits to be powered by a reader. Example: an NFC sticker, a smart card, or an nRF board acting as a tag.","title":"Tag (Passive)"},{"location":"nfc-01-simple-text/#readerwriter-active","text":"A reader generates a magnetic field. It reads data from or writes data to a tag. Example: a smartphone reading a poster or tapping to pay.","title":"Reader/Writer (Active)"},{"location":"nfc-01-simple-text/#peer-to-peer-both-active","text":"Two devices can talk to each other by taking turns. Both generate fields and exchange data. Example: two phones sharing a contact by tapping together. Most nRF boards can only act as a tag.","title":"Peer-to-Peer (Both Active)"},{"location":"nfc-01-simple-text/#nfc-tag-types","text":"When using NFC, devices can either act as a polling device (reader) or a tag (listener). We will focus only on the tag role in this subsection. A tag is a passive NFC device. It does not generate its own electromagnetic field but waits for a polling device like a smartphone to scan it. When scanned, the tag responds by modulating the field. The tag contains simple data, such as a URL or text. Most of Nordic Semiconductor's nRF5 Series devices have a built-in NFC Tag peripheral. This peripheral operates using NFC-A technology (i.e., following the ISO/IEC 14443 Type A standard). NFC-A is the most widely used NFC signaling method and is compatible with most smartphones. The nRF Connect SDK provides libraries to emulate two kinds of NFC tag protocols:","title":"NFC Tag Types"},{"location":"nfc-01-simple-text/#type-2-tag","text":"Based on the NFC Forum Type 2 specification. These tags are simple, lightweight, and fast enough for basic NFC applications like sharing URLs, text messages, or launching apps.","title":"Type 2 Tag"},{"location":"nfc-01-simple-text/#type-4-tag","text":"Based on the NFC Forum Type 4 specification. These tags can store more data, support security features like authentication, and can be used for advanced tasks such as emulating access cards or payment cards. The nRF5 SDK or nRF Connect SDK includes precompiled libraries for both Type 2 and Type 4 Tag emulation. These libraries communicate with the hardware through the NFCT driver inside the nrfxlib module. Other NFC tag types defined by the NFC Forum include:","title":"Type 4 Tag"},{"location":"nfc-01-simple-text/#type-1-tag","text":"The earliest NFC tag type. Very simple. Low speed and small memory. Not common today.","title":"Type 1 Tag"},{"location":"nfc-01-simple-text/#type-3-tag","text":"More complex. Supports higher data rates. Originally designed for specific applications like transit cards in Japan.","title":"Type 3 Tag"},{"location":"nfc-01-simple-text/#type-5-tag","text":"Newer standard. Often used for long-range RFID and NFC applications. Less common in consumer devices. Table comparing the NFC Tag Types: Tag Type Memory Size Speed Special Features Common Use Type 1 Small Slow Basic functionality, simple locking Rare today, early posters Type 2 Small to Medium Medium Lightweight, flexible, widely supported Stickers, marketing, simple IoT devices Type 3 Medium to Large Medium to High Complex, peer-to-peer possible Transit systems (e.g., FeliCa cards in Japan) Type 4 Medium to Large High Secure messaging, encryption, smartcard support Access cards, payment prototypes Type 5 Variable Medium to High Long-range NFC and RFID integration Industrial applications, asset tracking","title":"Type 5 Tag"},{"location":"nfc-01-simple-text/#ndef-nfc-data-exchange-format","text":"Purpose : A standardized data format to encapsulate typed data in NFC communications. Defined by : NFC Forum. Usage : For reading/writing data on NFC tags and peer-to-peer communication.","title":"NDEF: NFC Data Exchange Format"},{"location":"nfc-01-simple-text/#structure","text":"NDEF Message : A container that holds one or more NDEF Records. NDEF Record : Basic unit of NDEF data, with a header and a payload.","title":"Structure:"},{"location":"nfc-01-simple-text/#record-header-fields","text":"MB (Message Begin) : Set in the first record. ME (Message End) : Set in the last record. CF (Chunk Flag) : For chunked payloads. SR (Short Record) : Indicates 1-byte payload length (payload < 256 bytes). IL (ID Length Present) : Indicates presence of an ID field. TNF (Type Name Format) : 3-bit field indicating record type.","title":"Record Header Fields:"},{"location":"nfc-01-simple-text/#record-fields","text":"Type : Describes payload type (e.g., text, URI). ID : Optional identifier for the record. Payload : Actual data (e.g., text string, URL).","title":"Record Fields:"},{"location":"nfc-01-simple-text/#common-tnf-values","text":"0x01 \u2013 Well-known type (e.g., Text, URI) 0x02 \u2013 MIME media type 0x04 \u2013 External type","title":"Common TNF Values:"},{"location":"nfc-01-simple-text/#common-record-types","text":"Text : Type = \"T\", Payload = language code + UTF text. URI : Type = \"U\", Payload = prefix byte + URI string.","title":"Common Record Types:"},{"location":"nfc-01-simple-text/#encoding-example-text","text":"Payload = [lang code len][lang code][UTF-8 text]","title":"Encoding Example (Text):"},{"location":"nfc-01-simple-text/#in-action","text":"This code sets up NFC Type 2 Tag emulation on the nRF52840 DK using Nordic's NFC stack. It builds an NDEF message containing a single well-known Text record with the payload \"Hello World!\" encoded in UTF-8. When a phone or NFC reader enters the field, the tag is activated and the message is transmitted.","title":"In Action"},{"location":"nfc-01-simple-text/#step-1-configure-the-nfc-stack","text":"# NFC Type 2 Tag support via Nordic's nrfxlib backend CONFIG_NFC_T2T_NRFXLIB=y # Enable core NDEF functionality CONFIG_NFC_NDEF=y # Enable NDEF message handling CONFIG_NFC_NDEF_MSG=y # Enable support for NDEF record structures CONFIG_NFC_NDEF_RECORD=y # Enable helper macros/functions for text records CONFIG_NFC_NDEF_TEXT_RECORD=y These options enable both the low-level Type 2 Tag emulation ( nfc_t2t_* APIs) and high-level NDEF message construction utilities (such as text and URI record encoding).","title":"Step 1: Configure the NFC Stack"},{"location":"nfc-01-simple-text/#step-2-handle-nfc-events","text":"#include <nfc_t2t_lib.h> static void nfc_event_handler(void *ctx, nfc_t2t_event_t evt, const uint8_t *data, size_t len) { switch (evt) { case NFC_T2T_EVENT_FIELD_ON: printk(\"Phone detected\\n\"); break; case NFC_T2T_EVENT_FIELD_OFF: printk(\"Phone removed\\n\"); break; default: break; } } This callback receives NFC field events. NFC_T2T_EVENT_FIELD_ON : Indicates that a reader (e.g., a phone) is nearby and the tag is powered. NFC_T2T_EVENT_FIELD_OFF : The reader has moved away; the field is gone. Other events like NFC_T2T_EVENT_DATA_READ (when a reader completes reading) and NFC_T2T_EVENT_STOPPED (when the emulation is explicitly stopped) exist but are optional for basic use. You can handle these for more advanced flows like logging reads or cleaning up. and later in main we can register this handler with the NFC stack: int main(void) { int err = nfc_t2t_setup(nfc_event_handler, NULL); // More code not shown here... } Here, the second argument is a user-defined context pointer. It can be used to pass additional data to the event handler if needed. In this case, we set it to NULL since we don't need any extra context.","title":"Step 2: Handle NFC Events"},{"location":"nfc-01-simple-text/#step-3-encode-ndef-message","text":"To broadcast data over NFC, we must encode it into an NDEF (NFC Data Exchange Format) message. This step shows how to build a basic NDEF message containing a single Text Record using Nordic\u2019s NFC library.","title":"Step 3: Encode NDEF Message"},{"location":"nfc-01-simple-text/#0-include-required-headers","text":"#include <nfc/ndef/msg.h> #include <nfc/ndef/text_rec.h>","title":"0. Include Required Headers"},{"location":"nfc-01-simple-text/#1-define-a-text-record","text":"NFC_NDEF_TEXT_RECORD_DESC_DEF(text_rec, UTF_8, \"en\", 2, \"Hello World!\", 12); This macro: Creates a nfc_ndef_record_desc (record descriptor) and its payload. Parameters: UTF_8 : Specifies text encoding. \"en\", 2 : Language code (\"en\" for English) and its length. \"Hello World!\", 12 : Text string and its length. Use NFC_NDEF_TEXT_RECORD_DESC(text_rec) to access the descriptor later.","title":"1. Define a Text Record"},{"location":"nfc-01-simple-text/#2-define-the-ndef-message","text":"NFC_NDEF_MSG_DEF(ndef_msg, 1); This macro: Declares an NDEF message descriptor with capacity for 1 record. Creates an internal array to hold pointers to record descriptors. Use NFC_NDEF_MSG(ndef_msg) to refer to the message instance.","title":"2. Define the NDEF Message"},{"location":"nfc-01-simple-text/#3-add-the-record-to-the-message","text":"nfc_ndef_msg_record_add(&NFC_NDEF_MSG(ndef_msg), &NFC_NDEF_TEXT_RECORD_DESC(text_rec)); This function: Appends the previously defined text record to the message. Returns 0 on success or a negative error code.","title":"3. Add the Record to the Message"},{"location":"nfc-01-simple-text/#4-encode-the-message-to-a-buffer","text":"nfc_ndef_msg_encode(&NFC_NDEF_MSG(ndef_msg), buf, buf_len); This function: Serializes the message into a raw binary format for NFC transmission. buf is the output buffer; buf_len is input/output (available space / encoded length). The buffer must be large enough to hold the message (128 bytes is usually enough for simple records).","title":"4. Encode the Message to a Buffer"},{"location":"nfc-01-simple-text/#total-code-snippet","text":"#include <nfc/ndef/msg.h> #include <nfc/ndef/text_rec.h> static int create_text_payload(uint8_t *buf, uint32_t *buf_len) { NFC_NDEF_TEXT_RECORD_DESC_DEF(text_rec, UTF_8, \"en\", 2, \"Hello World!\", 12); NFC_NDEF_MSG_DEF(ndef_msg, 1); int ret = nfc_ndef_msg_record_add(&NFC_NDEF_MSG(ndef_msg), &NFC_NDEF_TEXT_RECORD_DESC(text_rec)); if (ret < 0) { return ret; } return nfc_ndef_msg_encode(&NFC_NDEF_MSG(ndef_msg), buf, buf_len); }","title":"Total Code Snippet"},{"location":"nfc-01-simple-text/#step-4-register-payload-for-read","text":"Once the NDEF message is encoded, it must be registered with the NFC stack so that it can be sent to a reader during a READ operation. if (nfc_t2t_payload_set(nfc_data_buf, payload_len) < 0) { printk(\"Unable to load NFC data\\n\"); goto error; } nfc_t2t_payload_set() tells the NFC Type 2 Tag library which data to serve to the reader. nfc_data_buf is a pointer to the encoded NDEF message in RAM. payload_len is the size of that buffer in bytes. The function wraps the raw NDEF data with the necessary Type-Length-Value (TLV) headers internally. The pointer must remain valid as long as NFC is active.","title":"Step 4: Register Payload for Read"},{"location":"nfc-01-simple-text/#step-5-start-nfc-emulation","text":"After configuring the message and registering the payload, NFC emulation must be activated to begin responding to NFC readers. if (nfc_t2t_emulation_start() < 0) { printk(\"Emulation start failed\\n\"); goto error; } nfc_t2t_emulation_start() enables the NFC hardware and starts field sensing. Once started, events like FIELD_ON , FIELD_OFF , and DATA_READ will be delivered to the user-defined callback. Returns 0 on success; returns an error if already started or hardware is busy. This call marks the final step to make the tag discoverable and readable by external devices.","title":"Step 5: Start NFC Emulation"},{"location":"nfc-02-writable-tag/","text":"NFC 02: Writable Tag Author: Tony Fu Date: 2025/05/04 Device: nRF52840 DK Toolchain: nRF Connect SDK v3.0.0 NFC Tag Type Comparison (Type 2 vs Type 4) In this example, we will use our phone to write data to the NFC tag. We need to use type 4 tag for this purpose. The nRF Connect SDK allows us to use both type 2 and type 4 tags. The table below summarizes the differences between the two types of tags: Feature Type 2 Tag Type 4 Tag Writability by phone \u274c Not supported (in Nordic SDK) \u2705 Fully supported Read support \u2705 Yes \u2705 Yes Data update method Static; updated via firmware or internal logic only Dynamic; data written via NFC (e.g., from phone) Storage backend No file system (raw TLV structure in RAM) NDEF file with internal length and control structure File system support \u274c None \u2705 Uses NDEF file abstraction Authentication \u274c Not supported \u2705 Optional (ISO 7816-style command sets) Tag activation Type 2 Tag protocol ISO/IEC 14443-4 (APDU protocol) Library used (nRF SDK) nfc_t2t_lib nfc_t4t_lib Use case Simple, static read-only tags (e.g., fixed URLs) Smart cards, writable business cards, secure access In Action This example demonstrates how to create and emulate a writable NFC Type 4 Tag using the nRF Connect SDK. It builds a simple NDEF text message with the payload \"42\" , sets up an emulation buffer, starts NFC communication, and handles basic tag events such as read, write, and field detection. Step 1: Configure the NFC Stack Just like the previous example, we need to enable the NFC stack in the prj.conf file. The only difference is that we need to enable the CONFIG_NFC_T4T_NRFXLIB option to use the type 4 tag. # NFC Type 4 Support CONFIG_NFC_T4T_NRFXLIB=y # NFC NDEF (High-Level Message Encoding) CONFIG_NFC_NDEF=y CONFIG_NFC_NDEF_MSG=y CONFIG_NFC_NDEF_RECORD=y CONFIG_NFC_NDEF_TEXT_RECORD=y Step 2: Handle NFC Events Just like the previous example, we need to handle NFC events in the main loop #include <nfc_t4t_lib.h> static void tag_event_handler(void *ctx, nfc_t4t_event_t evt, const uint8_t *data, size_t len, uint32_t flags) { ARG_UNUSED(ctx); ARG_UNUSED(data); ARG_UNUSED(flags); switch (evt) { case NFC_T4T_EVENT_FIELD_ON: printk(\"Reader present\\n\"); break; case NFC_T4T_EVENT_FIELD_OFF: printk(\"Reader removed\\n\"); break; case NFC_T4T_EVENT_NDEF_READ: printk(\"Message read\\n\"); break; case NFC_T4T_EVENT_NDEF_UPDATED: printk(\"Message updated (%d bytes)\\n\", len); break; default: break; } } and later in main we can register this handler with the NFC stack: int main(void) { // More code not shown here... if (nfc_t4t_setup(tag_event_handler, NULL) < 0) { printk(\"Error: NFC setup failed\\n\"); return -1; } // More code not shown here... } Step 3: Encode NDEF Message Next, we encode the NDEF message. The example below creates a text record with the payload \"42\" and language code \"en\" : static int create_text_payload(uint8_t *buf, uint32_t *len) { /* Define a text record with language code \"en\" and payload \"42\" */ NFC_NDEF_TEXT_RECORD_DESC_DEF(txt_rec, UTF_8, \"en\", 2, \"42\", 2); NFC_NDEF_MSG_DEF(msg, 1); int err = nfc_ndef_msg_record_add(&NFC_NDEF_MSG(msg), &NFC_NDEF_TEXT_RECORD_DESC(txt_rec)); if (err < 0) { return err; } uint32_t used = *len; err = nfc_ndef_msg_encode(&NFC_NDEF_MSG(msg), nfc_t4t_ndef_file_msg_get(buf), &used); if (err < 0) { return err; } err = nfc_t4t_ndef_file_encode(buf, &used); if (err < 0) { return err; } *len = used; return 0; } This is similar to the earlier example using T2T, but here in additionally we use nfc_t4t_ndef_file_msg_get to retrieve the buffer where the encoded NDEF message should be stored. This function provides access to the internal buffer structure used by T4T formatting. The final step uses nfc_t4t_ndef_file_encode , which wraps the encoded message in the full T4T NDEF file format. This is required because a Type 4 Tag expects the NDEF data to follow a specific structure. file_buf : A pointer to the output buffer that will hold the fully formatted NDEF file. size : A pointer to a variable that initially holds the buffer size and returns the actual size used after encoding. This function is essential to ensure the message conforms to the T4T specification and can be read by NFC readers that support this format. Later on, we will call this function to encode the NDEF message and write it to the NFC tag: #define NFC_MEM_SIZE 256 static uint8_t nfc_mem[NFC_MEM_SIZE]; main() { uint32_t ndef_len = NFC_MEM_SIZE; if (create_text_payload(nfc_mem, &ndef_len) < 0) { printk(\"Error: failed to build initial message\\n\"); return -1; } if (nfc_t4t_setup(tag_event_handler, NULL) < 0) { printk(\"Error: NFC setup failed\\n\"); return -1; } // More code not shown here... } Step 4: Set Emulation Buffer and Start NFC Before starting NFC communication, we must configure the buffer that holds the NDEF data and then activate the NFC emulation. if (nfc_t4t_ndef_rwpayload_set(nfc_mem, NFC_MEM_SIZE) < 0) { printk(\"Error: cannot set buffer\\n\"); return -1; } if (nfc_t4t_emulation_start() < 0) { printk(\"Error: emulation failed\\n\"); return -1; } The first function, nfc_t4t_ndef_rwpayload_set , sets the buffer used for emulating a read/write NDEF tag. This buffer must remain accessible for as long as the emulation is active. It will be updated if an external NFC reader modifies the content. You must ensure the buffer length is consistent across updates, and it should not be the same memory currently in use. nfc_mem : A pointer to the buffer that stores the NDEF content. NFC_MEM_SIZE : The size of this buffer in bytes. The second function, nfc_t4t_emulation_start , activates the NFC frontend. This must be called after the payload buffer is set. Once started, NFC events (like reads or writes) will be handled by the NFC stack and delivered to the application callback. These calls are essential to make the device appear as a writable NFC Type 4 Tag to external readers. In the end, the main function looks like this: int main(void) { printk(\"NFC tag init\\n\"); uint32_t ndef_len = NFC_MEM_SIZE; if (create_text_payload(nfc_mem, &ndef_len) < 0) { printk(\"Error: failed to build initial message\\n\"); return -1; } if (nfc_t4t_setup(tag_event_handler, NULL) < 0) { printk(\"Error: NFC setup failed\\n\"); return -1; } if (nfc_t4t_ndef_rwpayload_set(nfc_mem, NFC_MEM_SIZE) < 0) { printk(\"Error: cannot set buffer\\n\"); return -1; } if (nfc_t4t_emulation_start() < 0) { printk(\"Error: emulation failed\\n\"); return -1; } printk(\"Tag is writable. Waiting...\\n\"); while (1) { k_sleep(K_FOREVER); } }","title":"NFC-Writable Tag"},{"location":"nfc-02-writable-tag/#nfc-02-writable-tag","text":"Author: Tony Fu Date: 2025/05/04 Device: nRF52840 DK Toolchain: nRF Connect SDK v3.0.0","title":"NFC 02: Writable Tag"},{"location":"nfc-02-writable-tag/#nfc-tag-type-comparison-type-2-vs-type-4","text":"In this example, we will use our phone to write data to the NFC tag. We need to use type 4 tag for this purpose. The nRF Connect SDK allows us to use both type 2 and type 4 tags. The table below summarizes the differences between the two types of tags: Feature Type 2 Tag Type 4 Tag Writability by phone \u274c Not supported (in Nordic SDK) \u2705 Fully supported Read support \u2705 Yes \u2705 Yes Data update method Static; updated via firmware or internal logic only Dynamic; data written via NFC (e.g., from phone) Storage backend No file system (raw TLV structure in RAM) NDEF file with internal length and control structure File system support \u274c None \u2705 Uses NDEF file abstraction Authentication \u274c Not supported \u2705 Optional (ISO 7816-style command sets) Tag activation Type 2 Tag protocol ISO/IEC 14443-4 (APDU protocol) Library used (nRF SDK) nfc_t2t_lib nfc_t4t_lib Use case Simple, static read-only tags (e.g., fixed URLs) Smart cards, writable business cards, secure access","title":"NFC Tag Type Comparison (Type 2 vs Type 4)"},{"location":"nfc-02-writable-tag/#in-action","text":"This example demonstrates how to create and emulate a writable NFC Type 4 Tag using the nRF Connect SDK. It builds a simple NDEF text message with the payload \"42\" , sets up an emulation buffer, starts NFC communication, and handles basic tag events such as read, write, and field detection.","title":"In Action"},{"location":"nfc-02-writable-tag/#step-1-configure-the-nfc-stack","text":"Just like the previous example, we need to enable the NFC stack in the prj.conf file. The only difference is that we need to enable the CONFIG_NFC_T4T_NRFXLIB option to use the type 4 tag. # NFC Type 4 Support CONFIG_NFC_T4T_NRFXLIB=y # NFC NDEF (High-Level Message Encoding) CONFIG_NFC_NDEF=y CONFIG_NFC_NDEF_MSG=y CONFIG_NFC_NDEF_RECORD=y CONFIG_NFC_NDEF_TEXT_RECORD=y","title":"Step 1: Configure the NFC Stack"},{"location":"nfc-02-writable-tag/#step-2-handle-nfc-events","text":"Just like the previous example, we need to handle NFC events in the main loop #include <nfc_t4t_lib.h> static void tag_event_handler(void *ctx, nfc_t4t_event_t evt, const uint8_t *data, size_t len, uint32_t flags) { ARG_UNUSED(ctx); ARG_UNUSED(data); ARG_UNUSED(flags); switch (evt) { case NFC_T4T_EVENT_FIELD_ON: printk(\"Reader present\\n\"); break; case NFC_T4T_EVENT_FIELD_OFF: printk(\"Reader removed\\n\"); break; case NFC_T4T_EVENT_NDEF_READ: printk(\"Message read\\n\"); break; case NFC_T4T_EVENT_NDEF_UPDATED: printk(\"Message updated (%d bytes)\\n\", len); break; default: break; } } and later in main we can register this handler with the NFC stack: int main(void) { // More code not shown here... if (nfc_t4t_setup(tag_event_handler, NULL) < 0) { printk(\"Error: NFC setup failed\\n\"); return -1; } // More code not shown here... }","title":"Step 2: Handle NFC Events"},{"location":"nfc-02-writable-tag/#step-3-encode-ndef-message","text":"Next, we encode the NDEF message. The example below creates a text record with the payload \"42\" and language code \"en\" : static int create_text_payload(uint8_t *buf, uint32_t *len) { /* Define a text record with language code \"en\" and payload \"42\" */ NFC_NDEF_TEXT_RECORD_DESC_DEF(txt_rec, UTF_8, \"en\", 2, \"42\", 2); NFC_NDEF_MSG_DEF(msg, 1); int err = nfc_ndef_msg_record_add(&NFC_NDEF_MSG(msg), &NFC_NDEF_TEXT_RECORD_DESC(txt_rec)); if (err < 0) { return err; } uint32_t used = *len; err = nfc_ndef_msg_encode(&NFC_NDEF_MSG(msg), nfc_t4t_ndef_file_msg_get(buf), &used); if (err < 0) { return err; } err = nfc_t4t_ndef_file_encode(buf, &used); if (err < 0) { return err; } *len = used; return 0; } This is similar to the earlier example using T2T, but here in additionally we use nfc_t4t_ndef_file_msg_get to retrieve the buffer where the encoded NDEF message should be stored. This function provides access to the internal buffer structure used by T4T formatting. The final step uses nfc_t4t_ndef_file_encode , which wraps the encoded message in the full T4T NDEF file format. This is required because a Type 4 Tag expects the NDEF data to follow a specific structure. file_buf : A pointer to the output buffer that will hold the fully formatted NDEF file. size : A pointer to a variable that initially holds the buffer size and returns the actual size used after encoding. This function is essential to ensure the message conforms to the T4T specification and can be read by NFC readers that support this format. Later on, we will call this function to encode the NDEF message and write it to the NFC tag: #define NFC_MEM_SIZE 256 static uint8_t nfc_mem[NFC_MEM_SIZE]; main() { uint32_t ndef_len = NFC_MEM_SIZE; if (create_text_payload(nfc_mem, &ndef_len) < 0) { printk(\"Error: failed to build initial message\\n\"); return -1; } if (nfc_t4t_setup(tag_event_handler, NULL) < 0) { printk(\"Error: NFC setup failed\\n\"); return -1; } // More code not shown here... }","title":"Step 3: Encode NDEF Message"},{"location":"nfc-02-writable-tag/#step-4-set-emulation-buffer-and-start-nfc","text":"Before starting NFC communication, we must configure the buffer that holds the NDEF data and then activate the NFC emulation. if (nfc_t4t_ndef_rwpayload_set(nfc_mem, NFC_MEM_SIZE) < 0) { printk(\"Error: cannot set buffer\\n\"); return -1; } if (nfc_t4t_emulation_start() < 0) { printk(\"Error: emulation failed\\n\"); return -1; } The first function, nfc_t4t_ndef_rwpayload_set , sets the buffer used for emulating a read/write NDEF tag. This buffer must remain accessible for as long as the emulation is active. It will be updated if an external NFC reader modifies the content. You must ensure the buffer length is consistent across updates, and it should not be the same memory currently in use. nfc_mem : A pointer to the buffer that stores the NDEF content. NFC_MEM_SIZE : The size of this buffer in bytes. The second function, nfc_t4t_emulation_start , activates the NFC frontend. This must be called after the payload buffer is set. Once started, NFC events (like reads or writes) will be handled by the NFC stack and delivered to the application callback. These calls are essential to make the device appear as a writable NFC Type 4 Tag to external readers. In the end, the main function looks like this: int main(void) { printk(\"NFC tag init\\n\"); uint32_t ndef_len = NFC_MEM_SIZE; if (create_text_payload(nfc_mem, &ndef_len) < 0) { printk(\"Error: failed to build initial message\\n\"); return -1; } if (nfc_t4t_setup(tag_event_handler, NULL) < 0) { printk(\"Error: NFC setup failed\\n\"); return -1; } if (nfc_t4t_ndef_rwpayload_set(nfc_mem, NFC_MEM_SIZE) < 0) { printk(\"Error: cannot set buffer\\n\"); return -1; } if (nfc_t4t_emulation_start() < 0) { printk(\"Error: emulation failed\\n\"); return -1; } printk(\"Tag is writable. Waiting...\\n\"); while (1) { k_sleep(K_FOREVER); } }","title":"Step 4: Set Emulation Buffer and Start NFC"},{"location":"os-01-basic/","text":"OS 01: Basics Author: Tony Fu Date: 2025/05/11 Device: nRF52840 DK Toolchain: nRF Connect SDK v3.0.0 Zephyr Thread States In Zephyr RTOS, each thread's status is represented internally as a bitmask field ( thread_state ) within the thread structure. This allows a thread to simultaneously hold multiple state flags, enabling nuanced control and scheduling decisions. The states are decoded by functions like k_thread_state_str() , which interpret and format these bit flags into readable strings. Below is a summary of the known internal thread states: DUMMY : The thread structure is not associated with an actual thread. Often used for initialization or placeholders. PENDING : The thread is waiting for a resource (e.g., semaphore, mutex, queue). It is not ready to run. PRESTART : The thread has been created but not yet started (i.e., k_thread_start() hasn\u2019t been called). DEAD : The thread has terminated and is no longer active. SUSPENDED : The thread has been explicitly suspended and cannot run until resumed. ABORTING : The thread is in the process of being aborted (usually via k_thread_abort() ). SUSPENDING : The thread is transitioning into the suspended state. QUEUED : The thread is queued in an object (e.g., waiting in a FIFO or work queue). These states are not mutually exclusive . A thread can, and often does, hold more than one state flag at the same time. The system uses these combinations to precisely reflect what is happening with the thread at any given moment. Example : A thread waiting on a queue and also marked for suspension could have the state: PENDING + SUSPENDING This indicates that the thread is waiting for data and, simultaneously, in the process of being suspended. Simplified View (as used in Nordic's nRF Connect SDK course) To make the model more digestible, Nordic classifies threads into just three broad states: Course State Meaning Internal Representation Running Actively executing on the CPU. Not stored in thread_state , but implied by the scheduler. Runnable Ready to run, only waiting for CPU time. Internally: thread_state == 0 (no flags set) Non-runnable Blocked, suspended, or otherwise ineligible to run. Any combination of internal flags like PENDING , SUSPENDED , etc. This simplification omits internal transitions and overlaps for the sake of clarity, especially when teaching fundamentals. However, understanding the bitmask-based system helps when debugging or implementing lower-level scheduling logic. Thread Priority in Zephyr In Zephyr, each thread is assigned an integer priority. Lower numbers indicate higher priority. For example, a thread with priority 2 will run before one with priority 5 . Zephyr distinguishes between two types of threads based on priority: Preemptible threads : These have non-negative priorities ( 0 and up). They can be interrupted by other threads of equal or higher priority. Cooperative threads : These use negative priorities and cannot be preempted . Once running, they keep the CPU until they yield or block. The default configuration allows: 15 preemptible levels , from 0 (high) to 15 (low, used by the idle thread). 16 cooperative levels , from -1 down to -16 . Preemptible threads are the norm; cooperative threads are used rarely and typically not covered in beginner material. Rescheduling Points in Zephyr Zephyr is a tickless, event-driven RTOS , meaning the scheduler runs only when needed\u2014not on a fixed timer. A rescheduling point is any moment when the scheduler is invoked to reconsider which thread should run next. This happens whenever the state of the Ready queue changes . Common rescheduling triggers: A thread calls k_yield() : its state changes from Running to Ready . A thread becomes unready (e.g., when calling k_sleep() ): its state changes from Running to Non-runnable . A blocked thread is unblocked by a sync object (e.g., semaphore, mutex): its state becomes Ready . A thread waiting for data receives input: its state transitions to Ready . Time slicing is enabled and the current thread exceeds its allowed slice: it's moved from Running to Ready . These transitions prompt the scheduler to re-evaluate which thread to run based on priority and readiness. Time Slicing in Zephyr Time slicing allows threads of the same (non-negative) priority to share CPU time in a round-robin fashion. How it works: You configure a time slice duration using CONFIG_TIMESLICE_SIZE . If enabled, each preemptible thread (priority \u2265 0) gets up to that amount of time before being moved back to the Ready queue. This lets other threads of equal priority run in turn. This prevents a single thread from monopolizing the CPU, especially in when it provides no explicit rescheduling points. Key points: Only applies to preemptible threads (non-negative priority). Cooperative threads (negative priority) are not affected by time slicing\u2014they must yield explicitly. Time slicing does not override priority. Higher-priority threads always preempt lower-priority ones, regardless of time slices. Creating Threads in Zephyr To work with threads in Zephyr, include the core kernel API header: #include <zephyr/kernel.h> This gives access to thread management functions, synchronization primitives, and timing utilities. Why the k_ Prefix? Zephyr uses the k_ prefix to mark functions, types, and macros that are part of the kernel API . This naming convention makes it clear that you're working with internal kernel mechanisms, helping distinguish them from application-level symbols. Basic Thread Creation Example Here\u2019s an example that defines two threads. Each prints a message and displays the current state of both threads. Notice that even though the threads are created in runtime, their stack space is allocated at compile time. #include <zephyr/kernel.h> #include <zephyr/sys/printk.h> #define STACK_SIZE 512 #define PRIORITY 5 K_THREAD_STACK_DEFINE(thread1_stack, STACK_SIZE); K_THREAD_STACK_DEFINE(thread2_stack, STACK_SIZE); struct k_thread thread1_data; struct k_thread thread2_data; void thread1_entry(void *p1, void *p2, void *p3); void thread2_entry(void *p1, void *p2, void *p3); struct k_thread *t1_ptr = &thread1_data; struct k_thread *t2_ptr = &thread2_data; Each thread runs a loop, prints a message, and inspects thread states: void thread1_entry(void *p1, void *p2, void *p3) { while (1) { printk(\"Thread 1 says hello!\\n\"); char buf[32]; printk(\"Thread 1 state: %s\\n\", k_thread_state_str(t1_ptr, buf, sizeof(buf))); printk(\"Thread 2 state: %s\\n\", k_thread_state_str(t2_ptr, buf, sizeof(buf))); k_sleep(K_MSEC(1000)); } } void thread2_entry(void *p1, void *p2, void *p3) { while (1) { printk(\"Thread 2 reporting in.\\n\"); char buf[32]; printk(\"Thread 1 state: %s\\n\", k_thread_state_str(t1_ptr, buf, sizeof(buf))); printk(\"Thread 2 state: %s\\n\", k_thread_state_str(t2_ptr, buf, sizeof(buf))); k_sleep(K_MSEC(1000)); } } Threads are created in the main() function using k_thread_create() : void main(void) { k_thread_create(&thread1_data, thread1_stack, STACK_SIZE, thread1_entry, NULL, NULL, NULL, PRIORITY, 0, K_NO_WAIT); k_thread_create(&thread2_data, thread2_stack, STACK_SIZE, thread2_entry, NULL, NULL, NULL, PRIORITY, 0, K_NO_WAIT); printk(\"Main thread done launching threads.\\n\"); } Explanation of k_thread_create() k_tid_t k_thread_create( struct k_thread *new_thread, k_thread_stack_t *stack, size_t stack_size, k_thread_entry_t entry, void *p1, void *p2, void *p3, int prio, uint32_t options, k_timeout_t delay); new_thread : Pointer to a k_thread struct used for tracking the thread. stack : Pointer to stack memory defined with K_THREAD_STACK_DEFINE() . stack_size : Must match the size used when defining the stack. entry : Function to run when the thread starts. p1\u2013p3 : Optional arguments passed to the thread entry function. prio : Thread priority. Lower values mean higher priority. options : Architecture-specific flags; use 0 for basic threads. delay : Use K_NO_WAIT to start immediately, or a timeout for delayed start. Results When you run the code, you should see output similar to this: Thread 1 state: sleeping Thread 2 state: queued Thread 1 says hello! Thread 1 state: queued Thread 2 state: sleeping Thread 2 reporting in. Thread 1 state: sleeping Thread 2 state: queued Thread 1 says hello! Thread 1 state: queued Thread 2 state: sleeping Thread 2 reporting in. This output shows the state of each thread as they run. The states will change based on the actions taken by each thread and the scheduler's decisions.","title":"OS-Basic"},{"location":"os-01-basic/#os-01-basics","text":"Author: Tony Fu Date: 2025/05/11 Device: nRF52840 DK Toolchain: nRF Connect SDK v3.0.0","title":"OS 01: Basics"},{"location":"os-01-basic/#zephyr-thread-states","text":"In Zephyr RTOS, each thread's status is represented internally as a bitmask field ( thread_state ) within the thread structure. This allows a thread to simultaneously hold multiple state flags, enabling nuanced control and scheduling decisions. The states are decoded by functions like k_thread_state_str() , which interpret and format these bit flags into readable strings. Below is a summary of the known internal thread states: DUMMY : The thread structure is not associated with an actual thread. Often used for initialization or placeholders. PENDING : The thread is waiting for a resource (e.g., semaphore, mutex, queue). It is not ready to run. PRESTART : The thread has been created but not yet started (i.e., k_thread_start() hasn\u2019t been called). DEAD : The thread has terminated and is no longer active. SUSPENDED : The thread has been explicitly suspended and cannot run until resumed. ABORTING : The thread is in the process of being aborted (usually via k_thread_abort() ). SUSPENDING : The thread is transitioning into the suspended state. QUEUED : The thread is queued in an object (e.g., waiting in a FIFO or work queue). These states are not mutually exclusive . A thread can, and often does, hold more than one state flag at the same time. The system uses these combinations to precisely reflect what is happening with the thread at any given moment.","title":"Zephyr Thread States"},{"location":"os-01-basic/#example","text":"A thread waiting on a queue and also marked for suspension could have the state: PENDING + SUSPENDING This indicates that the thread is waiting for data and, simultaneously, in the process of being suspended.","title":"Example:"},{"location":"os-01-basic/#simplified-view-as-used-in-nordics-nrf-connect-sdk-course","text":"To make the model more digestible, Nordic classifies threads into just three broad states: Course State Meaning Internal Representation Running Actively executing on the CPU. Not stored in thread_state , but implied by the scheduler. Runnable Ready to run, only waiting for CPU time. Internally: thread_state == 0 (no flags set) Non-runnable Blocked, suspended, or otherwise ineligible to run. Any combination of internal flags like PENDING , SUSPENDED , etc. This simplification omits internal transitions and overlaps for the sake of clarity, especially when teaching fundamentals. However, understanding the bitmask-based system helps when debugging or implementing lower-level scheduling logic.","title":"Simplified View (as used in Nordic's nRF Connect SDK course)"},{"location":"os-01-basic/#thread-priority-in-zephyr","text":"In Zephyr, each thread is assigned an integer priority. Lower numbers indicate higher priority. For example, a thread with priority 2 will run before one with priority 5 . Zephyr distinguishes between two types of threads based on priority: Preemptible threads : These have non-negative priorities ( 0 and up). They can be interrupted by other threads of equal or higher priority. Cooperative threads : These use negative priorities and cannot be preempted . Once running, they keep the CPU until they yield or block. The default configuration allows: 15 preemptible levels , from 0 (high) to 15 (low, used by the idle thread). 16 cooperative levels , from -1 down to -16 . Preemptible threads are the norm; cooperative threads are used rarely and typically not covered in beginner material.","title":"Thread Priority in Zephyr"},{"location":"os-01-basic/#rescheduling-points-in-zephyr","text":"Zephyr is a tickless, event-driven RTOS , meaning the scheduler runs only when needed\u2014not on a fixed timer. A rescheduling point is any moment when the scheduler is invoked to reconsider which thread should run next. This happens whenever the state of the Ready queue changes .","title":"Rescheduling Points in Zephyr"},{"location":"os-01-basic/#common-rescheduling-triggers","text":"A thread calls k_yield() : its state changes from Running to Ready . A thread becomes unready (e.g., when calling k_sleep() ): its state changes from Running to Non-runnable . A blocked thread is unblocked by a sync object (e.g., semaphore, mutex): its state becomes Ready . A thread waiting for data receives input: its state transitions to Ready . Time slicing is enabled and the current thread exceeds its allowed slice: it's moved from Running to Ready . These transitions prompt the scheduler to re-evaluate which thread to run based on priority and readiness.","title":"Common rescheduling triggers:"},{"location":"os-01-basic/#time-slicing-in-zephyr","text":"Time slicing allows threads of the same (non-negative) priority to share CPU time in a round-robin fashion.","title":"Time Slicing in Zephyr"},{"location":"os-01-basic/#how-it-works","text":"You configure a time slice duration using CONFIG_TIMESLICE_SIZE . If enabled, each preemptible thread (priority \u2265 0) gets up to that amount of time before being moved back to the Ready queue. This lets other threads of equal priority run in turn. This prevents a single thread from monopolizing the CPU, especially in when it provides no explicit rescheduling points.","title":"How it works:"},{"location":"os-01-basic/#key-points","text":"Only applies to preemptible threads (non-negative priority). Cooperative threads (negative priority) are not affected by time slicing\u2014they must yield explicitly. Time slicing does not override priority. Higher-priority threads always preempt lower-priority ones, regardless of time slices.","title":"Key points:"},{"location":"os-01-basic/#creating-threads-in-zephyr","text":"To work with threads in Zephyr, include the core kernel API header: #include <zephyr/kernel.h> This gives access to thread management functions, synchronization primitives, and timing utilities.","title":"Creating Threads in Zephyr"},{"location":"os-01-basic/#why-the-k_-prefix","text":"Zephyr uses the k_ prefix to mark functions, types, and macros that are part of the kernel API . This naming convention makes it clear that you're working with internal kernel mechanisms, helping distinguish them from application-level symbols.","title":"Why the k_ Prefix?"},{"location":"os-01-basic/#basic-thread-creation-example","text":"Here\u2019s an example that defines two threads. Each prints a message and displays the current state of both threads. Notice that even though the threads are created in runtime, their stack space is allocated at compile time. #include <zephyr/kernel.h> #include <zephyr/sys/printk.h> #define STACK_SIZE 512 #define PRIORITY 5 K_THREAD_STACK_DEFINE(thread1_stack, STACK_SIZE); K_THREAD_STACK_DEFINE(thread2_stack, STACK_SIZE); struct k_thread thread1_data; struct k_thread thread2_data; void thread1_entry(void *p1, void *p2, void *p3); void thread2_entry(void *p1, void *p2, void *p3); struct k_thread *t1_ptr = &thread1_data; struct k_thread *t2_ptr = &thread2_data; Each thread runs a loop, prints a message, and inspects thread states: void thread1_entry(void *p1, void *p2, void *p3) { while (1) { printk(\"Thread 1 says hello!\\n\"); char buf[32]; printk(\"Thread 1 state: %s\\n\", k_thread_state_str(t1_ptr, buf, sizeof(buf))); printk(\"Thread 2 state: %s\\n\", k_thread_state_str(t2_ptr, buf, sizeof(buf))); k_sleep(K_MSEC(1000)); } } void thread2_entry(void *p1, void *p2, void *p3) { while (1) { printk(\"Thread 2 reporting in.\\n\"); char buf[32]; printk(\"Thread 1 state: %s\\n\", k_thread_state_str(t1_ptr, buf, sizeof(buf))); printk(\"Thread 2 state: %s\\n\", k_thread_state_str(t2_ptr, buf, sizeof(buf))); k_sleep(K_MSEC(1000)); } } Threads are created in the main() function using k_thread_create() : void main(void) { k_thread_create(&thread1_data, thread1_stack, STACK_SIZE, thread1_entry, NULL, NULL, NULL, PRIORITY, 0, K_NO_WAIT); k_thread_create(&thread2_data, thread2_stack, STACK_SIZE, thread2_entry, NULL, NULL, NULL, PRIORITY, 0, K_NO_WAIT); printk(\"Main thread done launching threads.\\n\"); }","title":"Basic Thread Creation Example"},{"location":"os-01-basic/#explanation-of-k_thread_create","text":"k_tid_t k_thread_create( struct k_thread *new_thread, k_thread_stack_t *stack, size_t stack_size, k_thread_entry_t entry, void *p1, void *p2, void *p3, int prio, uint32_t options, k_timeout_t delay); new_thread : Pointer to a k_thread struct used for tracking the thread. stack : Pointer to stack memory defined with K_THREAD_STACK_DEFINE() . stack_size : Must match the size used when defining the stack. entry : Function to run when the thread starts. p1\u2013p3 : Optional arguments passed to the thread entry function. prio : Thread priority. Lower values mean higher priority. options : Architecture-specific flags; use 0 for basic threads. delay : Use K_NO_WAIT to start immediately, or a timeout for delayed start.","title":"Explanation of k_thread_create()"},{"location":"os-01-basic/#results","text":"When you run the code, you should see output similar to this: Thread 1 state: sleeping Thread 2 state: queued Thread 1 says hello! Thread 1 state: queued Thread 2 state: sleeping Thread 2 reporting in. Thread 1 state: sleeping Thread 2 state: queued Thread 1 says hello! Thread 1 state: queued Thread 2 state: sleeping Thread 2 reporting in. This output shows the state of each thread as they run. The states will change based on the actions taken by each thread and the scheduler's decisions.","title":"Results"},{"location":"os-02-workqueue/","text":"OS 02: Workqueue Author: Tony Fu Date: 2025/05/11 Device: nRF52840 DK Toolchain: nRF Connect SDK v3.0.0 Types of Threads In Zephyr RTOS, threads are the primary units of execution. There are three main categories you\u2019ll encounter: system threads , user-defined threads , and workqueue threads . Each serves a distinct purpose in managing how work is scheduled and executed. 1. System Threads System threads are created automatically by Zephyr during system startup. Two are always present: Main thread : After basic kernel setup, this thread runs the application\u2019s main() function. If no main() is defined, the thread simply exits once initialization is complete, and the system continues running. Idle thread : When no other threads are ready to run, the idle thread takes over. It typically enters a low-power state to conserve energy, especially on platforms like Nordic\u2019s nRF series. These threads ensure the RTOS is always operational, even with no application-specific threads running. 2. User-Defined Threads We as developers can define additional threads to structure our application logic using k_thread_create() . Each thread runs independently and is assigned a priority to control scheduling. 3. Workqueue Threads A workqueue thread processes lightweight tasks called work items . A work item is simply a function submitted to a queue, typically from an interrupt or high-priority context. The workqueue thread executes these functions in the order they were received (FIFO). Zephyr includes a system workqueue by default. You can submit work items to it without creating a custom workqueue. The thread backing the system workqueue is itself a system thread. In this example, we will try using the system workqueue to process a simple task. In Action This example demonstrates how to use the default system workqueue in Zephyr to offload a non-urgent task. The work item runs in a separate thread managed by the kernel, which helps prevent blocking the main thread or higher-priority contexts. 1. Declare a Work Item static struct k_work my_work; This defines a work item structure . It's a lightweight object used to represent a unit of deferred work. The system workqueue will call a user-defined function ( work_handler ) when this work item is processed. 2. Define the Work Handler void work_handler(struct k_work *work) { printk(\"Work handler running in system workqueue.\\n\"); for (volatile int i = 0; i < 5000000; i++); // Simulated delay printk(\"Work handler done.\\n\"); } This function will be executed by the system workqueue thread , not the main thread. It simulates a time-consuming task using a busy loop. 3. Initialize and Submit the Work Item Now we initialize a work item and associates it with a handler function: void main(void) { printk(\"Main thread started.\\n\"); k_work_init(&my_work, work_handler); and later submit it to the system workqueue: k_work_submit(&my_work);","title":"OS-Workqueue"},{"location":"os-02-workqueue/#os-02-workqueue","text":"Author: Tony Fu Date: 2025/05/11 Device: nRF52840 DK Toolchain: nRF Connect SDK v3.0.0","title":"OS 02: Workqueue"},{"location":"os-02-workqueue/#types-of-threads","text":"In Zephyr RTOS, threads are the primary units of execution. There are three main categories you\u2019ll encounter: system threads , user-defined threads , and workqueue threads . Each serves a distinct purpose in managing how work is scheduled and executed.","title":"Types of Threads"},{"location":"os-02-workqueue/#1-system-threads","text":"System threads are created automatically by Zephyr during system startup. Two are always present: Main thread : After basic kernel setup, this thread runs the application\u2019s main() function. If no main() is defined, the thread simply exits once initialization is complete, and the system continues running. Idle thread : When no other threads are ready to run, the idle thread takes over. It typically enters a low-power state to conserve energy, especially on platforms like Nordic\u2019s nRF series. These threads ensure the RTOS is always operational, even with no application-specific threads running.","title":"1. System Threads"},{"location":"os-02-workqueue/#2-user-defined-threads","text":"We as developers can define additional threads to structure our application logic using k_thread_create() . Each thread runs independently and is assigned a priority to control scheduling.","title":"2. User-Defined Threads"},{"location":"os-02-workqueue/#3-workqueue-threads","text":"A workqueue thread processes lightweight tasks called work items . A work item is simply a function submitted to a queue, typically from an interrupt or high-priority context. The workqueue thread executes these functions in the order they were received (FIFO). Zephyr includes a system workqueue by default. You can submit work items to it without creating a custom workqueue. The thread backing the system workqueue is itself a system thread. In this example, we will try using the system workqueue to process a simple task.","title":"3. Workqueue Threads"},{"location":"os-02-workqueue/#in-action","text":"This example demonstrates how to use the default system workqueue in Zephyr to offload a non-urgent task. The work item runs in a separate thread managed by the kernel, which helps prevent blocking the main thread or higher-priority contexts.","title":"In Action"},{"location":"os-02-workqueue/#1-declare-a-work-item","text":"static struct k_work my_work; This defines a work item structure . It's a lightweight object used to represent a unit of deferred work. The system workqueue will call a user-defined function ( work_handler ) when this work item is processed.","title":"1. Declare a Work Item"},{"location":"os-02-workqueue/#2-define-the-work-handler","text":"void work_handler(struct k_work *work) { printk(\"Work handler running in system workqueue.\\n\"); for (volatile int i = 0; i < 5000000; i++); // Simulated delay printk(\"Work handler done.\\n\"); } This function will be executed by the system workqueue thread , not the main thread. It simulates a time-consuming task using a busy loop.","title":"2. Define the Work Handler"},{"location":"os-02-workqueue/#3-initialize-and-submit-the-work-item","text":"Now we initialize a work item and associates it with a handler function: void main(void) { printk(\"Main thread started.\\n\"); k_work_init(&my_work, work_handler); and later submit it to the system workqueue: k_work_submit(&my_work);","title":"3. Initialize and Submit the Work Item"},{"location":"os-03-semaphore-mutex/","text":"OS 03: Semaphores and Mutexes Author: Tony Fu Date: 2025/05/11 Device: nRF52840 DK Toolchain: nRF Connect SDK v3.0.0 Every RTOS has its own implementation of semaphores and mutexes. While the core concepts are similar, the details can vary, so pay close attention to the specifics described here: Semaphores Used to control access to a shared resource by limiting how many threads can access it simultaneously. It can also be used for event signaling between threads. Semaphores typically start with a non-zero initial count, indicating how many threads can acquire the semaphore without blocking. Semaphores are not \"owned\" by any thread; ownership does not apply, and therefore priority inheritance is not supported . A semaphore is given (i.e., its count is incremented) using k_sem_give() . This operation is safe to call from ISRs , but it has no effect if the count is already at its configured maximum. A semaphore is taken (i.e., its count is decremented) using k_sem_take() . If the count is zero, the calling thread blocks until the semaphore is available (unless a timeout is specified). Blocking take is not allowed from ISRs . Mutexes Used to ensure mutual exclusion in critical sections, allowing only one thread at a time to access a protected resource. A mutex is owned by the thread that successfully locks it. Only the owning thread can unlock it. Priority inheritance is supported: if a lower-priority thread holds a mutex and a higher-priority thread attempts to acquire it, the lower-priority thread temporarily inherits the higher priority. This mechanism reduces the risk of priority inversion , where a low-priority thread blocks high-priority ones by holding a shared resource. A mutex has two states: locked and unlocked . It is always initially unlocked. Zephyr\u2019s mutexes support recursive locking , meaning the owning thread can lock the mutex multiple times. The mutex is only released when it is unlocked the same number of times it was locked. Mutexes cannot be used in ISRs , because mutex logic depends on thread scheduling and priority handling, which are not meaningful in interrupt context. Synchronization vs. Data Sharing Semaphores and mutexes are used primarily for synchronization \u2014 not data passing, which typically uses queues. We will cover different types of queues in a later note. In Action: Semaphore In this example, we define two semaphore threads: one continuously waits for a signal ( sem_receiver_thread ), and the other periodically sends that signal ( sem_sender_thread ). Step 1: Project Configuration Although this config is usually enabled by default, for clarity, we explicitly enable multithreading support in prj.conf : CONFIG_MULTITHREADING=y Step 2: Semaphore Definition In src/main.c , we define a semaphore with an initial count of 0, meaning it starts in a state where no threads can take it until it is given. We have also set the maximum count to 1, which is a common practice for semaphores used for signaling. K_SEM_DEFINE(sync_sem, 0, 1); Step 3: Semaphore Threads We define two threads: sem_receiver_thread and sem_sender_thread . The receiver thread waits for the semaphore to be given, while the sender thread periodically gives the semaphore. // Thread A: waits for a signal void sem_receiver_thread(void) { while (1) { printk(\"[Semaphore] Receiver: waiting for signal...\\n\"); k_sem_take(&sync_sem, K_FOREVER); printk(\"[Semaphore] Receiver: got the signal!\\n\"); k_sleep(K_MSEC(1000)); } } // Thread B: sends a signal void sem_sender_thread(void) { while (1) { k_sleep(K_MSEC(2000)); printk(\"[Semaphore] Sender: sending signal...\\n\"); k_sem_give(&sync_sem); } } K_THREAD_DEFINE(sem_recv_id, STACK_SIZE, sem_receiver_thread, NULL, NULL, NULL, SEM_THREAD_PRIORITY, 0, 0); K_THREAD_DEFINE(sem_send_id, STACK_SIZE, sem_sender_thread, NULL, NULL, NULL, SEM_THREAD_PRIORITY, 0, 0); Results When you run the program, you should see the receiver thread waiting for a signal, and every two seconds, the sender thread sends a signal. The receiver thread then prints that it received the signal and sleeps for one second before waiting for the next signal. [Semaphore] Sender: sending signal... [Semaphore] Receiver: got the signal! In Action: Mutex In this example, we create two mutex threads ( mutex_worker_thread_1 and _2 ) safely increment a shared counter using a mutex ( counter_mutex ) to avoid race conditions. The counter resets after reaching a limit of 100, and each thread prints its activity. Step 1: Project Configuration Just like with semaphores, we ensure multithreading support is enabled in prj.conf . Step 2: Mutex Definition In src/main.c , we define a mutex for protecting access to the shared counter: K_MUTEX_DEFINE(counter_mutex); Step 3: Create a Shared Function We will create a function safe_increment() that safely increments the shared counter using the mutex. This function will be called by both threads. int shared_counter = 0; const int counter_limit = 100; void safe_increment(void) { k_mutex_lock(&counter_mutex, K_FOREVER); shared_counter++; if (shared_counter > counter_limit) { shared_counter = 0; } printk(\"[Mutex] Thread %p: counter = %d\\n\", k_current_get(), shared_counter); k_mutex_unlock(&counter_mutex); } Step 4: Mutex Threads We define two threads that will call safe_increment() to increment the shared counter. void mutex_worker_thread_1(void) { while (1) { safe_increment(); k_sleep(K_MSEC(500)); } } void mutex_worker_thread_2(void) { while (1) { safe_increment(); k_sleep(K_MSEC(700)); } } K_THREAD_DEFINE(mutex_thread1_id, STACK_SIZE, mutex_worker_thread_1, NULL, NULL, NULL, MUTEX_THREAD_PRIORITY, 0, 0); K_THREAD_DEFINE(mutex_thread2_id, STACK_SIZE, mutex_worker_thread_2, NULL, NULL, NULL, MUTEX_THREAD_PRIORITY, 0, 0); Results When you run the program, both threads will increment the shared counter safely using the mutex. The output will show the counter value being incremented by each thread, demonstrating that the mutex prevents the counter from being updated simultaneously by both threads: [Mutex] Thread 0x20000660: counter = 92 [Mutex] Thread 0x200006e0: counter = 93 [Mutex] Thread 0x20000660: counter = 94 [Mutex] Thread 0x200006e0: counter = 95 [Mutex] Thread 0x20000660: counter = 96 [Mutex] Thread 0x200006e0: counter = 97 [Mutex] Thread 0x200006e0: counter = 98 [Mutex] Thread 0x20000660: counter = 99 [Mutex] Thread 0x200006e0: counter = 100 [Mutex] Thread 0x20000660: counter = 0 [Mutex] Thread 0x200006e0: counter = 1 [Mutex] Thread 0x20000660: counter = 2 [Mutex] Thread 0x200006e0: counter = 3","title":"OS-Semaphore & Mutex"},{"location":"os-03-semaphore-mutex/#os-03-semaphores-and-mutexes","text":"Author: Tony Fu Date: 2025/05/11 Device: nRF52840 DK Toolchain: nRF Connect SDK v3.0.0 Every RTOS has its own implementation of semaphores and mutexes. While the core concepts are similar, the details can vary, so pay close attention to the specifics described here:","title":"OS 03: Semaphores and Mutexes"},{"location":"os-03-semaphore-mutex/#semaphores","text":"Used to control access to a shared resource by limiting how many threads can access it simultaneously. It can also be used for event signaling between threads. Semaphores typically start with a non-zero initial count, indicating how many threads can acquire the semaphore without blocking. Semaphores are not \"owned\" by any thread; ownership does not apply, and therefore priority inheritance is not supported . A semaphore is given (i.e., its count is incremented) using k_sem_give() . This operation is safe to call from ISRs , but it has no effect if the count is already at its configured maximum. A semaphore is taken (i.e., its count is decremented) using k_sem_take() . If the count is zero, the calling thread blocks until the semaphore is available (unless a timeout is specified). Blocking take is not allowed from ISRs .","title":"Semaphores"},{"location":"os-03-semaphore-mutex/#mutexes","text":"Used to ensure mutual exclusion in critical sections, allowing only one thread at a time to access a protected resource. A mutex is owned by the thread that successfully locks it. Only the owning thread can unlock it. Priority inheritance is supported: if a lower-priority thread holds a mutex and a higher-priority thread attempts to acquire it, the lower-priority thread temporarily inherits the higher priority. This mechanism reduces the risk of priority inversion , where a low-priority thread blocks high-priority ones by holding a shared resource. A mutex has two states: locked and unlocked . It is always initially unlocked. Zephyr\u2019s mutexes support recursive locking , meaning the owning thread can lock the mutex multiple times. The mutex is only released when it is unlocked the same number of times it was locked. Mutexes cannot be used in ISRs , because mutex logic depends on thread scheduling and priority handling, which are not meaningful in interrupt context.","title":"Mutexes"},{"location":"os-03-semaphore-mutex/#synchronization-vs-data-sharing","text":"Semaphores and mutexes are used primarily for synchronization \u2014 not data passing, which typically uses queues. We will cover different types of queues in a later note.","title":"Synchronization vs. Data Sharing"},{"location":"os-03-semaphore-mutex/#in-action-semaphore","text":"In this example, we define two semaphore threads: one continuously waits for a signal ( sem_receiver_thread ), and the other periodically sends that signal ( sem_sender_thread ).","title":"In Action: Semaphore"},{"location":"os-03-semaphore-mutex/#step-1-project-configuration","text":"Although this config is usually enabled by default, for clarity, we explicitly enable multithreading support in prj.conf : CONFIG_MULTITHREADING=y","title":"Step 1: Project Configuration"},{"location":"os-03-semaphore-mutex/#step-2-semaphore-definition","text":"In src/main.c , we define a semaphore with an initial count of 0, meaning it starts in a state where no threads can take it until it is given. We have also set the maximum count to 1, which is a common practice for semaphores used for signaling. K_SEM_DEFINE(sync_sem, 0, 1);","title":"Step 2: Semaphore Definition"},{"location":"os-03-semaphore-mutex/#step-3-semaphore-threads","text":"We define two threads: sem_receiver_thread and sem_sender_thread . The receiver thread waits for the semaphore to be given, while the sender thread periodically gives the semaphore. // Thread A: waits for a signal void sem_receiver_thread(void) { while (1) { printk(\"[Semaphore] Receiver: waiting for signal...\\n\"); k_sem_take(&sync_sem, K_FOREVER); printk(\"[Semaphore] Receiver: got the signal!\\n\"); k_sleep(K_MSEC(1000)); } } // Thread B: sends a signal void sem_sender_thread(void) { while (1) { k_sleep(K_MSEC(2000)); printk(\"[Semaphore] Sender: sending signal...\\n\"); k_sem_give(&sync_sem); } } K_THREAD_DEFINE(sem_recv_id, STACK_SIZE, sem_receiver_thread, NULL, NULL, NULL, SEM_THREAD_PRIORITY, 0, 0); K_THREAD_DEFINE(sem_send_id, STACK_SIZE, sem_sender_thread, NULL, NULL, NULL, SEM_THREAD_PRIORITY, 0, 0);","title":"Step 3: Semaphore Threads"},{"location":"os-03-semaphore-mutex/#results","text":"When you run the program, you should see the receiver thread waiting for a signal, and every two seconds, the sender thread sends a signal. The receiver thread then prints that it received the signal and sleeps for one second before waiting for the next signal. [Semaphore] Sender: sending signal... [Semaphore] Receiver: got the signal!","title":"Results"},{"location":"os-03-semaphore-mutex/#in-action-mutex","text":"In this example, we create two mutex threads ( mutex_worker_thread_1 and _2 ) safely increment a shared counter using a mutex ( counter_mutex ) to avoid race conditions. The counter resets after reaching a limit of 100, and each thread prints its activity.","title":"In Action: Mutex"},{"location":"os-03-semaphore-mutex/#step-1-project-configuration_1","text":"Just like with semaphores, we ensure multithreading support is enabled in prj.conf .","title":"Step 1: Project Configuration"},{"location":"os-03-semaphore-mutex/#step-2-mutex-definition","text":"In src/main.c , we define a mutex for protecting access to the shared counter: K_MUTEX_DEFINE(counter_mutex);","title":"Step 2: Mutex Definition"},{"location":"os-03-semaphore-mutex/#step-3-create-a-shared-function","text":"We will create a function safe_increment() that safely increments the shared counter using the mutex. This function will be called by both threads. int shared_counter = 0; const int counter_limit = 100; void safe_increment(void) { k_mutex_lock(&counter_mutex, K_FOREVER); shared_counter++; if (shared_counter > counter_limit) { shared_counter = 0; } printk(\"[Mutex] Thread %p: counter = %d\\n\", k_current_get(), shared_counter); k_mutex_unlock(&counter_mutex); }","title":"Step 3: Create a Shared Function"},{"location":"os-03-semaphore-mutex/#step-4-mutex-threads","text":"We define two threads that will call safe_increment() to increment the shared counter. void mutex_worker_thread_1(void) { while (1) { safe_increment(); k_sleep(K_MSEC(500)); } } void mutex_worker_thread_2(void) { while (1) { safe_increment(); k_sleep(K_MSEC(700)); } } K_THREAD_DEFINE(mutex_thread1_id, STACK_SIZE, mutex_worker_thread_1, NULL, NULL, NULL, MUTEX_THREAD_PRIORITY, 0, 0); K_THREAD_DEFINE(mutex_thread2_id, STACK_SIZE, mutex_worker_thread_2, NULL, NULL, NULL, MUTEX_THREAD_PRIORITY, 0, 0);","title":"Step 4: Mutex Threads"},{"location":"os-03-semaphore-mutex/#results_1","text":"When you run the program, both threads will increment the shared counter safely using the mutex. The output will show the counter value being incremented by each thread, demonstrating that the mutex prevents the counter from being updated simultaneously by both threads: [Mutex] Thread 0x20000660: counter = 92 [Mutex] Thread 0x200006e0: counter = 93 [Mutex] Thread 0x20000660: counter = 94 [Mutex] Thread 0x200006e0: counter = 95 [Mutex] Thread 0x20000660: counter = 96 [Mutex] Thread 0x200006e0: counter = 97 [Mutex] Thread 0x200006e0: counter = 98 [Mutex] Thread 0x20000660: counter = 99 [Mutex] Thread 0x200006e0: counter = 100 [Mutex] Thread 0x20000660: counter = 0 [Mutex] Thread 0x200006e0: counter = 1 [Mutex] Thread 0x20000660: counter = 2 [Mutex] Thread 0x200006e0: counter = 3","title":"Results"},{"location":"sdk-01-uart/","text":"SDK 01: UART Author: Tony Fu Date: 2025/05/10 Device: nRF52840 DK Toolchain: nRF Connect SDK v3.0.0 Comparing UART Access Methods in Zephyr Method How it Works Pros Cons Polling Your code checks the UART constantly (read/write one byte at a time). Simple to implement Wastes CPU time, blocks other tasks Interrupt-driven UART generates interrupts on TX/RX; you write ISR handlers to manage buffers. Non-blocking, better performance Requires careful buffer and state handling Asynchronous Built on top of interrupt-driven, but uses EasyDMA and high-level events. Most efficient, background transfer More complex API We will use the asynchronous method in this example. What's the Difference Between Interrupt-Driven and Asynchronous? Interrupt-driven API gives you manual control : you handle each byte in your own interrupt handlers (ISR). You must manually manage data queues or FIFOs. Asynchronous API is higher-level : it uses interrupts under the hood but gives you events like \"RX buffer ready\" or \"TX done\". It also uses EasyDMA , which lets the UART peripheral send/receive data directly to/from memory without CPU involvement. In Action In thie example, we will use asynchronous UART to commucate our nRF52840 DK with a PC. We have the option to send three commands from our PC terminal to the nRF52840 DK: hello : The nRF52840 DK will respond with \"Hello, world!\" add : The nRF52840 DK will respond with the sum of the two numbers. reboot : The nRF52840 DK will reboot. Typically, we will not use the UART directly. Instead we will use the LOG module or the CONSOLE module if we want to use the UART as a console. Step 1: Configuration Edit the prj.conf file: CONFIG_GPIO=y CONFIG_SERIAL=y CONFIG_UART_ASYNC_API=y CONFIG_REBOOT=y The first 3 options are required for the UART driver. The last option is required for the reboot command. Step 2: Handle UART Events We shall define a function with the following signature: #include <zephyr/drivers/uart.h> static void uart_cb(const struct device *dev, struct uart_event *evt, void *user_data) { switch (evt->type) { case UART_TX_DONE: // Occurs when the entire TX buffer has been sent. // Typically used to clear a busy flag or start the next TX. break; case UART_TX_ABORTED: // Occurs if an ongoing TX was canceled. // Typically used to handle errors or retry sending. break; case UART_RX_RDY: // <-- This is the event we will use // Called when new data is received in the RX buffer. // Typically used to read incoming bytes and process input. break; case UART_RX_BUF_REQUEST: // UART driver asks for a new RX buffer when using double-buffering. // Typically used to provide another buffer with uart_rx_buf_rsp(). break; case UART_RX_BUF_RELEASED: // Indicates a previously used RX buffer can now be reused or freed. // Typically used to manage memory (e.g., recycle buffers). break; case UART_RX_DISABLED: // <-- This is the event we will use // RX has been disabled, either intentionally or after an error. // Typically used to re-enable RX with uart_rx_enable(). break; case UART_RX_STOPPED: // RX stopped due to a hardware error. // Typically used to report the error or reset the interface. break; default: break; } } In our example, we will only use the UART_RX_RDY and UART_RX_DISABLED events. The UART_RX_RDY event is triggered when new data is received in the RX buffer. The UART_RX_DISABLED event is triggered at startup when our app calls uart_rx_enable() for the first time during main() , as Zephyr\u2019s UART driver may internally transition through a disabled state. Later on in main() , we will call uart_callback_set() to set the callback function. More on this later. Step 3: Create a uart_tx wrapper I noticed that if I call the uart_tx() function back to back without any delay between them to send the data, the second call will cause the whole program to hang. Therefore, we need to create a wrapper function to defer each call to uart_tx() . We will do this with a message queue and a delayed work item. Briefly, we will create a queue to hold the data to be sent, and then create a delayed work item to send the data in the queue. This also allows us to send data in a non-blocking way and add a delay between each call to uart_tx() . Overall, it is a good practice to defer I/O operations in the UART callback function, as it is basically an interrupt handler. We will start by defining a message queue and a delayed work item. The message queue will hold the data to be sent, and the delayed work item will send the data in the queue. #define PRINT_MSG_SIZE 128 #define PRINT_QUEUE_SIZE 8 K_MSGQ_DEFINE(print_msgq, PRINT_MSG_SIZE, PRINT_QUEUE_SIZE, 4); static struct k_work_delayable print_work; static void print_work_handler(struct k_work *work) { char msg[PRINT_MSG_SIZE]; while (k_msgq_get(&print_msgq, msg, K_NO_WAIT) == 0) { uart_tx(uart, (const uint8_t *)msg, strlen(msg), 100); k_msleep(2); } } Remember to initialize the work item in main() : k_work_init_delayable(&print_work, print_work_handler); Then, we can create our own print() function to send data to the UART. This function will add the data to the message queue and start the delayed work item. static void print(const char *str) { if (strlen(str) >= PRINT_MSG_SIZE) return; char tmp[PRINT_MSG_SIZE]; strcpy(tmp, str); k_msgq_put(&print_msgq, tmp, K_NO_WAIT); k_work_schedule(&print_work, K_MSEC(1)); } Step 4: Parse Commands We need to revisit our uart_cb() function to parse the commands. It contains a input parameter struct uart_event *evt , which contains the data received from the UART. Here are some important fields in the struct uart_event : evt->data.rx.len : The length of the data received. evt->data.rx.offset : The offset of the data received. So to read the data received, we need to iterate through the data from evt->rx.buf[rx.offset] to evt->rx.buf[rx.offset+rx.len] . In our case, since our receive buffer is 1 byte long, we can just read the first byte. Depending on the command received, we will call the appropriate function to handle the command. static uint8_t rx_buf[1]; #define CMD_BUF_SIZE 128 static char cmd_buf[CMD_BUF_SIZE]; static size_t cmd_len = 0; #define PROMPT \"> \" static void uart_cb(const struct device *dev, struct uart_event *evt, void *user_data) { ARG_UNUSED(dev); ARG_UNUSED(user_data); switch (evt->type) { case UART_RX_RDY: char c = evt->data.rx.buf[evt->data.rx.offset]; if (c == '\\r' || c == '\\n') // Enter key pressed { cmd_buf[cmd_len] = '\\0'; process_command(cmd_buf); cmd_len = 0; print(PROMPT); } else if (c == '\\b' || c == 127) // Backspace key pressed { if (cmd_len > 0) { cmd_len--; print(\"\\b \\b\"); } } else if (isprint((unsigned char)c) && cmd_len < CMD_BUF_SIZE - 1) // Printable character { cmd_buf[cmd_len++] = c; char echo[2] = {c, '\\0'}; print(echo); } break; case UART_RX_DISABLED: uart_rx_enable(dev, rx_buf, sizeof(rx_buf), 100); // 100 ms timeout break; default: break; } } Note that we also handle the UART_RX_DISABLED event to re-enable the RX buffer. This is important because the RX buffer is disabled after the first call to uart_rx_enable() . We will also need to define a rx_buf variable to hold the data received from the UART. Step 5: Process Commands This is just a simple command processor. Not really relavent to the teaching UART, so I will not go into details. static void process_command(const char *cmd) { if (strncmp(cmd, \"hello\", 5) == 0) { print(\"\\r\\nHello, world!\\r\\n\"); } else if (strncmp(cmd, \"add \", 4) == 0) { char cmd_copy[CMD_BUF_SIZE]; strncpy(cmd_copy, cmd, CMD_BUF_SIZE); cmd_copy[CMD_BUF_SIZE - 1] = '\\0'; char *arg1 = NULL, *arg2 = NULL, *rest = NULL; arg1 = strtok_r(cmd_copy + 4, \" \", &rest); arg2 = strtok_r(NULL, \" \", &rest); if (arg1 && arg2) { int a = strtol(arg1, NULL, 10); int b = strtol(arg2, NULL, 10); char result[32]; snprintf(result, sizeof(result), \"\\r\\n%d\\r\\n\", a + b); print(result); } else { print(\"Error: usage is add <num1> <num2>\\r\\n\"); } } else if (strncmp(cmd, \"reboot\", 6) == 0) { k_sleep(K_MSEC(100)); sys_reboot(SYS_REBOOT_COLD); } else { print(\"Unknown command\\r\\n\"); } } Step 6: Main Function Finally, we need to initialize the UART and start the RX buffer. We will also set the callback function for the UART events. static const struct device *uart; int main(void) { k_work_init_delayable(&print_work, print_work_handler); uart = DEVICE_DT_GET(DT_NODELABEL(uart0)); if (!device_is_ready(uart)) return 0; uart_callback_set(uart, uart_cb, NULL); uart_rx_enable(uart, rx_buf, sizeof(rx_buf), 100); print(\"UART CLI Ready\\r\\n\"); print(PROMPT); while (1) { k_sleep(K_FOREVER); } }","title":"SDK-UART"},{"location":"sdk-01-uart/#sdk-01-uart","text":"Author: Tony Fu Date: 2025/05/10 Device: nRF52840 DK Toolchain: nRF Connect SDK v3.0.0","title":"SDK 01: UART"},{"location":"sdk-01-uart/#comparing-uart-access-methods-in-zephyr","text":"Method How it Works Pros Cons Polling Your code checks the UART constantly (read/write one byte at a time). Simple to implement Wastes CPU time, blocks other tasks Interrupt-driven UART generates interrupts on TX/RX; you write ISR handlers to manage buffers. Non-blocking, better performance Requires careful buffer and state handling Asynchronous Built on top of interrupt-driven, but uses EasyDMA and high-level events. Most efficient, background transfer More complex API We will use the asynchronous method in this example.","title":"Comparing UART Access Methods in Zephyr"},{"location":"sdk-01-uart/#whats-the-difference-between-interrupt-driven-and-asynchronous","text":"Interrupt-driven API gives you manual control : you handle each byte in your own interrupt handlers (ISR). You must manually manage data queues or FIFOs. Asynchronous API is higher-level : it uses interrupts under the hood but gives you events like \"RX buffer ready\" or \"TX done\". It also uses EasyDMA , which lets the UART peripheral send/receive data directly to/from memory without CPU involvement.","title":"What's the Difference Between Interrupt-Driven and Asynchronous?"},{"location":"sdk-01-uart/#in-action","text":"In thie example, we will use asynchronous UART to commucate our nRF52840 DK with a PC. We have the option to send three commands from our PC terminal to the nRF52840 DK: hello : The nRF52840 DK will respond with \"Hello, world!\" add : The nRF52840 DK will respond with the sum of the two numbers. reboot : The nRF52840 DK will reboot. Typically, we will not use the UART directly. Instead we will use the LOG module or the CONSOLE module if we want to use the UART as a console.","title":"In Action"},{"location":"sdk-01-uart/#step-1-configuration","text":"Edit the prj.conf file: CONFIG_GPIO=y CONFIG_SERIAL=y CONFIG_UART_ASYNC_API=y CONFIG_REBOOT=y The first 3 options are required for the UART driver. The last option is required for the reboot command.","title":"Step 1: Configuration"},{"location":"sdk-01-uart/#step-2-handle-uart-events","text":"We shall define a function with the following signature: #include <zephyr/drivers/uart.h> static void uart_cb(const struct device *dev, struct uart_event *evt, void *user_data) { switch (evt->type) { case UART_TX_DONE: // Occurs when the entire TX buffer has been sent. // Typically used to clear a busy flag or start the next TX. break; case UART_TX_ABORTED: // Occurs if an ongoing TX was canceled. // Typically used to handle errors or retry sending. break; case UART_RX_RDY: // <-- This is the event we will use // Called when new data is received in the RX buffer. // Typically used to read incoming bytes and process input. break; case UART_RX_BUF_REQUEST: // UART driver asks for a new RX buffer when using double-buffering. // Typically used to provide another buffer with uart_rx_buf_rsp(). break; case UART_RX_BUF_RELEASED: // Indicates a previously used RX buffer can now be reused or freed. // Typically used to manage memory (e.g., recycle buffers). break; case UART_RX_DISABLED: // <-- This is the event we will use // RX has been disabled, either intentionally or after an error. // Typically used to re-enable RX with uart_rx_enable(). break; case UART_RX_STOPPED: // RX stopped due to a hardware error. // Typically used to report the error or reset the interface. break; default: break; } } In our example, we will only use the UART_RX_RDY and UART_RX_DISABLED events. The UART_RX_RDY event is triggered when new data is received in the RX buffer. The UART_RX_DISABLED event is triggered at startup when our app calls uart_rx_enable() for the first time during main() , as Zephyr\u2019s UART driver may internally transition through a disabled state. Later on in main() , we will call uart_callback_set() to set the callback function. More on this later.","title":"Step 2: Handle UART Events"},{"location":"sdk-01-uart/#step-3-create-a-uart_tx-wrapper","text":"I noticed that if I call the uart_tx() function back to back without any delay between them to send the data, the second call will cause the whole program to hang. Therefore, we need to create a wrapper function to defer each call to uart_tx() . We will do this with a message queue and a delayed work item. Briefly, we will create a queue to hold the data to be sent, and then create a delayed work item to send the data in the queue. This also allows us to send data in a non-blocking way and add a delay between each call to uart_tx() . Overall, it is a good practice to defer I/O operations in the UART callback function, as it is basically an interrupt handler. We will start by defining a message queue and a delayed work item. The message queue will hold the data to be sent, and the delayed work item will send the data in the queue. #define PRINT_MSG_SIZE 128 #define PRINT_QUEUE_SIZE 8 K_MSGQ_DEFINE(print_msgq, PRINT_MSG_SIZE, PRINT_QUEUE_SIZE, 4); static struct k_work_delayable print_work; static void print_work_handler(struct k_work *work) { char msg[PRINT_MSG_SIZE]; while (k_msgq_get(&print_msgq, msg, K_NO_WAIT) == 0) { uart_tx(uart, (const uint8_t *)msg, strlen(msg), 100); k_msleep(2); } } Remember to initialize the work item in main() : k_work_init_delayable(&print_work, print_work_handler); Then, we can create our own print() function to send data to the UART. This function will add the data to the message queue and start the delayed work item. static void print(const char *str) { if (strlen(str) >= PRINT_MSG_SIZE) return; char tmp[PRINT_MSG_SIZE]; strcpy(tmp, str); k_msgq_put(&print_msgq, tmp, K_NO_WAIT); k_work_schedule(&print_work, K_MSEC(1)); }","title":"Step 3: Create a uart_tx wrapper"},{"location":"sdk-01-uart/#step-4-parse-commands","text":"We need to revisit our uart_cb() function to parse the commands. It contains a input parameter struct uart_event *evt , which contains the data received from the UART. Here are some important fields in the struct uart_event : evt->data.rx.len : The length of the data received. evt->data.rx.offset : The offset of the data received. So to read the data received, we need to iterate through the data from evt->rx.buf[rx.offset] to evt->rx.buf[rx.offset+rx.len] . In our case, since our receive buffer is 1 byte long, we can just read the first byte. Depending on the command received, we will call the appropriate function to handle the command. static uint8_t rx_buf[1]; #define CMD_BUF_SIZE 128 static char cmd_buf[CMD_BUF_SIZE]; static size_t cmd_len = 0; #define PROMPT \"> \" static void uart_cb(const struct device *dev, struct uart_event *evt, void *user_data) { ARG_UNUSED(dev); ARG_UNUSED(user_data); switch (evt->type) { case UART_RX_RDY: char c = evt->data.rx.buf[evt->data.rx.offset]; if (c == '\\r' || c == '\\n') // Enter key pressed { cmd_buf[cmd_len] = '\\0'; process_command(cmd_buf); cmd_len = 0; print(PROMPT); } else if (c == '\\b' || c == 127) // Backspace key pressed { if (cmd_len > 0) { cmd_len--; print(\"\\b \\b\"); } } else if (isprint((unsigned char)c) && cmd_len < CMD_BUF_SIZE - 1) // Printable character { cmd_buf[cmd_len++] = c; char echo[2] = {c, '\\0'}; print(echo); } break; case UART_RX_DISABLED: uart_rx_enable(dev, rx_buf, sizeof(rx_buf), 100); // 100 ms timeout break; default: break; } } Note that we also handle the UART_RX_DISABLED event to re-enable the RX buffer. This is important because the RX buffer is disabled after the first call to uart_rx_enable() . We will also need to define a rx_buf variable to hold the data received from the UART.","title":"Step 4: Parse Commands"},{"location":"sdk-01-uart/#step-5-process-commands","text":"This is just a simple command processor. Not really relavent to the teaching UART, so I will not go into details. static void process_command(const char *cmd) { if (strncmp(cmd, \"hello\", 5) == 0) { print(\"\\r\\nHello, world!\\r\\n\"); } else if (strncmp(cmd, \"add \", 4) == 0) { char cmd_copy[CMD_BUF_SIZE]; strncpy(cmd_copy, cmd, CMD_BUF_SIZE); cmd_copy[CMD_BUF_SIZE - 1] = '\\0'; char *arg1 = NULL, *arg2 = NULL, *rest = NULL; arg1 = strtok_r(cmd_copy + 4, \" \", &rest); arg2 = strtok_r(NULL, \" \", &rest); if (arg1 && arg2) { int a = strtol(arg1, NULL, 10); int b = strtol(arg2, NULL, 10); char result[32]; snprintf(result, sizeof(result), \"\\r\\n%d\\r\\n\", a + b); print(result); } else { print(\"Error: usage is add <num1> <num2>\\r\\n\"); } } else if (strncmp(cmd, \"reboot\", 6) == 0) { k_sleep(K_MSEC(100)); sys_reboot(SYS_REBOOT_COLD); } else { print(\"Unknown command\\r\\n\"); } }","title":"Step 5: Process Commands"},{"location":"sdk-01-uart/#step-6-main-function","text":"Finally, we need to initialize the UART and start the RX buffer. We will also set the callback function for the UART events. static const struct device *uart; int main(void) { k_work_init_delayable(&print_work, print_work_handler); uart = DEVICE_DT_GET(DT_NODELABEL(uart0)); if (!device_is_ready(uart)) return 0; uart_callback_set(uart, uart_cb, NULL); uart_rx_enable(uart, rx_buf, sizeof(rx_buf), 100); print(\"UART CLI Ready\\r\\n\"); print(PROMPT); while (1) { k_sleep(K_FOREVER); } }","title":"Step 6: Main Function"},{"location":"sdk-02-debugging/","text":"SDK 02: Debugging Tips Author: Tony Fu Date: 2025/05/24 Device: nRF52840 DK Toolchain: nRF Connect SDK v3.0.0 I recommend watching this video for a quick overview of debugging in the SDK. In Action We are doing to use part of the code from the OS-03: Semaphores and Mutexes example. This code has two threads that increment a counter with mutex protection. The code is as follows. Step 1: Enable Debugging We need to enable debugging in the prj.conf file. Add the following lines to enable debugging features: CONFIG_DEBUG_THREAD_INFO=y CONFIG_DEBUG_OPTIMIZATIONS=y Then, when setting up the build configuration in VSCode, make sure to select Optimize for debugging (-Og) as the optimization level. This will ensure that the code is compiled with debugging information. Step 2: Set Breakpoints In VSCode, you can set breakpoints by clicking on the left margin next to the line numbers in your source code. For example, set a breakpoint at the line where the counter is incremented: // Shared function to safely update and print the counter void safe_increment(void) { k_mutex_lock(&counter_mutex, K_FOREVER); shared_counter++; // <- set breakpoint here if (shared_counter > counter_limit) { shared_counter = 0; } printk(\"[Mutex] Thread %p: counter = %d\\n\", k_current_get(), shared_counter); k_mutex_unlock(&counter_mutex); } There are also conditional breakpoints available in VSCode, but I could not get it to work properly. Step 3: Add Variables to Watch You can add variables to the watch list in VSCode to monitor their values during debugging. Right-click on the variable you want to watch (e.g., shared_counter ) and select \"Add to Watch\". This will allow you to see the value of shared_counter as you step through the code. Step 4: Start Debugging To start debugging, click on the \"Run and Debug\" icon in the left sidebar of VSCode. Then click on the \"Continue\" button to start the debugging session. The program will run until it hits the breakpoint you set earlier. You can check the value of shared_counter in the watch list and step through the code using the debugging controls. Step 5: Play with the Thread Viewer You can also use the Thread Viewer in VSCode to see the state of all threads. Click on the \"NRF DEBUG\" tab next to the terminal tab. This will show you a list of all threads, their states, and the current thread's stack trace. You can click on a thread to see its details and stack trace. Step 6: Manually Toggle LEDs The nRF52840 DK has four LEDs that you can manually toggle the GPIO pins to turn on/off the LEDs. Go to \"Peripherals\" in the left sidebar of VSCode. Click on \"GPIO\" to open the GPIO view. On the nRF52840 DK, the four green LEDs are connected to GPIO P0 pins 13, 14, 15, and 16. Click on the \"DIR\" menu to set the direction of the GPIO pins to \"Output\". The LEDs are active low, so to turn on an LED, you need to set the GPIO pin to low (0). To turn off an LED, set the GPIO pin to high (1). Usually, they are already set to low by default, so the previous step should have already turned on the LEDs.","title":"SDK-Debugging"},{"location":"sdk-02-debugging/#sdk-02-debugging-tips","text":"Author: Tony Fu Date: 2025/05/24 Device: nRF52840 DK Toolchain: nRF Connect SDK v3.0.0 I recommend watching this video for a quick overview of debugging in the SDK.","title":"SDK 02: Debugging Tips"},{"location":"sdk-02-debugging/#in-action","text":"We are doing to use part of the code from the OS-03: Semaphores and Mutexes example. This code has two threads that increment a counter with mutex protection. The code is as follows.","title":"In Action"},{"location":"sdk-02-debugging/#step-1-enable-debugging","text":"We need to enable debugging in the prj.conf file. Add the following lines to enable debugging features: CONFIG_DEBUG_THREAD_INFO=y CONFIG_DEBUG_OPTIMIZATIONS=y Then, when setting up the build configuration in VSCode, make sure to select Optimize for debugging (-Og) as the optimization level. This will ensure that the code is compiled with debugging information.","title":"Step 1: Enable Debugging"},{"location":"sdk-02-debugging/#step-2-set-breakpoints","text":"In VSCode, you can set breakpoints by clicking on the left margin next to the line numbers in your source code. For example, set a breakpoint at the line where the counter is incremented: // Shared function to safely update and print the counter void safe_increment(void) { k_mutex_lock(&counter_mutex, K_FOREVER); shared_counter++; // <- set breakpoint here if (shared_counter > counter_limit) { shared_counter = 0; } printk(\"[Mutex] Thread %p: counter = %d\\n\", k_current_get(), shared_counter); k_mutex_unlock(&counter_mutex); } There are also conditional breakpoints available in VSCode, but I could not get it to work properly.","title":"Step 2: Set Breakpoints"},{"location":"sdk-02-debugging/#step-3-add-variables-to-watch","text":"You can add variables to the watch list in VSCode to monitor their values during debugging. Right-click on the variable you want to watch (e.g., shared_counter ) and select \"Add to Watch\". This will allow you to see the value of shared_counter as you step through the code.","title":"Step 3: Add Variables to Watch"},{"location":"sdk-02-debugging/#step-4-start-debugging","text":"To start debugging, click on the \"Run and Debug\" icon in the left sidebar of VSCode. Then click on the \"Continue\" button to start the debugging session. The program will run until it hits the breakpoint you set earlier. You can check the value of shared_counter in the watch list and step through the code using the debugging controls.","title":"Step 4: Start Debugging"},{"location":"sdk-02-debugging/#step-5-play-with-the-thread-viewer","text":"You can also use the Thread Viewer in VSCode to see the state of all threads. Click on the \"NRF DEBUG\" tab next to the terminal tab. This will show you a list of all threads, their states, and the current thread's stack trace. You can click on a thread to see its details and stack trace.","title":"Step 5: Play with the Thread Viewer"},{"location":"sdk-02-debugging/#step-6-manually-toggle-leds","text":"The nRF52840 DK has four LEDs that you can manually toggle the GPIO pins to turn on/off the LEDs. Go to \"Peripherals\" in the left sidebar of VSCode. Click on \"GPIO\" to open the GPIO view. On the nRF52840 DK, the four green LEDs are connected to GPIO P0 pins 13, 14, 15, and 16. Click on the \"DIR\" menu to set the direction of the GPIO pins to \"Output\". The LEDs are active low, so to turn on an LED, you need to set the GPIO pin to low (0). To turn off an LED, set the GPIO pin to high (1). Usually, they are already set to low by default, so the previous step should have already turned on the LEDs.","title":"Step 6: Manually Toggle LEDs"},{"location":"sdk-03-custom-board/","text":"SDK 03: Custom Board Support using VS Code GUI Author: Tony Fu Date: 2025/06/01 Device: nRF52840 DK Toolchain: nRF Connect SDK v3.0.0 We will go over how to create a simple custom board definition for the nRF52840 DK in the nRF Connect SDK using the GUI in VS Code. Then, we will use the board definition to build a simple blinky application to run on nRF52840 DK. Creating Custom Board support using West In Zephyr, a \"board target\" correspond to an image of a specific hardware. I know, it sounds a bit abstract. But here is a breakdown. The name of a board target consists of the following parts: Board Name (Must have) : The name of the board, such as nrf5340dk . Version (Optional) : The version of the board, such as 0.1.0 . SoC (Must have) : The name of the SoC, such as nrf5340 . CPU Cluster (Optional) : The CPU cluster of the SoC, such as cpunet for network processor or cpuapp for application processor. Variant (Optional) : The variant of the board, such as ns for Trusted Firmware-M support. For example, the board target nrf5340dk@0.1.0/nrf5340/cpunet/ns corresponds to the nRF5340 DK board with the nRF5340 SoC, using the network processor cluster, and supporting Trusted Firmware-M. Notice that they are formatted as a path-like structure, which is how the build tool \"west\" organizes board targets. So, to create the above board target in your designated directory where you store all your custom boards, you would create a directory structure like this: west build -b nrf5340dk@0.1.0/nrf5340/cpunet/ns -- -DBOARD_ROOT=C:/nordic/myBoards You need to create all the board targets required by your board, so this mean you need to also call west build for the application processor cluster: west build -b nrf5340dk@0.1.0/nrf5340/cpuapp -- -DBOARD_ROOT=C:/nordic/myBoards This is the traditional way to create a custom board target in Zephyr. However, we will use the GUI in VS Code to make it easier. Creating Custom Board Support using VS Code GUI On the left side of the VS Code, open the \"nRF Connect\" extension view. Then click on \"Create a new board\" button. This will open a window to create a new board target. You will need to fill in the following fields: Board Name : The name of the board, such as my52840dk . Description : A short description of the board. This is usually just the board name formatted in a more human readable way, such as My 52840 DK . Vendor name : The name of the vendor. Since I am an individual hobbyist, I will use my github username tonyfu97 . SoC : This is a dropdown list of all the SoCs supported by the nRF Connect SDK. For our example, select nRF52840-QIAA (same package used in nRF52840). The GUI will automatically create all the required board targets for the SoC. Board root : This is the directory where you want to store your custom board targets. You can use the default value, which is C:/nordic/myBoards in this example. Then click on the \"Create Board\" button. The GUI will create the following directory structure in your designated board root directory: C: \u2514\u2500\u2500\u2500myBoards \u2514\u2500\u2500\u2500tonyfu97 \u2514\u2500\u2500\u2500my52840dk board.cmake board.yml Kconfig.my52840dk my52840dk-pinctrl.dtsi my52840dk.dts my52840dk.yml my52840dk_defconfig pre_dt_board.cmake You can see that the GUI has created all the required files for the board target. We will go over the important files in the next section. Default Configuration File: my52840dk_defconfig This configuration file will be applied to the board target when building the application. However, the configuration in prj.conf will override the configuration in this file. This is useful for setting default configurations for the board target, such as enabling hardware features or disabling unused features. The auto-generated my52840dk_defconfig file already contains the following configuration options: CONFIG_ARM_MPU=y CONFIG_HW_STACK_PROTECTION=y We can foresee the following configurations will be needed for our custom board, so we will append them to the my52840dk_defconfig file: # Enable RTT CONFIG_USE_SEGGER_RTT=y # enable GPIO CONFIG_GPIO=y # enable uart driver CONFIG_SERIAL=y # enable console CONFIG_CONSOLE=y CONFIG_UART_CONSOLE=y Device Tree Source File: my52840dk.dts While the kconfig files handle software configuration, the device tree source (DTS) file describes the hardware layout of the board. This is crucial for Zephyr to understand how to interact with the hardware components. The device tree source file is used to describe the hardware of the board. The GUI has already created a basic device tree source file for us, which includes the following: 1. Header /dts-v1/; #include <nordic/nrf52840_qiaa.dtsi> #include \"my52840dk-pinctrl.dtsi\" Includes common definitions for the nRF52840 QIAA variant. Includes your board-specific pin control configuration. We will go over the pin control file later. 2. Root Node / { model = \"My 52840 DK\"; compatible = \"tonyfu97,my52840dk\"; chosen { zephyr,sram = &sram0; zephyr,flash = &flash0; zephyr,code-partition = &slot0_partition; }; }; Declares board name and unique ID string. chosen tells Zephyr the default hardware configurations. In this case, it specifies the SRAM and flash memory regions, as well as the primary code partition. 3. Flash and Partition Layout &flash0 { partitions { compatible = \"fixed-partitions\"; #address-cells = <1>; #size-cells = <1>; &flash0 refers to the main flash device from the included .dtsi . Defines fixed partitions with absolute addresses and sizes. Partition definitions: boot_partition: partition@0 { label = \"mcuboot\"; reg = <0x00000000 DT_SIZE_K(48)>; }; slot0_partition: partition@c000 { label = \"image-0\"; reg = <0x0000c000 DT_SIZE_K(472)>; }; slot1_partition: partition@82000 { label = \"image-1\"; reg = <0x00082000 DT_SIZE_K(472)>; }; storage_partition: partition@f8000 { label = \"storage\"; reg = <0x000f8000 DT_SIZE_K(32)>; }; mcuboot : reserved for the bootloader. image-0 / image-1 : main and backup firmware images (for DFU). storage : typically used for settings or filesystem. However, this autogenerated DTS file is not sufficient . We have to also specify the peripherals (e.g., GPIO, UART, I2C, SPI, and PWM) and their configuration. First, we need to turn them on outside of the root node. Add this to the end of the DTS file: &gpiote { status = \"okay\"; }; &gpio0 { status = \"okay\"; }; &gpio1 { status = \"okay\"; }; &uart0 { compatible = \"nordic,nrf-uarte\"; status = \"okay\"; current-speed = <115200>; pinctrl-0 = <&uart0_default>; pinctrl-1 = <&uart0_sleep>; pinctrl-names = \"default\", \"sleep\"; }; &i2c0 { compatible = \"nordic,nrf-twi\"; status = \"okay\"; pinctrl-0 = <&i2c0_default>; pinctrl-1 = <&i2c0_sleep>; pinctrl-names = \"default\", \"sleep\"; }; &spi1 { compatible = \"nordic,nrf-spi\"; status = \"okay\"; pinctrl-0 = <&spi1_default>; pinctrl-1 = <&spi1_sleep>; pinctrl-names = \"default\", \"sleep\"; }; &pwm0 { status = \"okay\"; pinctrl-0 = <&pwm0_default>; pinctrl-1 = <&pwm0_sleep>; pinctrl-names = \"default\", \"sleep\"; }; Notice that for the serial protocols (UART, I2C, SPI), we have specified the pin control configurations. These configurations are defined in the my52840dk-pinctrl.dtsi file, which we will go over next. Briefly, it is used to tell which pins are used for which function, such as UART TX/RX, I2C SCL/SDA, SPI MOSI/MISO/SCK, and PWM output. Also, the \"compatible\" property is used to specify the driver for the peripheral. Then, inside of the root node ( / { ... } ), we need to add the following to support the LEDs, buttons, and PWM LEDs. This is done by exposing them using aliases and defining their properties. The following is the complete device tree source file for our custom board: / { model = \"My 52840 DK\"; compatible = \"tonyfu97,my52840dk\"; chosen { zephyr,sram = &sram0; zephyr,flash = &flash0; zephyr,code-partition = &slot0_partition; zephyr,console = &uart0 ; zephyr,shell-uart = &uart0 ; zephyr,uart-mcumgr = &uart0; }; leds { compatible = \"gpio-leds\"; led0: led_0 { gpios = <&gpio0 13 GPIO_ACTIVE_LOW>; label = \"Green LED 0\"; }; led1: led_1 { gpios = <&gpio0 14 GPIO_ACTIVE_LOW>; label = \"Green LED 1\"; }; led2: led_2 { gpios = <&gpio0 15 GPIO_ACTIVE_LOW>; label = \"Green LED 2\"; }; led3: led_3 { gpios = <&gpio0 16 GPIO_ACTIVE_LOW>; label = \"Green LED 3\"; }; }; buttons { compatible = \"gpio-keys\"; button0: button_0 { gpios = <&gpio0 11 (GPIO_PULL_UP | GPIO_ACTIVE_LOW)>; label = \"Push button switch 0\"; zephyr,code = <INPUT_KEY_0>; }; button1: button_1 { gpios = <&gpio0 12 (GPIO_PULL_UP | GPIO_ACTIVE_LOW)>; label = \"Push button switch 1\"; zephyr,code = <INPUT_KEY_1>; }; button2: button_2 { gpios = <&gpio0 24 (GPIO_PULL_UP | GPIO_ACTIVE_LOW)>; label = \"Push button switch 2\"; zephyr,code = <INPUT_KEY_2>; }; button3: button_3 { gpios = <&gpio0 25 (GPIO_PULL_UP | GPIO_ACTIVE_LOW)>; label = \"Push button switch 3\"; zephyr,code = <INPUT_KEY_3>; }; }; pwmleds { compatible = \"pwm-leds\"; pwm_led0: pwm_led_0 { pwms = <&pwm0 0 PWM_MSEC(20) PWM_POLARITY_INVERTED>; }; }; /* These aliases are provided for compatibility with samples */ aliases { led0 = &led0; led1 = &led1; led2 = &led2; led3 = &led3; pwm-led0 = &pwm_led0; sw0 = &button0; sw1 = &button1; sw2 = &button2; sw3 = &button3; bootloader-led0 = &led0; mcuboot-button0 = &button0; mcuboot-led0 = &led0; watchdog0 = &wdt0; }; }; You also need to include the input event codes header file to define the button codes. This is done by adding the following line at the top of the DTS file: #include <zephyr/dt-bindings/input/input-event-codes.h> Pin Control File: my52840dk-pinctrl.dtsi The \"Device Tree Source Include\" (dsti) file is used to define the pin control configurations for the board. This file is included in the main DTS file and contains the pin configurations for the peripherals. The auto-generated my52840dk-pinctrl.dtsi file is almost empty: &pinctrl { };","title":"SDK-Custom Board Support"},{"location":"sdk-03-custom-board/#sdk-03-custom-board-support-using-vs-code-gui","text":"Author: Tony Fu Date: 2025/06/01 Device: nRF52840 DK Toolchain: nRF Connect SDK v3.0.0 We will go over how to create a simple custom board definition for the nRF52840 DK in the nRF Connect SDK using the GUI in VS Code. Then, we will use the board definition to build a simple blinky application to run on nRF52840 DK.","title":"SDK 03: Custom Board Support using VS Code GUI"},{"location":"sdk-03-custom-board/#creating-custom-board-support-using-west","text":"In Zephyr, a \"board target\" correspond to an image of a specific hardware. I know, it sounds a bit abstract. But here is a breakdown. The name of a board target consists of the following parts: Board Name (Must have) : The name of the board, such as nrf5340dk . Version (Optional) : The version of the board, such as 0.1.0 . SoC (Must have) : The name of the SoC, such as nrf5340 . CPU Cluster (Optional) : The CPU cluster of the SoC, such as cpunet for network processor or cpuapp for application processor. Variant (Optional) : The variant of the board, such as ns for Trusted Firmware-M support. For example, the board target nrf5340dk@0.1.0/nrf5340/cpunet/ns corresponds to the nRF5340 DK board with the nRF5340 SoC, using the network processor cluster, and supporting Trusted Firmware-M. Notice that they are formatted as a path-like structure, which is how the build tool \"west\" organizes board targets. So, to create the above board target in your designated directory where you store all your custom boards, you would create a directory structure like this: west build -b nrf5340dk@0.1.0/nrf5340/cpunet/ns -- -DBOARD_ROOT=C:/nordic/myBoards You need to create all the board targets required by your board, so this mean you need to also call west build for the application processor cluster: west build -b nrf5340dk@0.1.0/nrf5340/cpuapp -- -DBOARD_ROOT=C:/nordic/myBoards This is the traditional way to create a custom board target in Zephyr. However, we will use the GUI in VS Code to make it easier.","title":"Creating Custom Board support using West"},{"location":"sdk-03-custom-board/#creating-custom-board-support-using-vs-code-gui","text":"On the left side of the VS Code, open the \"nRF Connect\" extension view. Then click on \"Create a new board\" button. This will open a window to create a new board target. You will need to fill in the following fields: Board Name : The name of the board, such as my52840dk . Description : A short description of the board. This is usually just the board name formatted in a more human readable way, such as My 52840 DK . Vendor name : The name of the vendor. Since I am an individual hobbyist, I will use my github username tonyfu97 . SoC : This is a dropdown list of all the SoCs supported by the nRF Connect SDK. For our example, select nRF52840-QIAA (same package used in nRF52840). The GUI will automatically create all the required board targets for the SoC. Board root : This is the directory where you want to store your custom board targets. You can use the default value, which is C:/nordic/myBoards in this example. Then click on the \"Create Board\" button. The GUI will create the following directory structure in your designated board root directory: C: \u2514\u2500\u2500\u2500myBoards \u2514\u2500\u2500\u2500tonyfu97 \u2514\u2500\u2500\u2500my52840dk board.cmake board.yml Kconfig.my52840dk my52840dk-pinctrl.dtsi my52840dk.dts my52840dk.yml my52840dk_defconfig pre_dt_board.cmake You can see that the GUI has created all the required files for the board target. We will go over the important files in the next section.","title":"Creating Custom Board Support using VS Code GUI"},{"location":"sdk-03-custom-board/#default-configuration-file-my52840dk_defconfig","text":"This configuration file will be applied to the board target when building the application. However, the configuration in prj.conf will override the configuration in this file. This is useful for setting default configurations for the board target, such as enabling hardware features or disabling unused features. The auto-generated my52840dk_defconfig file already contains the following configuration options: CONFIG_ARM_MPU=y CONFIG_HW_STACK_PROTECTION=y We can foresee the following configurations will be needed for our custom board, so we will append them to the my52840dk_defconfig file: # Enable RTT CONFIG_USE_SEGGER_RTT=y # enable GPIO CONFIG_GPIO=y # enable uart driver CONFIG_SERIAL=y # enable console CONFIG_CONSOLE=y CONFIG_UART_CONSOLE=y","title":"Default Configuration File: my52840dk_defconfig"},{"location":"sdk-03-custom-board/#device-tree-source-file-my52840dkdts","text":"While the kconfig files handle software configuration, the device tree source (DTS) file describes the hardware layout of the board. This is crucial for Zephyr to understand how to interact with the hardware components. The device tree source file is used to describe the hardware of the board. The GUI has already created a basic device tree source file for us, which includes the following:","title":"Device Tree Source File: my52840dk.dts"},{"location":"sdk-03-custom-board/#1-header","text":"/dts-v1/; #include <nordic/nrf52840_qiaa.dtsi> #include \"my52840dk-pinctrl.dtsi\" Includes common definitions for the nRF52840 QIAA variant. Includes your board-specific pin control configuration. We will go over the pin control file later.","title":"1. Header"},{"location":"sdk-03-custom-board/#2-root-node","text":"/ { model = \"My 52840 DK\"; compatible = \"tonyfu97,my52840dk\"; chosen { zephyr,sram = &sram0; zephyr,flash = &flash0; zephyr,code-partition = &slot0_partition; }; }; Declares board name and unique ID string. chosen tells Zephyr the default hardware configurations. In this case, it specifies the SRAM and flash memory regions, as well as the primary code partition.","title":"2. Root Node"},{"location":"sdk-03-custom-board/#3-flash-and-partition-layout","text":"&flash0 { partitions { compatible = \"fixed-partitions\"; #address-cells = <1>; #size-cells = <1>; &flash0 refers to the main flash device from the included .dtsi . Defines fixed partitions with absolute addresses and sizes. Partition definitions: boot_partition: partition@0 { label = \"mcuboot\"; reg = <0x00000000 DT_SIZE_K(48)>; }; slot0_partition: partition@c000 { label = \"image-0\"; reg = <0x0000c000 DT_SIZE_K(472)>; }; slot1_partition: partition@82000 { label = \"image-1\"; reg = <0x00082000 DT_SIZE_K(472)>; }; storage_partition: partition@f8000 { label = \"storage\"; reg = <0x000f8000 DT_SIZE_K(32)>; }; mcuboot : reserved for the bootloader. image-0 / image-1 : main and backup firmware images (for DFU). storage : typically used for settings or filesystem. However, this autogenerated DTS file is not sufficient . We have to also specify the peripherals (e.g., GPIO, UART, I2C, SPI, and PWM) and their configuration. First, we need to turn them on outside of the root node. Add this to the end of the DTS file: &gpiote { status = \"okay\"; }; &gpio0 { status = \"okay\"; }; &gpio1 { status = \"okay\"; }; &uart0 { compatible = \"nordic,nrf-uarte\"; status = \"okay\"; current-speed = <115200>; pinctrl-0 = <&uart0_default>; pinctrl-1 = <&uart0_sleep>; pinctrl-names = \"default\", \"sleep\"; }; &i2c0 { compatible = \"nordic,nrf-twi\"; status = \"okay\"; pinctrl-0 = <&i2c0_default>; pinctrl-1 = <&i2c0_sleep>; pinctrl-names = \"default\", \"sleep\"; }; &spi1 { compatible = \"nordic,nrf-spi\"; status = \"okay\"; pinctrl-0 = <&spi1_default>; pinctrl-1 = <&spi1_sleep>; pinctrl-names = \"default\", \"sleep\"; }; &pwm0 { status = \"okay\"; pinctrl-0 = <&pwm0_default>; pinctrl-1 = <&pwm0_sleep>; pinctrl-names = \"default\", \"sleep\"; }; Notice that for the serial protocols (UART, I2C, SPI), we have specified the pin control configurations. These configurations are defined in the my52840dk-pinctrl.dtsi file, which we will go over next. Briefly, it is used to tell which pins are used for which function, such as UART TX/RX, I2C SCL/SDA, SPI MOSI/MISO/SCK, and PWM output. Also, the \"compatible\" property is used to specify the driver for the peripheral. Then, inside of the root node ( / { ... } ), we need to add the following to support the LEDs, buttons, and PWM LEDs. This is done by exposing them using aliases and defining their properties. The following is the complete device tree source file for our custom board: / { model = \"My 52840 DK\"; compatible = \"tonyfu97,my52840dk\"; chosen { zephyr,sram = &sram0; zephyr,flash = &flash0; zephyr,code-partition = &slot0_partition; zephyr,console = &uart0 ; zephyr,shell-uart = &uart0 ; zephyr,uart-mcumgr = &uart0; }; leds { compatible = \"gpio-leds\"; led0: led_0 { gpios = <&gpio0 13 GPIO_ACTIVE_LOW>; label = \"Green LED 0\"; }; led1: led_1 { gpios = <&gpio0 14 GPIO_ACTIVE_LOW>; label = \"Green LED 1\"; }; led2: led_2 { gpios = <&gpio0 15 GPIO_ACTIVE_LOW>; label = \"Green LED 2\"; }; led3: led_3 { gpios = <&gpio0 16 GPIO_ACTIVE_LOW>; label = \"Green LED 3\"; }; }; buttons { compatible = \"gpio-keys\"; button0: button_0 { gpios = <&gpio0 11 (GPIO_PULL_UP | GPIO_ACTIVE_LOW)>; label = \"Push button switch 0\"; zephyr,code = <INPUT_KEY_0>; }; button1: button_1 { gpios = <&gpio0 12 (GPIO_PULL_UP | GPIO_ACTIVE_LOW)>; label = \"Push button switch 1\"; zephyr,code = <INPUT_KEY_1>; }; button2: button_2 { gpios = <&gpio0 24 (GPIO_PULL_UP | GPIO_ACTIVE_LOW)>; label = \"Push button switch 2\"; zephyr,code = <INPUT_KEY_2>; }; button3: button_3 { gpios = <&gpio0 25 (GPIO_PULL_UP | GPIO_ACTIVE_LOW)>; label = \"Push button switch 3\"; zephyr,code = <INPUT_KEY_3>; }; }; pwmleds { compatible = \"pwm-leds\"; pwm_led0: pwm_led_0 { pwms = <&pwm0 0 PWM_MSEC(20) PWM_POLARITY_INVERTED>; }; }; /* These aliases are provided for compatibility with samples */ aliases { led0 = &led0; led1 = &led1; led2 = &led2; led3 = &led3; pwm-led0 = &pwm_led0; sw0 = &button0; sw1 = &button1; sw2 = &button2; sw3 = &button3; bootloader-led0 = &led0; mcuboot-button0 = &button0; mcuboot-led0 = &led0; watchdog0 = &wdt0; }; }; You also need to include the input event codes header file to define the button codes. This is done by adding the following line at the top of the DTS file: #include <zephyr/dt-bindings/input/input-event-codes.h>","title":"3. Flash and Partition Layout"},{"location":"sdk-03-custom-board/#pin-control-file-my52840dk-pinctrldtsi","text":"The \"Device Tree Source Include\" (dsti) file is used to define the pin control configurations for the board. This file is included in the main DTS file and contains the pin configurations for the peripherals. The auto-generated my52840dk-pinctrl.dtsi file is almost empty: &pinctrl { };","title":"Pin Control File: my52840dk-pinctrl.dtsi"},{"location":"setup-01-vscode/","text":"01 Setup nRF Connect SDK with VSCode Author: Tony Fu Date: 2025/04/26 Device: nRF52840 DK Toolchain: nRF Connect SDK v3.0.0 Setup nRF Connect SDK with VSCode I would recommend this tutorial series for setting up the nRF Connect SDK with VSCode. nrfutil To my suprise, the VSCode extension (and the toolchain that it install) did not include the nrfutil package. This is required for flashing the firmware. Without it, the \"flash\" action button of the VSCode extension will not work. Simply head to this website and download the latest version of nrfutil . Then add it to your PATH. Open a terminal and run the following command to see what commands are available: nrfutil search You should see something like this: Command Installed Latest Status 91 0.5.0 Not installed ble-sniffer 0.16.2 Not installed completion 1.5.0 Not installed device 2.9.0 Not installed npm 0.3.0 Not installed nrf5sdk-tools 1.1.0 1.1.0 Installed sdk-manager 1.1.0 Not installed suit 0.9.0 Not installed toolchain-manager 0.15.0 Not installed trace 3.3.1 Not installed You should install the device command. This is required for flashing the firmware. To install it, run the following command: nrfutil install device","title":"Setup-VSCode"},{"location":"setup-01-vscode/#01-setup-nrf-connect-sdk-with-vscode","text":"Author: Tony Fu Date: 2025/04/26 Device: nRF52840 DK Toolchain: nRF Connect SDK v3.0.0","title":"01 Setup nRF Connect SDK with VSCode"},{"location":"setup-01-vscode/#setup-nrf-connect-sdk-with-vscode","text":"I would recommend this tutorial series for setting up the nRF Connect SDK with VSCode.","title":"Setup nRF Connect SDK with VSCode"},{"location":"setup-01-vscode/#nrfutil","text":"To my suprise, the VSCode extension (and the toolchain that it install) did not include the nrfutil package. This is required for flashing the firmware. Without it, the \"flash\" action button of the VSCode extension will not work. Simply head to this website and download the latest version of nrfutil . Then add it to your PATH. Open a terminal and run the following command to see what commands are available: nrfutil search You should see something like this: Command Installed Latest Status 91 0.5.0 Not installed ble-sniffer 0.16.2 Not installed completion 1.5.0 Not installed device 2.9.0 Not installed npm 0.3.0 Not installed nrf5sdk-tools 1.1.0 1.1.0 Installed sdk-manager 1.1.0 Not installed suit 0.9.0 Not installed toolchain-manager 0.15.0 Not installed trace 3.3.1 Not installed You should install the device command. This is required for flashing the firmware. To install it, run the following command: nrfutil install device","title":"nrfutil"},{"location":"setup-02-prj-conf-trick/","text":"Setup 02: How to know what to put in prj.conf? Consult sample code Check Kconfig files Check online documentation Work backwards from the function(s) you want to use to the Kconfig options that enable them","title":"Setup 02: How to know what to put in prj.conf?"},{"location":"setup-02-prj-conf-trick/#setup-02-how-to-know-what-to-put-in-prjconf","text":"Consult sample code Check Kconfig files Check online documentation Work backwards from the function(s) you want to use to the Kconfig options that enable them","title":"Setup 02: How to know what to put in prj.conf?"}]}