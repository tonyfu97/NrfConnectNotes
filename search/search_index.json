{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"nRF Connect SDK Notes This site contains my notes for the official courses on Nordic Developer Academy .","title":"Home"},{"location":"#nrf-connect-sdk-notes","text":"This site contains my notes for the official courses on Nordic Developer Academy .","title":"nRF Connect SDK Notes"},{"location":"01-ble-minimal-skeleton/","text":"01 - Minimal BLE Skeleton This example sets up the Bluetooth stack only \u2014 no advertising, no services, no connections. Useful as a clean starting point. Configuration: prj.conf # Enable basic logging CONFIG_LOG=y # Enable Bluetooth stack CONFIG_BT=y # Optional: Set device name (not used here but required for CONFIG_BT) CONFIG_BT_DEVICE_NAME=\"Minimal_BLE\" # Increase stack sizes for stability CONFIG_SYSTEM_WORKQUEUE_STACK_SIZE=2048 CONFIG_MAIN_STACK_SIZE=2048 Code Structure: main.c #include <zephyr/kernel.h> #include <zephyr/logging/log.h> #include <zephyr/bluetooth/bluetooth.h> LOG_MODULE_REGISTER(minimal_ble, LOG_LEVEL_INF); int main(void) { int err; LOG_INF(\"Minimal BLE Example Start\"); // Initialize the Bluetooth stack err = bt_enable(NULL); if (err) { LOG_ERR(\"Bluetooth init failed (err %d)\", err); return -1; } LOG_INF(\"Bluetooth initialized\"); // Idle loop while (1) { k_sleep(K_SECONDS(1)); } }","title":"BLE-Minimal Skeleton"},{"location":"01-ble-minimal-skeleton/#01-minimal-ble-skeleton","text":"This example sets up the Bluetooth stack only \u2014 no advertising, no services, no connections. Useful as a clean starting point.","title":"01 - Minimal BLE Skeleton"},{"location":"01-ble-minimal-skeleton/#configuration-prjconf","text":"# Enable basic logging CONFIG_LOG=y # Enable Bluetooth stack CONFIG_BT=y # Optional: Set device name (not used here but required for CONFIG_BT) CONFIG_BT_DEVICE_NAME=\"Minimal_BLE\" # Increase stack sizes for stability CONFIG_SYSTEM_WORKQUEUE_STACK_SIZE=2048 CONFIG_MAIN_STACK_SIZE=2048","title":"Configuration: prj.conf"},{"location":"01-ble-minimal-skeleton/#code-structure-mainc","text":"#include <zephyr/kernel.h> #include <zephyr/logging/log.h> #include <zephyr/bluetooth/bluetooth.h> LOG_MODULE_REGISTER(minimal_ble, LOG_LEVEL_INF); int main(void) { int err; LOG_INF(\"Minimal BLE Example Start\"); // Initialize the Bluetooth stack err = bt_enable(NULL); if (err) { LOG_ERR(\"Bluetooth init failed (err %d)\", err); return -1; } LOG_INF(\"Bluetooth initialized\"); // Idle loop while (1) { k_sleep(K_SECONDS(1)); } }","title":"Code Structure: main.c"},{"location":"02-ble-advertising-simple/","text":"02 - BLE Advertising Simple To advertise your device, you need to call bt_le_adv_start() with the right parameters. int bt_le_adv_start(const struct bt_le_adv_param *param, const struct bt_data *ad, size_t ad_len, const struct bt_data *sd, size_t sd_len); param : Advertising parameters (defines behavior) ad : Advertising data (broadcasted to all scanners) sd : Scan response data (optional, sent after scan request) Common Advertising Params BT_LE_ADV_CONN - Connectable undirected advertising, but still advertises to all devices after connected to a peer. This could be bad for power consumption and security. BT_LE_ADV_CONN_ONE_TIME - Connectable undirected advertising, but stops after the first connection. This is the recommended default for most applications. BT_LE_ADV_CONN_DIR - Connectable directed advertising, which is used when you know the peer address. This is faster and less power-hungry than undirected advertising. BT_LE_ADV_NCONN - Non-connectable undirected advertising, which is used when you don't want to be connected to. This is useful for beacons and other passive broadcasts. BT_LE_ADV_CONN_DIR_LOW_DUTY - Connectable directed advertising with a lower duty cycle, which is used when you don't expect to be connected to immediately but still want to reconnect with a known peer. BT_LE_ADV_NCONN_IDENTITY - Non-connectable advertising that uses the device's identity address, which is useful for testing and visibility. Note: To prevent tracking, advertising modes like BT_LE_ADV_CONN , BT_LE_ADV_CONN_ONE_TIME , and BT_LE_ADV_NCONN (params 1, 2, and 4) use Resolvable Private Addresses (RPAs) by default. RPAs are a privacy feature introduced in Bluetooth 4.2. They are generated using the device\u2019s identity address (public or static random) and a random value, and they typically change every 15 minutes. This allows trusted, bonded peers to resolve your identity, while third parties cannot track the device over time. RPA behavior is enabled by default when CONFIG_BT_PRIVACY=y , but it can be disabled if needed. To explicitly advertise with your identity address (e.g., for testing or directed advertising), use the BT_LE_ADV_OPT_USE_IDENTITY option. Advertising Data and Scan Response Data Advertising Data (ad[]) static const struct bt_data ad[] = { BT_DATA_BYTES(BT_DATA_FLAGS, (BT_LE_AD_GENERAL | BT_LE_AD_NO_BREDR)), BT_DATA(BT_DATA_NAME_COMPLETE, DEVICE_NAME, DEVICE_NAME_LEN), }; This example shows how to define advertising data using struct bt_data . struct bt_data { uint8_t type; uint8_t data_len; const uint8_t *data; }; However, we typically don't define `struct bt_data` directly. Instead, we use macros to simplify the process. ```c BT_DATA(type, data, data_len) // Use with a pointer and explicit size BT_DATA_BYTES(type, byte1, byte2...) // Inline declaration with raw bytes In advertising data, we must always include the following fields: BT_DATA_BYTES(BT_DATA_FLAGS, (BT_LE_AD_GENERAL | BT_LE_AD_NO_BREDR)) This is always used on Nordic devices because Nordic only supports BLE (not BR/EDR), and this is why we include <zephyr/bluetooth/gap.h> for the bitmasks. and BT_DATA(BT_DATA_NAME_COMPLETE, DEVICE_NAME, DEVICE_NAME_LEN) Scan Response Data (sd[]) Use scan response (sd) when you want to include optional, larger data like a full device name or a URL. Advertising data is always broadcast; scan response is only sent when a scanner asks for it, making it more power-efficient and less crowded. #define COMPANY_ID_CODE 0x0059 // Nordic Semiconductor typedef struct { uint16_t company_id; // Company ID uint8_t data[6]; // Custom Data } my_data_t; static const my_data_t my_data = { .company_id = COMPANY_ID_CODE, .data = {0x01, 0x02, 0x03, 0x04, 0x05, 0x06}}; When the advertising data is too large to fit in advertising packets, the scanner can request a scan response. This is not shown here. Common Advertising Data Types Common in ad[] (Advertising) Macro Description BT_DATA_FLAGS BLE flags (required) BT_DATA_NAME_COMPLETE Complete device name BT_DATA_UUID16_ALL List of 16-bit service UUIDs BT_DATA_UUID128_ALL List of 128-bit service UUIDs BT_DATA_MANUFACTURER_DATA Vendor-specific binary data Common in sd[] (Scan Response) Macro Description BT_DATA_URI URI string (e.g., website) BT_DATA_TX_POWER Transmission power (in dBm) BT_DATA_APPEARANCE Device appearance (e.g., watch) BT_DATA_NAME_SHORTENED Shortened name (if full name won't fit) More on service UUIDs later.","title":"BLE-Advertising Simple"},{"location":"02-ble-advertising-simple/#02-ble-advertising-simple","text":"To advertise your device, you need to call bt_le_adv_start() with the right parameters. int bt_le_adv_start(const struct bt_le_adv_param *param, const struct bt_data *ad, size_t ad_len, const struct bt_data *sd, size_t sd_len); param : Advertising parameters (defines behavior) ad : Advertising data (broadcasted to all scanners) sd : Scan response data (optional, sent after scan request)","title":"02 - BLE Advertising Simple"},{"location":"02-ble-advertising-simple/#common-advertising-params","text":"BT_LE_ADV_CONN - Connectable undirected advertising, but still advertises to all devices after connected to a peer. This could be bad for power consumption and security. BT_LE_ADV_CONN_ONE_TIME - Connectable undirected advertising, but stops after the first connection. This is the recommended default for most applications. BT_LE_ADV_CONN_DIR - Connectable directed advertising, which is used when you know the peer address. This is faster and less power-hungry than undirected advertising. BT_LE_ADV_NCONN - Non-connectable undirected advertising, which is used when you don't want to be connected to. This is useful for beacons and other passive broadcasts. BT_LE_ADV_CONN_DIR_LOW_DUTY - Connectable directed advertising with a lower duty cycle, which is used when you don't expect to be connected to immediately but still want to reconnect with a known peer. BT_LE_ADV_NCONN_IDENTITY - Non-connectable advertising that uses the device's identity address, which is useful for testing and visibility. Note: To prevent tracking, advertising modes like BT_LE_ADV_CONN , BT_LE_ADV_CONN_ONE_TIME , and BT_LE_ADV_NCONN (params 1, 2, and 4) use Resolvable Private Addresses (RPAs) by default. RPAs are a privacy feature introduced in Bluetooth 4.2. They are generated using the device\u2019s identity address (public or static random) and a random value, and they typically change every 15 minutes. This allows trusted, bonded peers to resolve your identity, while third parties cannot track the device over time. RPA behavior is enabled by default when CONFIG_BT_PRIVACY=y , but it can be disabled if needed. To explicitly advertise with your identity address (e.g., for testing or directed advertising), use the BT_LE_ADV_OPT_USE_IDENTITY option.","title":"Common Advertising Params"},{"location":"02-ble-advertising-simple/#advertising-data-and-scan-response-data","text":"","title":"Advertising Data and Scan Response Data"},{"location":"02-ble-advertising-simple/#advertising-data-ad","text":"static const struct bt_data ad[] = { BT_DATA_BYTES(BT_DATA_FLAGS, (BT_LE_AD_GENERAL | BT_LE_AD_NO_BREDR)), BT_DATA(BT_DATA_NAME_COMPLETE, DEVICE_NAME, DEVICE_NAME_LEN), }; This example shows how to define advertising data using struct bt_data . struct bt_data { uint8_t type; uint8_t data_len; const uint8_t *data; }; However, we typically don't define `struct bt_data` directly. Instead, we use macros to simplify the process. ```c BT_DATA(type, data, data_len) // Use with a pointer and explicit size BT_DATA_BYTES(type, byte1, byte2...) // Inline declaration with raw bytes In advertising data, we must always include the following fields: BT_DATA_BYTES(BT_DATA_FLAGS, (BT_LE_AD_GENERAL | BT_LE_AD_NO_BREDR)) This is always used on Nordic devices because Nordic only supports BLE (not BR/EDR), and this is why we include <zephyr/bluetooth/gap.h> for the bitmasks. and BT_DATA(BT_DATA_NAME_COMPLETE, DEVICE_NAME, DEVICE_NAME_LEN)","title":"Advertising Data (ad[])"},{"location":"02-ble-advertising-simple/#scan-response-data-sd","text":"Use scan response (sd) when you want to include optional, larger data like a full device name or a URL. Advertising data is always broadcast; scan response is only sent when a scanner asks for it, making it more power-efficient and less crowded. #define COMPANY_ID_CODE 0x0059 // Nordic Semiconductor typedef struct { uint16_t company_id; // Company ID uint8_t data[6]; // Custom Data } my_data_t; static const my_data_t my_data = { .company_id = COMPANY_ID_CODE, .data = {0x01, 0x02, 0x03, 0x04, 0x05, 0x06}}; When the advertising data is too large to fit in advertising packets, the scanner can request a scan response. This is not shown here.","title":"Scan Response Data (sd[])"},{"location":"02-ble-advertising-simple/#common-advertising-data-types","text":"","title":"Common Advertising Data Types"},{"location":"02-ble-advertising-simple/#common-in-ad-advertising","text":"Macro Description BT_DATA_FLAGS BLE flags (required) BT_DATA_NAME_COMPLETE Complete device name BT_DATA_UUID16_ALL List of 16-bit service UUIDs BT_DATA_UUID128_ALL List of 128-bit service UUIDs BT_DATA_MANUFACTURER_DATA Vendor-specific binary data","title":"Common in ad[] (Advertising)"},{"location":"02-ble-advertising-simple/#common-in-sd-scan-response","text":"Macro Description BT_DATA_URI URI string (e.g., website) BT_DATA_TX_POWER Transmission power (in dBm) BT_DATA_APPEARANCE Device appearance (e.g., watch) BT_DATA_NAME_SHORTENED Shortened name (if full name won't fit) More on service UUIDs later.","title":"Common in sd[] (Scan Response)"}]}