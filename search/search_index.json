{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"nRF Connect SDK Notes This site contains my notes for the official courses on Nordic Developer Academy . Note: In order to not exceed the filename length limit, please make sure to clone the repository as close to the root of your filesystem as possible.","title":"Home"},{"location":"#nrf-connect-sdk-notes","text":"This site contains my notes for the official courses on Nordic Developer Academy . Note: In order to not exceed the filename length limit, please make sure to clone the repository as close to the root of your filesystem as possible.","title":"nRF Connect SDK Notes"},{"location":"01-ble-minimal-skeleton/","text":"01 - Minimal BLE Skeleton This example sets up the Bluetooth stack only \u2014 no advertising, no services, no connections. Useful as a clean starting point. Configuration: prj.conf # Enable basic logging CONFIG_LOG=y # Enable Bluetooth stack CONFIG_BT=y # Optional: Set device name (not used here but required for CONFIG_BT) CONFIG_BT_DEVICE_NAME=\"Minimal_BLE\" # Increase stack sizes for stability CONFIG_SYSTEM_WORKQUEUE_STACK_SIZE=2048 CONFIG_MAIN_STACK_SIZE=2048 Code Structure: main.c #include <zephyr/kernel.h> #include <zephyr/logging/log.h> #include <zephyr/bluetooth/bluetooth.h> LOG_MODULE_REGISTER(minimal_ble, LOG_LEVEL_INF); int main(void) { int err; LOG_INF(\"Minimal BLE Example Start\"); // Initialize the Bluetooth stack err = bt_enable(NULL); if (err) { LOG_ERR(\"Bluetooth init failed (err %d)\", err); return -1; } LOG_INF(\"Bluetooth initialized\"); // Idle loop while (1) { k_sleep(K_SECONDS(1)); } }","title":"BLE-Minimal Skeleton"},{"location":"01-ble-minimal-skeleton/#01-minimal-ble-skeleton","text":"This example sets up the Bluetooth stack only \u2014 no advertising, no services, no connections. Useful as a clean starting point.","title":"01 - Minimal BLE Skeleton"},{"location":"01-ble-minimal-skeleton/#configuration-prjconf","text":"# Enable basic logging CONFIG_LOG=y # Enable Bluetooth stack CONFIG_BT=y # Optional: Set device name (not used here but required for CONFIG_BT) CONFIG_BT_DEVICE_NAME=\"Minimal_BLE\" # Increase stack sizes for stability CONFIG_SYSTEM_WORKQUEUE_STACK_SIZE=2048 CONFIG_MAIN_STACK_SIZE=2048","title":"Configuration: prj.conf"},{"location":"01-ble-minimal-skeleton/#code-structure-mainc","text":"#include <zephyr/kernel.h> #include <zephyr/logging/log.h> #include <zephyr/bluetooth/bluetooth.h> LOG_MODULE_REGISTER(minimal_ble, LOG_LEVEL_INF); int main(void) { int err; LOG_INF(\"Minimal BLE Example Start\"); // Initialize the Bluetooth stack err = bt_enable(NULL); if (err) { LOG_ERR(\"Bluetooth init failed (err %d)\", err); return -1; } LOG_INF(\"Bluetooth initialized\"); // Idle loop while (1) { k_sleep(K_SECONDS(1)); } }","title":"Code Structure: main.c"},{"location":"02-ble-advertising-simple/","text":"02 - BLE Advertising Simple To advertise your device, you need to call bt_le_adv_start() with the right parameters. int bt_le_adv_start(const struct bt_le_adv_param *param, const struct bt_data *ad, size_t ad_len, const struct bt_data *sd, size_t sd_len); param : Advertising parameters (defines behavior) ad : Advertising data (broadcasted to all scanners) sd : Scan response data (optional, sent after scan request) Common Advertising Params BT_LE_ADV_CONN - Connectable undirected advertising, but still advertises to all devices after connected to a peer. This could be bad for power consumption and security. BT_LE_ADV_CONN_ONE_TIME - Connectable undirected advertising, but stops after the first connection. This is the recommended default for most applications. BT_LE_ADV_CONN_DIR - Connectable directed advertising, which is used when you know the peer address. This is faster and less power-hungry than undirected advertising. BT_LE_ADV_NCONN - Non-connectable undirected advertising, which is used when you don't want to be connected to. This is useful for beacons and other passive broadcasts. BT_LE_ADV_CONN_DIR_LOW_DUTY - Connectable directed advertising with a lower duty cycle, which is used when you don't expect to be connected to immediately but still want to reconnect with a known peer. BT_LE_ADV_NCONN_IDENTITY - Non-connectable advertising that uses the device's identity address, which is useful for testing and visibility. Note: To prevent tracking, advertising modes like BT_LE_ADV_CONN , BT_LE_ADV_CONN_ONE_TIME , and BT_LE_ADV_NCONN (params 1, 2, and 4) use Resolvable Private Addresses (RPAs) by default. RPAs are a privacy feature introduced in Bluetooth 4.2. They are generated using the device\u2019s identity address (public or static random) and a random value, and they typically change every 15 minutes. This allows trusted, bonded peers to resolve your identity, while third parties cannot track the device over time. RPA behavior is enabled by default when CONFIG_BT_PRIVACY=y , but it can be disabled if needed. To explicitly advertise with your identity address (e.g., for testing or directed advertising), use the BT_LE_ADV_OPT_USE_IDENTITY option. Advertising Data and Scan Response Data Advertising Data (ad[]) static const struct bt_data ad[] = { BT_DATA_BYTES(BT_DATA_FLAGS, (BT_LE_AD_GENERAL | BT_LE_AD_NO_BREDR)), BT_DATA(BT_DATA_NAME_COMPLETE, DEVICE_NAME, DEVICE_NAME_LEN), }; This example shows how to define advertising data using struct bt_data . struct bt_data { uint8_t type; uint8_t data_len; const uint8_t *data; }; However, we typically don't define `struct bt_data` directly. Instead, we use macros to simplify the process. ```c BT_DATA(type, data, data_len) // Use with a pointer and explicit size BT_DATA_BYTES(type, byte1, byte2...) // Inline declaration with raw bytes In advertising data, we must always include the following fields: BT_DATA_BYTES(BT_DATA_FLAGS, (BT_LE_AD_GENERAL | BT_LE_AD_NO_BREDR)) This is always used on Nordic devices because Nordic only supports BLE (not BR/EDR), and this is why we include <zephyr/bluetooth/gap.h> for the bitmasks. and BT_DATA(BT_DATA_NAME_COMPLETE, DEVICE_NAME, DEVICE_NAME_LEN) Scan Response Data (sd[]) Use scan response (sd) when you want to include optional, larger data like a full device name or a URL. Advertising data is always broadcast; scan response is only sent when a scanner asks for it, making it more power-efficient and less crowded. #define COMPANY_ID_CODE 0x0059 // Nordic Semiconductor typedef struct { uint16_t company_id; // Company ID uint8_t data[6]; // Custom Data } my_data_t; static const my_data_t my_data = { .company_id = COMPANY_ID_CODE, .data = {0x01, 0x02, 0x03, 0x04, 0x05, 0x06}}; When the advertising data is too large to fit in advertising packets, the scanner can request a scan response. This is not shown here. Common Advertising Data Types Common in ad[] (Advertising) Macro Description BT_DATA_FLAGS BLE flags (required) BT_DATA_NAME_COMPLETE Complete device name BT_DATA_UUID16_ALL List of 16-bit service UUIDs BT_DATA_UUID128_ALL List of 128-bit service UUIDs BT_DATA_MANUFACTURER_DATA Vendor-specific binary data Common in sd[] (Scan Response) Macro Description BT_DATA_URI URI string (e.g., website) BT_DATA_TX_POWER Transmission power (in dBm) BT_DATA_APPEARANCE Device appearance (e.g., watch) BT_DATA_NAME_SHORTENED Shortened name (if full name won't fit) More on service UUIDs later.","title":"BLE-Advertising Simple"},{"location":"02-ble-advertising-simple/#02-ble-advertising-simple","text":"To advertise your device, you need to call bt_le_adv_start() with the right parameters. int bt_le_adv_start(const struct bt_le_adv_param *param, const struct bt_data *ad, size_t ad_len, const struct bt_data *sd, size_t sd_len); param : Advertising parameters (defines behavior) ad : Advertising data (broadcasted to all scanners) sd : Scan response data (optional, sent after scan request)","title":"02 - BLE Advertising Simple"},{"location":"02-ble-advertising-simple/#common-advertising-params","text":"BT_LE_ADV_CONN - Connectable undirected advertising, but still advertises to all devices after connected to a peer. This could be bad for power consumption and security. BT_LE_ADV_CONN_ONE_TIME - Connectable undirected advertising, but stops after the first connection. This is the recommended default for most applications. BT_LE_ADV_CONN_DIR - Connectable directed advertising, which is used when you know the peer address. This is faster and less power-hungry than undirected advertising. BT_LE_ADV_NCONN - Non-connectable undirected advertising, which is used when you don't want to be connected to. This is useful for beacons and other passive broadcasts. BT_LE_ADV_CONN_DIR_LOW_DUTY - Connectable directed advertising with a lower duty cycle, which is used when you don't expect to be connected to immediately but still want to reconnect with a known peer. BT_LE_ADV_NCONN_IDENTITY - Non-connectable advertising that uses the device's identity address, which is useful for testing and visibility. Note: To prevent tracking, advertising modes like BT_LE_ADV_CONN , BT_LE_ADV_CONN_ONE_TIME , and BT_LE_ADV_NCONN (params 1, 2, and 4) use Resolvable Private Addresses (RPAs) by default. RPAs are a privacy feature introduced in Bluetooth 4.2. They are generated using the device\u2019s identity address (public or static random) and a random value, and they typically change every 15 minutes. This allows trusted, bonded peers to resolve your identity, while third parties cannot track the device over time. RPA behavior is enabled by default when CONFIG_BT_PRIVACY=y , but it can be disabled if needed. To explicitly advertise with your identity address (e.g., for testing or directed advertising), use the BT_LE_ADV_OPT_USE_IDENTITY option.","title":"Common Advertising Params"},{"location":"02-ble-advertising-simple/#advertising-data-and-scan-response-data","text":"","title":"Advertising Data and Scan Response Data"},{"location":"02-ble-advertising-simple/#advertising-data-ad","text":"static const struct bt_data ad[] = { BT_DATA_BYTES(BT_DATA_FLAGS, (BT_LE_AD_GENERAL | BT_LE_AD_NO_BREDR)), BT_DATA(BT_DATA_NAME_COMPLETE, DEVICE_NAME, DEVICE_NAME_LEN), }; This example shows how to define advertising data using struct bt_data . struct bt_data { uint8_t type; uint8_t data_len; const uint8_t *data; }; However, we typically don't define `struct bt_data` directly. Instead, we use macros to simplify the process. ```c BT_DATA(type, data, data_len) // Use with a pointer and explicit size BT_DATA_BYTES(type, byte1, byte2...) // Inline declaration with raw bytes In advertising data, we must always include the following fields: BT_DATA_BYTES(BT_DATA_FLAGS, (BT_LE_AD_GENERAL | BT_LE_AD_NO_BREDR)) This is always used on Nordic devices because Nordic only supports BLE (not BR/EDR), and this is why we include <zephyr/bluetooth/gap.h> for the bitmasks. and BT_DATA(BT_DATA_NAME_COMPLETE, DEVICE_NAME, DEVICE_NAME_LEN)","title":"Advertising Data (ad[])"},{"location":"02-ble-advertising-simple/#scan-response-data-sd","text":"Use scan response (sd) when you want to include optional, larger data like a full device name or a URL. Advertising data is always broadcast; scan response is only sent when a scanner asks for it, making it more power-efficient and less crowded. #define COMPANY_ID_CODE 0x0059 // Nordic Semiconductor typedef struct { uint16_t company_id; // Company ID uint8_t data[6]; // Custom Data } my_data_t; static const my_data_t my_data = { .company_id = COMPANY_ID_CODE, .data = {0x01, 0x02, 0x03, 0x04, 0x05, 0x06}}; When the advertising data is too large to fit in advertising packets, the scanner can request a scan response. This is not shown here.","title":"Scan Response Data (sd[])"},{"location":"02-ble-advertising-simple/#common-advertising-data-types","text":"","title":"Common Advertising Data Types"},{"location":"02-ble-advertising-simple/#common-in-ad-advertising","text":"Macro Description BT_DATA_FLAGS BLE flags (required) BT_DATA_NAME_COMPLETE Complete device name BT_DATA_UUID16_ALL List of 16-bit service UUIDs BT_DATA_UUID128_ALL List of 128-bit service UUIDs BT_DATA_MANUFACTURER_DATA Vendor-specific binary data","title":"Common in ad[] (Advertising)"},{"location":"02-ble-advertising-simple/#common-in-sd-scan-response","text":"Macro Description BT_DATA_URI URI string (e.g., website) BT_DATA_TX_POWER Transmission power (in dBm) BT_DATA_APPEARANCE Device appearance (e.g., watch) BT_DATA_NAME_SHORTENED Shortened name (if full name won't fit) More on service UUIDs later.","title":"Common in sd[] (Scan Response)"},{"location":"03-ble-advert-connectable/","text":"03 - BLE Advertising: Connectable To make a device connectable, we need to enable the Bluetooth peripheral role and set the advertising parameters accordingly. Add this to your prj.conf file: CONFIG_BT_PERIPHERAL=y In previous examples, we used the predefined macro BT_LE_ADV_NCONN for non-connectable advertising. To allow connections, we need different parameters like BT_LE_ADV_CONN_ONE_TIME . We can also define our own advertising parameters with the help of the BT_LE_ADV_PARAM() macro: BT_LE_ADV_PARAM(_options, _int_min, _int_max, _peer) _options : A bitmask of advertising options (e.g., connectable, use identity, etc.) _int_min , _int_max : Advertising interval (units of 0.625 ms) _peer : Peer address; set to NULL for undirected advertising Example parameters for connectable advertising: static const struct bt_le_adv_param *adv_param = BT_LE_ADV_PARAM( (BT_LE_ADV_OPT_CONNECTABLE | BT_LE_ADV_OPT_USE_IDENTITY), /* Connectable advertising and use identity address */ BT_GAP_ADV_FAST_INT_MIN_2, /* Min Advertising Interval 100 ms */ BT_GAP_ADV_FAST_INT_MAX_2, /* Max Advertising Interval 150 ms */ NULL); /* Set to NULL for undirected advertising */ Common options flags include: BT_LE_ADV_OPT_CONNECTABLE : Allow devices to connect BT_LE_ADV_OPT_ONE_TIME : Stop advertising after one connection BT_LE_ADV_OPT_USE_IDENTITY : Use the device's identity address (not RPA) BT_LE_ADV_OPT_USE_NAME : Automatically include the GAP device name BT_LE_ADV_OPT_SCANNABLE : Enable scan response data BT_LE_ADV_OPT_EXT_ADV : Use extended advertising features (for longer range or larger data) BT_LE_ADV_OPT_FILTER_SCAN_REQ : Only respond to scanners in the filter list BT_LE_ADV_OPT_FILTER_CONN : Only allow connections from filtered peers This setup allows your device to be discoverable and accept connections from central devices like phones or PCs. However, it will continue to advertise even after a connection is established, which may not be ideal for power consumption or security. To stop advertising after the first connection, add the BT_LE_ADV_OPT_ONE_TIME option. Advertising Intervals The advertising interval controls how often your device broadcasts its advertising packets. It is set using _int_min and _int_max in BT_LE_ADV_PARAM() and is specified in units of 0.625 ms. Valid range : 20 ms to 10.24 seconds Resolution : 0.625 ms steps You can set: - min == max \u2192 Fixed interval (allowed) - min < max \u2192 Interval chosen randomly within that range (typical) A small random delay (0\u201310 ms) is added automatically to help avoid collisions between devices using similar intervals. Guidelines Short intervals (~20\u2013100 ms) : Fast discovery, higher power consumption Medium intervals (~150\u2013500 ms) : Balanced power and discovery time (good default) Long intervals (>1 s) : Low power, slower to be discovered Choose an interval based on your application: - For wearables or low-power sensors , favor longer intervals - For pairing mode or quick reconnection , use shorter intervals Some constants are defined in zephyr/bluetooth/gap.h for common intervals: GAP Advertising Parameters These are predefined intervals for legacy advertisement (connectable or scannable), used by many macros like BT_LE_ADV_CONN . Macro Hex Time (ms) BT_GAP_ADV_FAST_INT_MIN_1 0x0030 30 BT_GAP_ADV_FAST_INT_MAX_1 0x0060 60 BT_GAP_ADV_FAST_INT_MIN_2 0x00a0 100 BT_GAP_ADV_FAST_INT_MAX_2 0x00f0 150 BT_GAP_ADV_SLOW_INT_MIN 0x0640 1000 BT_GAP_ADV_SLOW_INT_MAX 0x0780 1200 GAP Periodic Advertising Parameters Periodic advertising is a Bluetooth Low Energy feature introduced in Bluetooth 5 that allows a device to broadcast data at fixed, predictable intervals without requiring a connection. Unlike legacy advertising, which is sent on the primary channels and may be missed if the scanner isn't listening at the right time, periodic advertising uses a synchronizable schedule and is transmitted on secondary channels. This allows scanners to synchronize with the advertiser and receive updates reliably with lower power consumption. It's ideal for broadcasting sensor data , location beacons , or status updates where frequent connections aren't needed but consistent updates are. Macro Hex Time (ms) BT_GAP_PER_ADV_FAST_INT_MIN_1 0x0018 30 BT_GAP_PER_ADV_FAST_INT_MAX_1 0x0030 60 BT_GAP_PER_ADV_FAST_INT_MIN_2 0x0050 100 BT_GAP_PER_ADV_FAST_INT_MAX_2 0x0078 150 BT_GAP_PER_ADV_SLOW_INT_MIN 0x0320 1000 BT_GAP_PER_ADV_SLOW_INT_MAX 0x03C0 1200 GAP Scan Parameters These define standard scan intervals and windows. The interval is how often scanning starts, and the window is how long each scan lasts. Macro Hex Time (ms) BT_GAP_SCAN_FAST_INTERVAL_MIN 0x0030 30 BT_GAP_SCAN_FAST_INTERVAL 0x0060 60 BT_GAP_SCAN_FAST_WINDOW 0x0030 30 BT_GAP_SCAN_SLOW_INTERVAL_1 0x0800 1280 BT_GAP_SCAN_SLOW_WINDOW_1 0x0012 11.25 BT_GAP_SCAN_SLOW_INTERVAL_2 0x1000 2560 BT_GAP_SCAN_SLOW_WINDOW_2 0x0012 11.25 GAP Initial Connection Parameters These define intervals used when initiating a connection (i.e., when a central connects to a peripheral). Macro Hex Time (ms) BT_GAP_INIT_CONN_INT_MIN 0x0018 30 BT_GAP_INIT_CONN_INT_MAX 0x0028 50 Additional Notes on Timing Coordination When both the advertiser and scanner are under your control, you can optimize their timing parameters to strike a balance between discovery speed , power consumption , and reliability . This is especially useful in scenarios like proprietary ecosystems, closed systems, or when designing both ends of a BLE link (e.g., a wearable + smartphone app). Understanding Scan Interval and Scan Window Scan interval is how often the scanner initiates a scan cycle. Scan window is how long the scanner listens during each scan interval. Both range from 2.5 ms to 10.24 seconds in 0.625 ms steps. In each scan interval, the scanner will scan one of the three primary advertising channels. After the interval ends, it switches to the next channel. If the scan window is equal to the scan interval, the scanner is scanning continuously (100% duty cycle). If the window is shorter than the interval, it means the scanner is off part of the time \u2014 which saves power. For example, if scan interval = 100 ms and window = 20 ms, the scanner is listening only 20% of the time. Coordinating With Advertising Intervals To improve the chances of the scanner receiving advertising packets: The advertising interval should be shorter than or equal to the scan interval. This increases the probability that an advertisement will occur during the scan window. A good rule of thumb is: advertising interval \u2264 scan interval - scan window This ensures that at least one advertisement falls within an active scan window over multiple cycles. You can also align timing using multiples, such as: - Scan interval = 3 \u00d7 advertising interval - Scan window = 50\u201380% of scan interval (for reasonable duty cycle) This is not a strict rule, but it helps statistically reduce missed advertisements due to phase misalignment. Example Timing Coordination Parameter Typical Value Advertising interval 100 ms ( 0x00A0 ) Scan interval 300 ms ( 0x018C ) Scan window 150 ms ( 0x00F0 ) This setup provides good discovery speed and balances scanner energy usage. Notes on Scan Response Timing Scan response packets are only sent if the advertiser receives a scan request . This scan request must be sent while the advertiser is listening , and only during active scanning. The non-scanning time (between windows) is not used for scan response \u2014 in fact, nothing happens during those gaps. This means larger scan windows increase the chance of triggering a scan response successfully. Power Considerations Scanning uses more power than advertising \u2014 so the scanner (usually the central) should be the device with more available energy (e.g., a phone). Peripheral devices (e.g., sensors, wearables) can advertise less frequently to save power and rely on burst scanning from the central. Summary Guidelines Ensure advertising interval \u2264 scan interval Keep scan window large enough to catch at least one advertisement Use scan window \u2248 50\u2013100% of scan interval for faster discovery For low power devices, increase advertising interval and let central scan more aggressively Aside: BLE Address Types Before we continue, let's take a moment to explore the different types of Bluetooth LE addresses. Every BLE device is identified by a 48-bit address , and they are grouped into two main categories: public and random . Random addresses are further split into static , resolvable private , and non-resolvable private types. The type used affects how your device is identified, whether it can be tracked, and whether connections or bonding are possible. 1. Public Address A globally unique address assigned by the manufacturer and stored in the device's hardware (e.g., in FICR on nRF chips). Used automatically unless you override it with a random address or enable privacy. Get the default public address: bt_addr_le_t addr; bt_id_get(&addr, NULL); 2. Random Static Address Does not change across boots \u2014 stable identity. Must follow BLE spec: the most significant two bits of the first byte must be 11 (so the first byte must be between 0xC0 and 0xFF ). Commonly used when you don't have a public address block but need a consistent identity. Set a static random address manually: #include <zephyr/bluetooth/addr.h> bt_addr_le_t addr; bt_addr_le_from_str(\"FF:00:11:22:33:44\", \"random\", &addr); addr.a.val[5] |= 0xC0; // Make sure MSBs are '11' to mark as static random int id = bt_id_create(&addr, NULL); // Must be called before bt_enable() In production, you might derive a unique static random address from the device\u2019s public address or store a pre-generated one in flash/UICR. 3. Resolvable Private Address (RPA) Changes periodically (by default every 15 minutes), but can be resolved by bonded peers using an Identity Resolving Key (IRK). Enables privacy without sacrificing the ability to reconnect or bond. I am currently not sure how to set the RPA manually, but it should be automatically generated by the stack when you enable privacy ( CONFIG_BT_PRIVACY=y ). 4. Non-Resolvable Private Address (NRPA) Also changes periodically, but cannot be resolved \u2014 not bondable or connectable. Useful for anonymous broadcasting (e.g., a privacy-focused beacon). A new NRPA is generated every time you start advertising. Set NRPA explicitly: static const struct bt_le_adv_param *adv_param = BT_LE_ADV_PARAM( BT_LE_ADV_OPT_USE_NRPA, 160, 160, NULL); Connection Callbacks To handle Bluetooth connections in Zephyr, we use the bt_conn_cb structure. This lets us register callback functions to track connection events like when a device connects or disconnects. First, include the necessary header: #include <zephyr/bluetooth/conn.h> Then, declare a connection reference to track the active connection: static struct bt_conn *my_conn = NULL; Basic Callbacks void on_connected(struct bt_conn *conn, uint8_t err) { if (err) { LOG_ERR(\"Connection failed (err %u)\", err); return; } my_conn = bt_conn_ref(conn); } void on_disconnected(struct bt_conn *conn, uint8_t reason) { LOG_INF(\"Disconnected (reason 0x%02x)\", reason); if (my_conn) { bt_conn_unref(my_conn); my_conn = NULL; } } bt_conn_ref() increases the reference count so the connection stays valid. bt_conn_unref() is called on disconnection to release the reference. bt_conn_get_dst() gets the peer device\u2019s address. Registering Callbacks static struct bt_conn_cb connection_callbacks = { .connected = on_connected, .disconnected = on_disconnected, }; bt_conn_cb_register(&connection_callbacks); You must register your callback structure before or after enabling Bluetooth, and before expecting any connection events. Other Available Callbacks in bt_conn_cb You can optionally implement more callbacks: recycled : Called when a connection object is returned to the pool. le_param_req : Called when the peer requests to update connection parameters. Return true to accept or false to reject. le_param_updated : Notifies when connection parameters are updated (interval, latency, timeout). identity_resolved : (If SMP enabled) Notifies when a peer's identity address is resolved from an RPA. security_changed : (If SMP or Classic enabled) Called when connection security changes. remote_info_available : Called when info about the peer (features, roles) is available. le_phy_updated : Notifies when PHY is changed (1M, 2M, coded). le_data_len_updated : Called when the maximum payload size changes. tx_power_report : Reports transmit power changes. subrate_changed : Called when connection subrate settings change. These are mostly optional and only needed for advanced use cases.","title":"BLE-Advertising Connectable"},{"location":"03-ble-advert-connectable/#03-ble-advertising-connectable","text":"To make a device connectable, we need to enable the Bluetooth peripheral role and set the advertising parameters accordingly. Add this to your prj.conf file: CONFIG_BT_PERIPHERAL=y In previous examples, we used the predefined macro BT_LE_ADV_NCONN for non-connectable advertising. To allow connections, we need different parameters like BT_LE_ADV_CONN_ONE_TIME . We can also define our own advertising parameters with the help of the BT_LE_ADV_PARAM() macro: BT_LE_ADV_PARAM(_options, _int_min, _int_max, _peer) _options : A bitmask of advertising options (e.g., connectable, use identity, etc.) _int_min , _int_max : Advertising interval (units of 0.625 ms) _peer : Peer address; set to NULL for undirected advertising Example parameters for connectable advertising: static const struct bt_le_adv_param *adv_param = BT_LE_ADV_PARAM( (BT_LE_ADV_OPT_CONNECTABLE | BT_LE_ADV_OPT_USE_IDENTITY), /* Connectable advertising and use identity address */ BT_GAP_ADV_FAST_INT_MIN_2, /* Min Advertising Interval 100 ms */ BT_GAP_ADV_FAST_INT_MAX_2, /* Max Advertising Interval 150 ms */ NULL); /* Set to NULL for undirected advertising */ Common options flags include: BT_LE_ADV_OPT_CONNECTABLE : Allow devices to connect BT_LE_ADV_OPT_ONE_TIME : Stop advertising after one connection BT_LE_ADV_OPT_USE_IDENTITY : Use the device's identity address (not RPA) BT_LE_ADV_OPT_USE_NAME : Automatically include the GAP device name BT_LE_ADV_OPT_SCANNABLE : Enable scan response data BT_LE_ADV_OPT_EXT_ADV : Use extended advertising features (for longer range or larger data) BT_LE_ADV_OPT_FILTER_SCAN_REQ : Only respond to scanners in the filter list BT_LE_ADV_OPT_FILTER_CONN : Only allow connections from filtered peers This setup allows your device to be discoverable and accept connections from central devices like phones or PCs. However, it will continue to advertise even after a connection is established, which may not be ideal for power consumption or security. To stop advertising after the first connection, add the BT_LE_ADV_OPT_ONE_TIME option.","title":"03 - BLE Advertising: Connectable"},{"location":"03-ble-advert-connectable/#advertising-intervals","text":"The advertising interval controls how often your device broadcasts its advertising packets. It is set using _int_min and _int_max in BT_LE_ADV_PARAM() and is specified in units of 0.625 ms. Valid range : 20 ms to 10.24 seconds Resolution : 0.625 ms steps You can set: - min == max \u2192 Fixed interval (allowed) - min < max \u2192 Interval chosen randomly within that range (typical) A small random delay (0\u201310 ms) is added automatically to help avoid collisions between devices using similar intervals.","title":"Advertising Intervals"},{"location":"03-ble-advert-connectable/#guidelines","text":"Short intervals (~20\u2013100 ms) : Fast discovery, higher power consumption Medium intervals (~150\u2013500 ms) : Balanced power and discovery time (good default) Long intervals (>1 s) : Low power, slower to be discovered Choose an interval based on your application: - For wearables or low-power sensors , favor longer intervals - For pairing mode or quick reconnection , use shorter intervals Some constants are defined in zephyr/bluetooth/gap.h for common intervals:","title":"Guidelines"},{"location":"03-ble-advert-connectable/#gap-advertising-parameters","text":"These are predefined intervals for legacy advertisement (connectable or scannable), used by many macros like BT_LE_ADV_CONN . Macro Hex Time (ms) BT_GAP_ADV_FAST_INT_MIN_1 0x0030 30 BT_GAP_ADV_FAST_INT_MAX_1 0x0060 60 BT_GAP_ADV_FAST_INT_MIN_2 0x00a0 100 BT_GAP_ADV_FAST_INT_MAX_2 0x00f0 150 BT_GAP_ADV_SLOW_INT_MIN 0x0640 1000 BT_GAP_ADV_SLOW_INT_MAX 0x0780 1200","title":"GAP Advertising Parameters"},{"location":"03-ble-advert-connectable/#gap-periodic-advertising-parameters","text":"Periodic advertising is a Bluetooth Low Energy feature introduced in Bluetooth 5 that allows a device to broadcast data at fixed, predictable intervals without requiring a connection. Unlike legacy advertising, which is sent on the primary channels and may be missed if the scanner isn't listening at the right time, periodic advertising uses a synchronizable schedule and is transmitted on secondary channels. This allows scanners to synchronize with the advertiser and receive updates reliably with lower power consumption. It's ideal for broadcasting sensor data , location beacons , or status updates where frequent connections aren't needed but consistent updates are. Macro Hex Time (ms) BT_GAP_PER_ADV_FAST_INT_MIN_1 0x0018 30 BT_GAP_PER_ADV_FAST_INT_MAX_1 0x0030 60 BT_GAP_PER_ADV_FAST_INT_MIN_2 0x0050 100 BT_GAP_PER_ADV_FAST_INT_MAX_2 0x0078 150 BT_GAP_PER_ADV_SLOW_INT_MIN 0x0320 1000 BT_GAP_PER_ADV_SLOW_INT_MAX 0x03C0 1200","title":"GAP Periodic Advertising Parameters"},{"location":"03-ble-advert-connectable/#gap-scan-parameters","text":"These define standard scan intervals and windows. The interval is how often scanning starts, and the window is how long each scan lasts. Macro Hex Time (ms) BT_GAP_SCAN_FAST_INTERVAL_MIN 0x0030 30 BT_GAP_SCAN_FAST_INTERVAL 0x0060 60 BT_GAP_SCAN_FAST_WINDOW 0x0030 30 BT_GAP_SCAN_SLOW_INTERVAL_1 0x0800 1280 BT_GAP_SCAN_SLOW_WINDOW_1 0x0012 11.25 BT_GAP_SCAN_SLOW_INTERVAL_2 0x1000 2560 BT_GAP_SCAN_SLOW_WINDOW_2 0x0012 11.25","title":"GAP Scan Parameters"},{"location":"03-ble-advert-connectable/#gap-initial-connection-parameters","text":"These define intervals used when initiating a connection (i.e., when a central connects to a peripheral). Macro Hex Time (ms) BT_GAP_INIT_CONN_INT_MIN 0x0018 30 BT_GAP_INIT_CONN_INT_MAX 0x0028 50","title":"GAP Initial Connection Parameters"},{"location":"03-ble-advert-connectable/#additional-notes-on-timing-coordination","text":"When both the advertiser and scanner are under your control, you can optimize their timing parameters to strike a balance between discovery speed , power consumption , and reliability . This is especially useful in scenarios like proprietary ecosystems, closed systems, or when designing both ends of a BLE link (e.g., a wearable + smartphone app).","title":"Additional Notes on Timing Coordination"},{"location":"03-ble-advert-connectable/#understanding-scan-interval-and-scan-window","text":"Scan interval is how often the scanner initiates a scan cycle. Scan window is how long the scanner listens during each scan interval. Both range from 2.5 ms to 10.24 seconds in 0.625 ms steps. In each scan interval, the scanner will scan one of the three primary advertising channels. After the interval ends, it switches to the next channel. If the scan window is equal to the scan interval, the scanner is scanning continuously (100% duty cycle). If the window is shorter than the interval, it means the scanner is off part of the time \u2014 which saves power. For example, if scan interval = 100 ms and window = 20 ms, the scanner is listening only 20% of the time.","title":"Understanding Scan Interval and Scan Window"},{"location":"03-ble-advert-connectable/#coordinating-with-advertising-intervals","text":"To improve the chances of the scanner receiving advertising packets: The advertising interval should be shorter than or equal to the scan interval. This increases the probability that an advertisement will occur during the scan window. A good rule of thumb is: advertising interval \u2264 scan interval - scan window This ensures that at least one advertisement falls within an active scan window over multiple cycles. You can also align timing using multiples, such as: - Scan interval = 3 \u00d7 advertising interval - Scan window = 50\u201380% of scan interval (for reasonable duty cycle) This is not a strict rule, but it helps statistically reduce missed advertisements due to phase misalignment.","title":"Coordinating With Advertising Intervals"},{"location":"03-ble-advert-connectable/#example-timing-coordination","text":"Parameter Typical Value Advertising interval 100 ms ( 0x00A0 ) Scan interval 300 ms ( 0x018C ) Scan window 150 ms ( 0x00F0 ) This setup provides good discovery speed and balances scanner energy usage.","title":"Example Timing Coordination"},{"location":"03-ble-advert-connectable/#notes-on-scan-response-timing","text":"Scan response packets are only sent if the advertiser receives a scan request . This scan request must be sent while the advertiser is listening , and only during active scanning. The non-scanning time (between windows) is not used for scan response \u2014 in fact, nothing happens during those gaps. This means larger scan windows increase the chance of triggering a scan response successfully.","title":"Notes on Scan Response Timing"},{"location":"03-ble-advert-connectable/#power-considerations","text":"Scanning uses more power than advertising \u2014 so the scanner (usually the central) should be the device with more available energy (e.g., a phone). Peripheral devices (e.g., sensors, wearables) can advertise less frequently to save power and rely on burst scanning from the central.","title":"Power Considerations"},{"location":"03-ble-advert-connectable/#summary-guidelines","text":"Ensure advertising interval \u2264 scan interval Keep scan window large enough to catch at least one advertisement Use scan window \u2248 50\u2013100% of scan interval for faster discovery For low power devices, increase advertising interval and let central scan more aggressively","title":"Summary Guidelines"},{"location":"03-ble-advert-connectable/#aside-ble-address-types","text":"Before we continue, let's take a moment to explore the different types of Bluetooth LE addresses. Every BLE device is identified by a 48-bit address , and they are grouped into two main categories: public and random . Random addresses are further split into static , resolvable private , and non-resolvable private types. The type used affects how your device is identified, whether it can be tracked, and whether connections or bonding are possible.","title":"Aside: BLE Address Types"},{"location":"03-ble-advert-connectable/#1-public-address","text":"A globally unique address assigned by the manufacturer and stored in the device's hardware (e.g., in FICR on nRF chips). Used automatically unless you override it with a random address or enable privacy.","title":"1. Public Address"},{"location":"03-ble-advert-connectable/#get-the-default-public-address","text":"bt_addr_le_t addr; bt_id_get(&addr, NULL);","title":"Get the default public address:"},{"location":"03-ble-advert-connectable/#2-random-static-address","text":"Does not change across boots \u2014 stable identity. Must follow BLE spec: the most significant two bits of the first byte must be 11 (so the first byte must be between 0xC0 and 0xFF ). Commonly used when you don't have a public address block but need a consistent identity.","title":"2. Random Static Address"},{"location":"03-ble-advert-connectable/#set-a-static-random-address-manually","text":"#include <zephyr/bluetooth/addr.h> bt_addr_le_t addr; bt_addr_le_from_str(\"FF:00:11:22:33:44\", \"random\", &addr); addr.a.val[5] |= 0xC0; // Make sure MSBs are '11' to mark as static random int id = bt_id_create(&addr, NULL); // Must be called before bt_enable() In production, you might derive a unique static random address from the device\u2019s public address or store a pre-generated one in flash/UICR.","title":"Set a static random address manually:"},{"location":"03-ble-advert-connectable/#3-resolvable-private-address-rpa","text":"Changes periodically (by default every 15 minutes), but can be resolved by bonded peers using an Identity Resolving Key (IRK). Enables privacy without sacrificing the ability to reconnect or bond. I am currently not sure how to set the RPA manually, but it should be automatically generated by the stack when you enable privacy ( CONFIG_BT_PRIVACY=y ).","title":"3. Resolvable Private Address (RPA)"},{"location":"03-ble-advert-connectable/#4-non-resolvable-private-address-nrpa","text":"Also changes periodically, but cannot be resolved \u2014 not bondable or connectable. Useful for anonymous broadcasting (e.g., a privacy-focused beacon). A new NRPA is generated every time you start advertising.","title":"4. Non-Resolvable Private Address (NRPA)"},{"location":"03-ble-advert-connectable/#set-nrpa-explicitly","text":"static const struct bt_le_adv_param *adv_param = BT_LE_ADV_PARAM( BT_LE_ADV_OPT_USE_NRPA, 160, 160, NULL);","title":"Set NRPA explicitly:"},{"location":"03-ble-advert-connectable/#connection-callbacks","text":"To handle Bluetooth connections in Zephyr, we use the bt_conn_cb structure. This lets us register callback functions to track connection events like when a device connects or disconnects. First, include the necessary header: #include <zephyr/bluetooth/conn.h> Then, declare a connection reference to track the active connection: static struct bt_conn *my_conn = NULL;","title":"Connection Callbacks"},{"location":"03-ble-advert-connectable/#basic-callbacks","text":"void on_connected(struct bt_conn *conn, uint8_t err) { if (err) { LOG_ERR(\"Connection failed (err %u)\", err); return; } my_conn = bt_conn_ref(conn); } void on_disconnected(struct bt_conn *conn, uint8_t reason) { LOG_INF(\"Disconnected (reason 0x%02x)\", reason); if (my_conn) { bt_conn_unref(my_conn); my_conn = NULL; } } bt_conn_ref() increases the reference count so the connection stays valid. bt_conn_unref() is called on disconnection to release the reference. bt_conn_get_dst() gets the peer device\u2019s address.","title":"Basic Callbacks"},{"location":"03-ble-advert-connectable/#registering-callbacks","text":"static struct bt_conn_cb connection_callbacks = { .connected = on_connected, .disconnected = on_disconnected, }; bt_conn_cb_register(&connection_callbacks); You must register your callback structure before or after enabling Bluetooth, and before expecting any connection events.","title":"Registering Callbacks"},{"location":"03-ble-advert-connectable/#other-available-callbacks-in-bt_conn_cb","text":"You can optionally implement more callbacks: recycled : Called when a connection object is returned to the pool. le_param_req : Called when the peer requests to update connection parameters. Return true to accept or false to reject. le_param_updated : Notifies when connection parameters are updated (interval, latency, timeout). identity_resolved : (If SMP enabled) Notifies when a peer's identity address is resolved from an RPA. security_changed : (If SMP or Classic enabled) Called when connection security changes. remote_info_available : Called when info about the peer (features, roles) is available. le_phy_updated : Notifies when PHY is changed (1M, 2M, coded). le_data_len_updated : Called when the maximum payload size changes. tx_power_report : Reports transmit power changes. subrate_changed : Called when connection subrate settings change. These are mostly optional and only needed for advanced use cases.","title":"Other Available Callbacks in bt_conn_cb"},{"location":"04-ble-conn-params/","text":"04 - BLE Connection Parameters Core Connection Parameters These parameters were part of the original Bluetooth LE specification , and are exchanged during connection establishment. They define the timing and reliability of the connection. 1. Connection Interval Time between consecutive connection events (when devices wake up to communicate). Typical range: 7.5 ms to 4 s, in steps of 1.25 ms. Lower values = lower latency, higher power use. Higher values = longer sleep time, lower power use. 2. Supervision Timeout Max time allowed without successful packet reception before the connection is considered lost. Typical range: 100 ms to 32 s, in steps of 10 ms. Must be > (1 + peripheral latency) \u00d7 connection interval \u00d7 2. 3. Peripheral Latency Number of connection events the peripheral can skip if it has nothing to send. Typical values: 0\u2013499 (unitless). Allows the peripheral to save power while remaining in the connection. Note: The name is misleading \u2014 this is not a time duration , but a count of skipped events. In Action In the on_connect callback, we can print the 3 connection parameters: static void on_conn_established(struct bt_conn *conn, uint8_t err) { // ... other code active_conn = bt_conn_ref(conn); struct bt_conn_info info; if (bt_conn_get_info(conn, &info) == 0) { double int_ms = info.le.interval * 1.25; uint16_t timeout_ms = info.le.timeout * 10; LOG_INF(\"Initial conn params: %.2f ms, latency %u, timeout %u ms\", int_ms, info.le.latency, timeout_ms); } // ... other code } Note: Floating point math is not enabled by default, so we need to add CONFIG_FPU=y to the prj.conf file. Those parameters are typically first determined by the central device, and then the peripheral can request changes. To define our (i.e., the peripheral's) connection parameters, we can override the default values in the prj.conf file: # Set preferred connection parameters (units: 1.25ms for interval, 10ms for timeout) CONFIG_BT_PERIPHERAL_PREF_MIN_INT=320 CONFIG_BT_PERIPHERAL_PREF_MAX_INT=400 CONFIG_BT_PERIPHERAL_PREF_LATENCY=3 CONFIG_BT_PERIPHERAL_PREF_TIMEOUT=500 CONFIG_BT_GAP_AUTO_UPDATE_CONN_PARAMS=y The last line may be redundant, as it is enabled by default. It allows the peripheral to request a change in connection parameters after the initial connection. To get notified of the new parameters, we can implement the on_conn_param_update callback: static void handle_conn_param_change(struct bt_conn *conn, uint16_t interval, uint16_t latency, uint16_t timeout) { double interval_ms = interval * 1.25; uint16_t timeout_ms = timeout * 10; LOG_INF(\"Params changed: %.2f ms, latency %u, timeout %u ms\", interval_ms, latency, timeout_ms); } PHY Radio Modes The default mode is 1M PHY (1 Mbps), which is used for compatibility. 2M PHY (2 Mbps): Doubles throughput, reduces time on air, but may shorten range. Coded PHY : Increases range using redundancy, but at a lower data rate (125 kbps or 500 kbps). In Action First, we need to enable the PHY feature in the prj.conf file: CONFIG_BT_USER_PHY_UPDATE=y We can set the PHY mode again in the on_connect callback: static void on_conn_established(struct bt_conn *conn, uint8_t err) { // ... other code const struct bt_conn_le_phy_param phy_pref = { .options = BT_CONN_LE_PHY_OPT_NONE, .pref_rx_phy = BT_GAP_LE_PHY_2M, .pref_tx_phy = BT_GAP_LE_PHY_2M, }; int err = bt_conn_le_phy_update(conn, &phy_pref); if (err) { LOG_ERR(\"PHY update failed (%d)\", err); } // ... other code } To get notified of the PHY change, we can implement the on_phy_update callback: static void handle_phy_change(struct bt_conn *conn, struct bt_conn_le_phy_info *info) { switch (info->tx_phy) { case BT_CONN_LE_TX_POWER_PHY_1M: LOG_INF(\"PHY switched to 1M\"); break; case BT_CONN_LE_TX_POWER_PHY_2M: LOG_INF(\"PHY switched to 2M\"); break; case BT_CONN_LE_TX_POWER_PHY_CODED_S8: LOG_INF(\"PHY switched to Long Range\"); break; default: LOG_INF(\"PHY changed to unknown mode\"); break; } } Data Length vs MTU To understand how these differ, it's helpful to recall the Bluetooth LE stack layers : - GATT (Generic Attribute Profile): Application layer. You usually interact here. - L2CAP : Handles segmentation and reassembly of packets. - Link Layer : The lowest level; handles actual radio transmission. MTU (Maximum Transmission Unit) Maximum size of a single GATT operation (covered in next page). Default: 23 bytes. Can be increased after connection using MTU Exchange . Operates at the GATT / L2CAP level . You configure the maximum value with: Kconfig CONFIG_BT_L2CAP_TX_MTU=247 Data Length Maximum size of a single Link Layer PDU (packet). Default: 27 bytes. With BLE 4.2+, it can go up to 251 bytes . Controlled via Data Length Extension (DLE) . Even with a high MTU, a small data length will result in packet fragmentation . Configure this with: Kconfig CONFIG_BT_CTLR_DATA_LENGTH_MAX=251 CONFIG_BT_BUF_ACL_TX_SIZE=251 CONFIG_BT_BUF_ACL_RX_SIZE=251 Negotiating MTU and Data Length in Code Make sure data length updates are enabled: CONFIG_BT_USER_DATA_LEN_UPDATE=y Then, in your on_connected() callback: // Request a data length update (TX only) struct bt_conn_le_data_len_param len_params = { .tx_max_len = BT_GAP_DATA_LEN_MAX, // Usually 251 .tx_max_time = BT_GAP_DATA_TIME_MAX, // Usually 0x4290 (17040 \u00b5s) }; int err = bt_conn_le_data_len_update(conn, &len_params); if (err) { LOG_ERR(\"Failed to update data length (%d)\", err); } Why only TX? Because you can only propose values for your side of the connection. The peer will reply with what it supports for both TX and RX. The callback later gives you the final values for both ends. To negotiate the MTU: // Start MTU exchange \u2014 no need to specify desired MTU static struct bt_gatt_exchange_params params = { .func = mtu_exchange_cb // Called when negotiation is done }; err = bt_gatt_exchange_mtu(conn, &params); if (err) { LOG_ERR(\"MTU exchange failed (%d)\", err); } \ud83d\udcdd Why don't we set a value in params ? You don\u2019t pass the MTU manually. The stack reads CONFIG_BT_L2CAP_TX_MTU and automatically includes that in the ATT_Exchange_MTU_Request . The negotiated MTU is then: c min(our_mtu, peer_mtu) The callback: static void mtu_exchange_cb(struct bt_conn *conn, uint8_t err, struct bt_gatt_exchange_params *params) { if (!err) { uint16_t app_mtu = bt_gatt_get_mtu(conn) - 3; // 3 bytes = ATT header LOG_INF(\"MTU negotiated: %u bytes\", app_mtu); } else { LOG_ERR(\"MTU exchange failed (ATT err %u)\", err); } } Result: Callback confirms what was accepted static void handle_data_len_change(struct bt_conn *conn, struct bt_conn_le_data_len_info *info) { LOG_INF(\"Data len: TX=%u (%uus), RX=%u (%uus)\", info->tx_max_len, info->tx_max_time, info->rx_max_len, info->rx_max_time); } \ud83d\udcdd This tells you what both sides agreed on after negotiation \u2014 your request vs. what the peer supports. - TX: What you send - RX: What you receive","title":"BLE-Connection Parameters"},{"location":"04-ble-conn-params/#04-ble-connection-parameters","text":"","title":"04 - BLE Connection Parameters"},{"location":"04-ble-conn-params/#core-connection-parameters","text":"These parameters were part of the original Bluetooth LE specification , and are exchanged during connection establishment. They define the timing and reliability of the connection.","title":"Core Connection Parameters"},{"location":"04-ble-conn-params/#1-connection-interval","text":"Time between consecutive connection events (when devices wake up to communicate). Typical range: 7.5 ms to 4 s, in steps of 1.25 ms. Lower values = lower latency, higher power use. Higher values = longer sleep time, lower power use.","title":"1. Connection Interval"},{"location":"04-ble-conn-params/#2-supervision-timeout","text":"Max time allowed without successful packet reception before the connection is considered lost. Typical range: 100 ms to 32 s, in steps of 10 ms. Must be > (1 + peripheral latency) \u00d7 connection interval \u00d7 2.","title":"2. Supervision Timeout"},{"location":"04-ble-conn-params/#3-peripheral-latency","text":"Number of connection events the peripheral can skip if it has nothing to send. Typical values: 0\u2013499 (unitless). Allows the peripheral to save power while remaining in the connection. Note: The name is misleading \u2014 this is not a time duration , but a count of skipped events.","title":"3. Peripheral Latency"},{"location":"04-ble-conn-params/#in-action","text":"In the on_connect callback, we can print the 3 connection parameters: static void on_conn_established(struct bt_conn *conn, uint8_t err) { // ... other code active_conn = bt_conn_ref(conn); struct bt_conn_info info; if (bt_conn_get_info(conn, &info) == 0) { double int_ms = info.le.interval * 1.25; uint16_t timeout_ms = info.le.timeout * 10; LOG_INF(\"Initial conn params: %.2f ms, latency %u, timeout %u ms\", int_ms, info.le.latency, timeout_ms); } // ... other code } Note: Floating point math is not enabled by default, so we need to add CONFIG_FPU=y to the prj.conf file. Those parameters are typically first determined by the central device, and then the peripheral can request changes. To define our (i.e., the peripheral's) connection parameters, we can override the default values in the prj.conf file: # Set preferred connection parameters (units: 1.25ms for interval, 10ms for timeout) CONFIG_BT_PERIPHERAL_PREF_MIN_INT=320 CONFIG_BT_PERIPHERAL_PREF_MAX_INT=400 CONFIG_BT_PERIPHERAL_PREF_LATENCY=3 CONFIG_BT_PERIPHERAL_PREF_TIMEOUT=500 CONFIG_BT_GAP_AUTO_UPDATE_CONN_PARAMS=y The last line may be redundant, as it is enabled by default. It allows the peripheral to request a change in connection parameters after the initial connection. To get notified of the new parameters, we can implement the on_conn_param_update callback: static void handle_conn_param_change(struct bt_conn *conn, uint16_t interval, uint16_t latency, uint16_t timeout) { double interval_ms = interval * 1.25; uint16_t timeout_ms = timeout * 10; LOG_INF(\"Params changed: %.2f ms, latency %u, timeout %u ms\", interval_ms, latency, timeout_ms); }","title":"In Action"},{"location":"04-ble-conn-params/#phy-radio-modes","text":"The default mode is 1M PHY (1 Mbps), which is used for compatibility. 2M PHY (2 Mbps): Doubles throughput, reduces time on air, but may shorten range. Coded PHY : Increases range using redundancy, but at a lower data rate (125 kbps or 500 kbps).","title":"PHY Radio Modes"},{"location":"04-ble-conn-params/#in-action_1","text":"First, we need to enable the PHY feature in the prj.conf file: CONFIG_BT_USER_PHY_UPDATE=y We can set the PHY mode again in the on_connect callback: static void on_conn_established(struct bt_conn *conn, uint8_t err) { // ... other code const struct bt_conn_le_phy_param phy_pref = { .options = BT_CONN_LE_PHY_OPT_NONE, .pref_rx_phy = BT_GAP_LE_PHY_2M, .pref_tx_phy = BT_GAP_LE_PHY_2M, }; int err = bt_conn_le_phy_update(conn, &phy_pref); if (err) { LOG_ERR(\"PHY update failed (%d)\", err); } // ... other code } To get notified of the PHY change, we can implement the on_phy_update callback: static void handle_phy_change(struct bt_conn *conn, struct bt_conn_le_phy_info *info) { switch (info->tx_phy) { case BT_CONN_LE_TX_POWER_PHY_1M: LOG_INF(\"PHY switched to 1M\"); break; case BT_CONN_LE_TX_POWER_PHY_2M: LOG_INF(\"PHY switched to 2M\"); break; case BT_CONN_LE_TX_POWER_PHY_CODED_S8: LOG_INF(\"PHY switched to Long Range\"); break; default: LOG_INF(\"PHY changed to unknown mode\"); break; } }","title":"In Action"},{"location":"04-ble-conn-params/#data-length-vs-mtu","text":"To understand how these differ, it's helpful to recall the Bluetooth LE stack layers : - GATT (Generic Attribute Profile): Application layer. You usually interact here. - L2CAP : Handles segmentation and reassembly of packets. - Link Layer : The lowest level; handles actual radio transmission.","title":"Data Length vs MTU"},{"location":"04-ble-conn-params/#mtu-maximum-transmission-unit","text":"Maximum size of a single GATT operation (covered in next page). Default: 23 bytes. Can be increased after connection using MTU Exchange . Operates at the GATT / L2CAP level . You configure the maximum value with: Kconfig CONFIG_BT_L2CAP_TX_MTU=247","title":"MTU (Maximum Transmission Unit)"},{"location":"04-ble-conn-params/#data-length","text":"Maximum size of a single Link Layer PDU (packet). Default: 27 bytes. With BLE 4.2+, it can go up to 251 bytes . Controlled via Data Length Extension (DLE) . Even with a high MTU, a small data length will result in packet fragmentation . Configure this with: Kconfig CONFIG_BT_CTLR_DATA_LENGTH_MAX=251 CONFIG_BT_BUF_ACL_TX_SIZE=251 CONFIG_BT_BUF_ACL_RX_SIZE=251","title":"Data Length"},{"location":"04-ble-conn-params/#negotiating-mtu-and-data-length-in-code","text":"Make sure data length updates are enabled: CONFIG_BT_USER_DATA_LEN_UPDATE=y Then, in your on_connected() callback: // Request a data length update (TX only) struct bt_conn_le_data_len_param len_params = { .tx_max_len = BT_GAP_DATA_LEN_MAX, // Usually 251 .tx_max_time = BT_GAP_DATA_TIME_MAX, // Usually 0x4290 (17040 \u00b5s) }; int err = bt_conn_le_data_len_update(conn, &len_params); if (err) { LOG_ERR(\"Failed to update data length (%d)\", err); } Why only TX? Because you can only propose values for your side of the connection. The peer will reply with what it supports for both TX and RX. The callback later gives you the final values for both ends. To negotiate the MTU: // Start MTU exchange \u2014 no need to specify desired MTU static struct bt_gatt_exchange_params params = { .func = mtu_exchange_cb // Called when negotiation is done }; err = bt_gatt_exchange_mtu(conn, &params); if (err) { LOG_ERR(\"MTU exchange failed (%d)\", err); } \ud83d\udcdd Why don't we set a value in params ? You don\u2019t pass the MTU manually. The stack reads CONFIG_BT_L2CAP_TX_MTU and automatically includes that in the ATT_Exchange_MTU_Request . The negotiated MTU is then: c min(our_mtu, peer_mtu) The callback: static void mtu_exchange_cb(struct bt_conn *conn, uint8_t err, struct bt_gatt_exchange_params *params) { if (!err) { uint16_t app_mtu = bt_gatt_get_mtu(conn) - 3; // 3 bytes = ATT header LOG_INF(\"MTU negotiated: %u bytes\", app_mtu); } else { LOG_ERR(\"MTU exchange failed (ATT err %u)\", err); } }","title":"Negotiating MTU and Data Length in Code"},{"location":"04-ble-conn-params/#result-callback-confirms-what-was-accepted","text":"static void handle_data_len_change(struct bt_conn *conn, struct bt_conn_le_data_len_info *info) { LOG_INF(\"Data len: TX=%u (%uus), RX=%u (%uus)\", info->tx_max_len, info->tx_max_time, info->rx_max_len, info->rx_max_time); } \ud83d\udcdd This tells you what both sides agreed on after negotiation \u2014 your request vs. what the peer supports. - TX: What you send - RX: What you receive","title":"Result: Callback confirms what was accepted"},{"location":"05-ble-gatt-client/","text":"05 - BLE GATT Client-Initiated Operations In the GATT protocol, the server holds the data. The client can request the server to perform operations such as read , write , or write without response \u2014 these are known as client-initiated operations . Alternatively, the client can subscribe to notifications or indications , which are server-initiated operations . This note focuses on client-initiated operations . The server-side implementation will be covered in a later note. We will walk through how to define a custom 128-bit UUID GATT service with both readable and writable characteristics in Zephyr, using the Nordic SDK style. 1. Create a File: my_service.h This header will define the UUIDs, callback types, and initialization function needed for the custom service. 2. Encode the UUIDs Using BT_UUID_128_ENCODE Zephyr provides a helper macro to define a 128-bit UUID: BT_UUID_128_ENCODE(w32, w1, w2, w3, w48) This macro converts your UUID into little-endian byte order suitable for Zephyr\u2019s internal structures. It's commonly used when defining: - Service UUIDs - Characteristic UUIDs - Advertising UUIDs Parameters: Param Size Description w32 32b First field of the UUID w1 16b Second field w2 16b Third field w3 16b Fourth field w48 48b Final field (usually vendor part) Just take your UUID, replace the dashes with commas, and prefix each value with 0x . Example: If your 128-bit UUID is: 12345678-9abc-def0-1234-56789abcdef0 You can encode it like: #define BT_UUID_MY_SERVICE_VAL \\ BT_UUID_128_ENCODE(0x12345678, 0x9abc, 0xdef0, 0x1234, 0x56789abcdef0) And then define characteristics with similar base UUIDs: #define BT_UUID_MY_CHAR_READ_VAL \\ BT_UUID_128_ENCODE(0x12345678, 0x9abc, 0xdef0, 0x1234, 0x56789abcdef1) #define BT_UUID_MY_CHAR_WRITE_VAL \\ BT_UUID_128_ENCODE(0x12345678, 0x9abc, 0xdef0, 0x1234, 0x56789abcdef2) \ud83d\udca1 Naming convention (rule of thumb): - The first few fields can vary by purpose (e.g., 1 service, multiple characteristics). - The final 48 bits are often treated as the vendor-defined base. - No strict rules \u2014 just make sure they\u2019re unique. 3. Declare the UUIDs Encoding a UUID gives you a byte array. To use them in APIs like BT_GATT_PRIMARY_SERVICE() or BT_GATT_CHARACTERISTIC() , you must wrap them with BT_UUID_DECLARE_128() : #define BT_UUID_MY_SERVICE BT_UUID_DECLARE_128(BT_UUID_MY_SERVICE_VAL) #define BT_UUID_MY_CHAR_READ BT_UUID_DECLARE_128(BT_UUID_MY_CHAR_READ_VAL) #define BT_UUID_MY_CHAR_WRITE BT_UUID_DECLARE_128(BT_UUID_MY_CHAR_WRITE_VAL) This declares each UUID as a const struct bt_uuid * that can be used with Zephyr\u2019s GATT API. 4. Create a File: my_service.c This file implements the callbacks, the internal state, and defines the GATT service. 5. Implement the Read Callback Include the needed headers: #include <zephyr/bluetooth/bluetooth.h> #include <zephyr/bluetooth/gatt.h> Implement the read callback: static uint8_t stored_value; static ssize_t on_read(struct bt_conn *conn, const struct bt_gatt_attr *attr, void *buf, uint16_t len, uint16_t offset) { LOG_INF(\"Read request received\"); return bt_gatt_attr_read(conn, attr, buf, len, offset, &stored_value, sizeof(stored_value)); } bt_gatt_attr_read() is a helper that reads from a memory buffer and does bounds checking for you. 6. Implement the Write Callback static struct my_service_cb service_cb; static ssize_t on_write(struct bt_conn *conn, const struct bt_gatt_attr *attr, const void *buf, uint16_t len, uint16_t offset, uint8_t flags) { if (offset != 0 || len != 1) { return BT_GATT_ERR(BT_ATT_ERR_INVALID_ATTRIBUTE_LEN); } uint8_t val = *((uint8_t *)buf); stored_value = val; LOG_INF(\"New value written: %d\", stored_value); if (service_cb.on_write) { service_cb.on_write(val); } return len; } You can choose to act immediately on the written value, or store it for later use. 7. Define a Callback Struct and Init Function Define the callback type and storage: typedef void (*my_write_cb_t)(uint8_t new_value); struct my_service_cb { my_write_cb_t on_write; }; Then implement a simple init function: int my_service_init(struct my_service_cb *cb) { if (cb) { service_cb = *cb; } LOG_INF(\"Custom service initialized\"); return 0; } This lets users register custom application logic on writes. 8. Define the GATT Service Declare your service and characteristics using BT_GATT_SERVICE_DEFINE : BT_GATT_SERVICE_DEFINE(my_svc, BT_GATT_PRIMARY_SERVICE(BT_UUID_MY_SERVICE), BT_GATT_CHARACTERISTIC(BT_UUID_MY_CHAR_READ, BT_GATT_CHRC_READ, BT_GATT_PERM_READ, on_read, NULL, &stored_value), BT_GATT_CHARACTERISTIC(BT_UUID_MY_CHAR_WRITE, BT_GATT_CHRC_WRITE, BT_GATT_PERM_WRITE, NULL, on_write, NULL) ); 9. Use the Service in main.c Register your service in main() : #include \"my_service.h\" void my_write_handler(uint8_t value) { LOG_INF(\"Value changed by client to %d\", value); } void main(void) { bt_enable(NULL); struct my_service_cb cb = { .on_write = my_write_handler, }; my_service_init(&cb); bt_le_adv_start(BT_LE_ADV_CONN, ad, ARRAY_SIZE(ad), sd, ARRAY_SIZE(sd)); }","title":"BLE-GATT Client Operations"},{"location":"05-ble-gatt-client/#05-ble-gatt-client-initiated-operations","text":"In the GATT protocol, the server holds the data. The client can request the server to perform operations such as read , write , or write without response \u2014 these are known as client-initiated operations . Alternatively, the client can subscribe to notifications or indications , which are server-initiated operations . This note focuses on client-initiated operations . The server-side implementation will be covered in a later note. We will walk through how to define a custom 128-bit UUID GATT service with both readable and writable characteristics in Zephyr, using the Nordic SDK style.","title":"05 - BLE GATT Client-Initiated Operations"},{"location":"05-ble-gatt-client/#1-create-a-file-my_serviceh","text":"This header will define the UUIDs, callback types, and initialization function needed for the custom service.","title":"1. Create a File: my_service.h"},{"location":"05-ble-gatt-client/#2-encode-the-uuids-using-bt_uuid_128_encode","text":"Zephyr provides a helper macro to define a 128-bit UUID: BT_UUID_128_ENCODE(w32, w1, w2, w3, w48) This macro converts your UUID into little-endian byte order suitable for Zephyr\u2019s internal structures. It's commonly used when defining: - Service UUIDs - Characteristic UUIDs - Advertising UUIDs","title":"2. Encode the UUIDs Using BT_UUID_128_ENCODE"},{"location":"05-ble-gatt-client/#parameters","text":"Param Size Description w32 32b First field of the UUID w1 16b Second field w2 16b Third field w3 16b Fourth field w48 48b Final field (usually vendor part) Just take your UUID, replace the dashes with commas, and prefix each value with 0x .","title":"Parameters:"},{"location":"05-ble-gatt-client/#example","text":"If your 128-bit UUID is: 12345678-9abc-def0-1234-56789abcdef0 You can encode it like: #define BT_UUID_MY_SERVICE_VAL \\ BT_UUID_128_ENCODE(0x12345678, 0x9abc, 0xdef0, 0x1234, 0x56789abcdef0) And then define characteristics with similar base UUIDs: #define BT_UUID_MY_CHAR_READ_VAL \\ BT_UUID_128_ENCODE(0x12345678, 0x9abc, 0xdef0, 0x1234, 0x56789abcdef1) #define BT_UUID_MY_CHAR_WRITE_VAL \\ BT_UUID_128_ENCODE(0x12345678, 0x9abc, 0xdef0, 0x1234, 0x56789abcdef2) \ud83d\udca1 Naming convention (rule of thumb): - The first few fields can vary by purpose (e.g., 1 service, multiple characteristics). - The final 48 bits are often treated as the vendor-defined base. - No strict rules \u2014 just make sure they\u2019re unique.","title":"Example:"},{"location":"05-ble-gatt-client/#3-declare-the-uuids","text":"Encoding a UUID gives you a byte array. To use them in APIs like BT_GATT_PRIMARY_SERVICE() or BT_GATT_CHARACTERISTIC() , you must wrap them with BT_UUID_DECLARE_128() : #define BT_UUID_MY_SERVICE BT_UUID_DECLARE_128(BT_UUID_MY_SERVICE_VAL) #define BT_UUID_MY_CHAR_READ BT_UUID_DECLARE_128(BT_UUID_MY_CHAR_READ_VAL) #define BT_UUID_MY_CHAR_WRITE BT_UUID_DECLARE_128(BT_UUID_MY_CHAR_WRITE_VAL) This declares each UUID as a const struct bt_uuid * that can be used with Zephyr\u2019s GATT API.","title":"3. Declare the UUIDs"},{"location":"05-ble-gatt-client/#4-create-a-file-my_servicec","text":"This file implements the callbacks, the internal state, and defines the GATT service.","title":"4. Create a File: my_service.c"},{"location":"05-ble-gatt-client/#5-implement-the-read-callback","text":"Include the needed headers: #include <zephyr/bluetooth/bluetooth.h> #include <zephyr/bluetooth/gatt.h> Implement the read callback: static uint8_t stored_value; static ssize_t on_read(struct bt_conn *conn, const struct bt_gatt_attr *attr, void *buf, uint16_t len, uint16_t offset) { LOG_INF(\"Read request received\"); return bt_gatt_attr_read(conn, attr, buf, len, offset, &stored_value, sizeof(stored_value)); } bt_gatt_attr_read() is a helper that reads from a memory buffer and does bounds checking for you.","title":"5. Implement the Read Callback"},{"location":"05-ble-gatt-client/#6-implement-the-write-callback","text":"static struct my_service_cb service_cb; static ssize_t on_write(struct bt_conn *conn, const struct bt_gatt_attr *attr, const void *buf, uint16_t len, uint16_t offset, uint8_t flags) { if (offset != 0 || len != 1) { return BT_GATT_ERR(BT_ATT_ERR_INVALID_ATTRIBUTE_LEN); } uint8_t val = *((uint8_t *)buf); stored_value = val; LOG_INF(\"New value written: %d\", stored_value); if (service_cb.on_write) { service_cb.on_write(val); } return len; } You can choose to act immediately on the written value, or store it for later use.","title":"6. Implement the Write Callback"},{"location":"05-ble-gatt-client/#7-define-a-callback-struct-and-init-function","text":"Define the callback type and storage: typedef void (*my_write_cb_t)(uint8_t new_value); struct my_service_cb { my_write_cb_t on_write; }; Then implement a simple init function: int my_service_init(struct my_service_cb *cb) { if (cb) { service_cb = *cb; } LOG_INF(\"Custom service initialized\"); return 0; } This lets users register custom application logic on writes.","title":"7. Define a Callback Struct and Init Function"},{"location":"05-ble-gatt-client/#8-define-the-gatt-service","text":"Declare your service and characteristics using BT_GATT_SERVICE_DEFINE : BT_GATT_SERVICE_DEFINE(my_svc, BT_GATT_PRIMARY_SERVICE(BT_UUID_MY_SERVICE), BT_GATT_CHARACTERISTIC(BT_UUID_MY_CHAR_READ, BT_GATT_CHRC_READ, BT_GATT_PERM_READ, on_read, NULL, &stored_value), BT_GATT_CHARACTERISTIC(BT_UUID_MY_CHAR_WRITE, BT_GATT_CHRC_WRITE, BT_GATT_PERM_WRITE, NULL, on_write, NULL) );","title":"8. Define the GATT Service"},{"location":"05-ble-gatt-client/#9-use-the-service-in-mainc","text":"Register your service in main() : #include \"my_service.h\" void my_write_handler(uint8_t value) { LOG_INF(\"Value changed by client to %d\", value); } void main(void) { bt_enable(NULL); struct my_service_cb cb = { .on_write = my_write_handler, }; my_service_init(&cb); bt_le_adv_start(BT_LE_ADV_CONN, ad, ARRAY_SIZE(ad), sd, ARRAY_SIZE(sd)); }","title":"9. Use the Service in main.c"},{"location":"06-ble-gatt-server/","text":"06 - BLE GATT Server-Initiated Operations Before diving into server-initiated operations like notifications and indications , it\u2019s important to understand the layers beneath them: ATT and GATT . These layers form the foundation of BLE\u2019s server-client communication model. We want to get comfortable with GATT , as it\u2019s the layer most application developers interact with. But beneath GATT lies ATT , which provides the raw data transport mechanism. ATT (Attribute Protocol) ATT defines a minimal protocol for exposing data as a list of attributes on the server. Each attribute is a generic container that GATT builds upon (services, characteristics, descriptors). An ATT attribute consists of: Field Size Description Handle 2 bytes A unique ID for the attribute on the server. Used by clients to reference it. Type 2 or 16 bytes A UUID that indicates what kind of attribute this is (e.g., service, characteristic). Permission \u2014 Access control: read, write, notify, etc. Value Variable Actual data content (e.g., the characteristic's value). Common Attribute Types These are 16-bit standardized UUIDs defined by the Bluetooth SIG. They are used to define structure within a GATT service: Type (UUID) Description Meaning 0x2800 Primary Service Marks the beginning of a primary service declaration. 0x2801 Secondary Service Used to define a secondary (helper) service that is referenced by another. 0x2803 Characteristic Declaration Describes a characteristic: includes properties, handle, and UUID. 0x2901 Characteristic User Description Human-readable label (e.g., \"Heart Rate\" ). Shown in GUIs. 0x2902 Client Characteristic Configuration (CCCD) Lets clients enable notifications or indications for a characteristic. GATT uses these generic ATT attributes to structure and organize the data. The type of a characteristic is defined by its UUID, which can be a 16-bit or 128-bit value. Attribute Permissions Each attribute has a set of permissions that control how clients are allowed to interact with it \u2014 such as whether it can be read, written, or requires a secure connection. These permissions are enforced by the ATT server , regardless of what the characteristic claims to support (via its properties). Here's a mapping of common permissions: Permission Description Zephyr Macro Plain Read Client can read the attribute value. BT_GATT_PERM_READ Plain Write Client can write a new value. BT_GATT_PERM_WRITE Encrypted Read Read only allowed over an encrypted connection. BT_GATT_PERM_READ_ENCRYPT Encrypted Write Write only allowed over an encrypted connection. BT_GATT_PERM_WRITE_ENCRYPT Authenticated Read Read allowed only after authentication (e.g., MITM pairing). BT_GATT_PERM_READ_AUTHEN Authenticated Write Write allowed only after authentication (e.g., MITM pairing). BT_GATT_PERM_WRITE_AUTHEN LESC Read Read requires LE Secure Connections. BT_GATT_PERM_READ_LESC LESC Write Write requires LE Secure Connections. BT_GATT_PERM_WRITE_LESC Prepare Write Attribute supports queued writes (long/atomic writes). BT_GATT_PERM_PREPARE_WRITE \ud83d\udd10 When no appropriate permissions are granted (e.g., no BT_GATT_PERM_READ ), the server will reject the client\u2019s operation with an ATT error like Read Not Permitted . This permission layer acts independently from characteristic properties , which simply advertise what can be done \u2014 permissions control what is actually allowed at runtime. Also, here is a quick note on the different security levels (will be covered in more detail later): Encrypted access means the connection must be encrypted (e.g., after pairing). This protects data from passive eavesdropping. Authenticated access goes a step further \u2014 the connection must be encrypted and use an authenticated key (typically generated with MITM protection, like passkey entry). This defends against impersonation attacks. LESC (LE Secure Connections) is a newer pairing method introduced in Bluetooth 4.2. It uses Elliptic Curve Diffie-Hellman (ECDH) for key exchange and offers stronger protection against passive and active attacks compared to older methods. GATT (Generic Attribute Profile) The Generic Attribute Profile (GATT) defines how the low-level attributes defined by the ATT protocol are grouped and interpreted to represent meaningful data. While ATT is concerned purely with the format and transport of attributes (each with a handle, type, permissions, and value), GATT gives structure to those attributes by organizing them into logical groupings like services , characteristics , and descriptors . At its core, GATT uses multiple ATT attributes to represent each component: A Service is a collection of related characteristics (e.g., the Heart Rate Service). A Characteristic represents a data item (e.g., current heart rate) and is made up of three attributes: a declaration , a value , and optional descriptors . A Descriptor is additional metadata about a characteristic, such as a human-readable label or client configuration (e.g., enabling notifications). Each attribute is given a handle, type, permssions, and value. Handles are assgined by the server and can vary between different BLE stacks, but it is worth discussing the other three fields in more detail: 1. Service Declaration Type Permission Value 0x2800 (Primary) or 0x2801 (Secondary) Read UUID of the service (e.g., 0x180F for Battery Service) 2. Characteristic Declaration Type Permission Value 0x2803 (Characteristic Declaration) Read - Properties (1 byte): Bitfield indicating allowed operations (e.g., Read, Write, Notify). - Value Handle (2 bytes): Handle pointing to the Characteristic Value attribute. - Characteristic UUID (2 or 16 bytes): UUID of the characteristic. 3. Characteristic Value Type (UUID of Characteristic) Permission Value The UUID of the characteristic (e.g., 0x2A19 for Battery Level) Depends on characteristic (e.g., Read, Write, Notify) Raw data (e.g., sensor reading, config byte). This is the actual payload a client interacts with. 4. Descriptor Attribute (optional) Type Permission Value e.g., 0x2901 (User Description), 0x2902 (CCCD) Depends on descriptor: - 0x2901 : Read - 0x2902 : Read/Write - User Description (0x2901) : Human-readable name of the characteristic (e.g., \"Temperature\"). - CCCD (0x2902) : 2-byte bitfield that enables notifications and/or indications. - Others: May define triggers, ranges, or valid formats.","title":"BLE-GATT Server Operations"},{"location":"06-ble-gatt-server/#06-ble-gatt-server-initiated-operations","text":"Before diving into server-initiated operations like notifications and indications , it\u2019s important to understand the layers beneath them: ATT and GATT . These layers form the foundation of BLE\u2019s server-client communication model. We want to get comfortable with GATT , as it\u2019s the layer most application developers interact with. But beneath GATT lies ATT , which provides the raw data transport mechanism.","title":"06 - BLE GATT Server-Initiated Operations"},{"location":"06-ble-gatt-server/#att-attribute-protocol","text":"ATT defines a minimal protocol for exposing data as a list of attributes on the server. Each attribute is a generic container that GATT builds upon (services, characteristics, descriptors). An ATT attribute consists of: Field Size Description Handle 2 bytes A unique ID for the attribute on the server. Used by clients to reference it. Type 2 or 16 bytes A UUID that indicates what kind of attribute this is (e.g., service, characteristic). Permission \u2014 Access control: read, write, notify, etc. Value Variable Actual data content (e.g., the characteristic's value).","title":"ATT (Attribute Protocol)"},{"location":"06-ble-gatt-server/#common-attribute-types","text":"These are 16-bit standardized UUIDs defined by the Bluetooth SIG. They are used to define structure within a GATT service: Type (UUID) Description Meaning 0x2800 Primary Service Marks the beginning of a primary service declaration. 0x2801 Secondary Service Used to define a secondary (helper) service that is referenced by another. 0x2803 Characteristic Declaration Describes a characteristic: includes properties, handle, and UUID. 0x2901 Characteristic User Description Human-readable label (e.g., \"Heart Rate\" ). Shown in GUIs. 0x2902 Client Characteristic Configuration (CCCD) Lets clients enable notifications or indications for a characteristic. GATT uses these generic ATT attributes to structure and organize the data. The type of a characteristic is defined by its UUID, which can be a 16-bit or 128-bit value.","title":"Common Attribute Types"},{"location":"06-ble-gatt-server/#attribute-permissions","text":"Each attribute has a set of permissions that control how clients are allowed to interact with it \u2014 such as whether it can be read, written, or requires a secure connection. These permissions are enforced by the ATT server , regardless of what the characteristic claims to support (via its properties). Here's a mapping of common permissions: Permission Description Zephyr Macro Plain Read Client can read the attribute value. BT_GATT_PERM_READ Plain Write Client can write a new value. BT_GATT_PERM_WRITE Encrypted Read Read only allowed over an encrypted connection. BT_GATT_PERM_READ_ENCRYPT Encrypted Write Write only allowed over an encrypted connection. BT_GATT_PERM_WRITE_ENCRYPT Authenticated Read Read allowed only after authentication (e.g., MITM pairing). BT_GATT_PERM_READ_AUTHEN Authenticated Write Write allowed only after authentication (e.g., MITM pairing). BT_GATT_PERM_WRITE_AUTHEN LESC Read Read requires LE Secure Connections. BT_GATT_PERM_READ_LESC LESC Write Write requires LE Secure Connections. BT_GATT_PERM_WRITE_LESC Prepare Write Attribute supports queued writes (long/atomic writes). BT_GATT_PERM_PREPARE_WRITE \ud83d\udd10 When no appropriate permissions are granted (e.g., no BT_GATT_PERM_READ ), the server will reject the client\u2019s operation with an ATT error like Read Not Permitted . This permission layer acts independently from characteristic properties , which simply advertise what can be done \u2014 permissions control what is actually allowed at runtime. Also, here is a quick note on the different security levels (will be covered in more detail later): Encrypted access means the connection must be encrypted (e.g., after pairing). This protects data from passive eavesdropping. Authenticated access goes a step further \u2014 the connection must be encrypted and use an authenticated key (typically generated with MITM protection, like passkey entry). This defends against impersonation attacks. LESC (LE Secure Connections) is a newer pairing method introduced in Bluetooth 4.2. It uses Elliptic Curve Diffie-Hellman (ECDH) for key exchange and offers stronger protection against passive and active attacks compared to older methods.","title":"Attribute Permissions"},{"location":"06-ble-gatt-server/#gatt-generic-attribute-profile","text":"The Generic Attribute Profile (GATT) defines how the low-level attributes defined by the ATT protocol are grouped and interpreted to represent meaningful data. While ATT is concerned purely with the format and transport of attributes (each with a handle, type, permissions, and value), GATT gives structure to those attributes by organizing them into logical groupings like services , characteristics , and descriptors . At its core, GATT uses multiple ATT attributes to represent each component: A Service is a collection of related characteristics (e.g., the Heart Rate Service). A Characteristic represents a data item (e.g., current heart rate) and is made up of three attributes: a declaration , a value , and optional descriptors . A Descriptor is additional metadata about a characteristic, such as a human-readable label or client configuration (e.g., enabling notifications). Each attribute is given a handle, type, permssions, and value. Handles are assgined by the server and can vary between different BLE stacks, but it is worth discussing the other three fields in more detail:","title":"GATT (Generic Attribute Profile)"},{"location":"06-ble-gatt-server/#1-service-declaration","text":"Type Permission Value 0x2800 (Primary) or 0x2801 (Secondary) Read UUID of the service (e.g., 0x180F for Battery Service)","title":"1. Service Declaration"},{"location":"06-ble-gatt-server/#2-characteristic-declaration","text":"Type Permission Value 0x2803 (Characteristic Declaration) Read - Properties (1 byte): Bitfield indicating allowed operations (e.g., Read, Write, Notify). - Value Handle (2 bytes): Handle pointing to the Characteristic Value attribute. - Characteristic UUID (2 or 16 bytes): UUID of the characteristic.","title":"2. Characteristic Declaration"},{"location":"06-ble-gatt-server/#3-characteristic-value","text":"Type (UUID of Characteristic) Permission Value The UUID of the characteristic (e.g., 0x2A19 for Battery Level) Depends on characteristic (e.g., Read, Write, Notify) Raw data (e.g., sensor reading, config byte). This is the actual payload a client interacts with.","title":"3. Characteristic Value"},{"location":"06-ble-gatt-server/#4-descriptor-attribute-optional","text":"Type Permission Value e.g., 0x2901 (User Description), 0x2902 (CCCD) Depends on descriptor: - 0x2901 : Read - 0x2902 : Read/Write - User Description (0x2901) : Human-readable name of the characteristic (e.g., \"Temperature\"). - CCCD (0x2902) : 2-byte bitfield that enables notifications and/or indications. - Others: May define triggers, ranges, or valid formats.","title":"4. Descriptor Attribute (optional)"}]}