{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"nRF Connect SDK Notes This site contains my notes for the official courses on Nordic Developer Academy . Note: In order to not exceed the filename length limit, please make sure to clone the repository as close to the root of your filesystem as possible.","title":"Home"},{"location":"#nrf-connect-sdk-notes","text":"This site contains my notes for the official courses on Nordic Developer Academy . Note: In order to not exceed the filename length limit, please make sure to clone the repository as close to the root of your filesystem as possible.","title":"nRF Connect SDK Notes"},{"location":"ble-01-minimal-skeleton/","text":"01 - Minimal BLE Skeleton Author: Tony Fu Date: 2025/4/3 Device: nRF52840 Dongle Toolchain: nRF Connect SDK v2.8.0 This example sets up the Bluetooth stack only \u2014 no advertising, no services, no connections. Useful as a clean starting point. Configuration: prj.conf # Enable basic logging CONFIG_LOG=y # Enable Bluetooth stack CONFIG_BT=y # Optional: Set device name (not used here but required for CONFIG_BT) CONFIG_BT_DEVICE_NAME=\"Minimal_BLE\" # Increase stack sizes for stability CONFIG_SYSTEM_WORKQUEUE_STACK_SIZE=2048 CONFIG_MAIN_STACK_SIZE=2048 Code Structure: main.c #include <zephyr/kernel.h> #include <zephyr/logging/log.h> #include <zephyr/bluetooth/bluetooth.h> LOG_MODULE_REGISTER(minimal_ble, LOG_LEVEL_INF); int main(void) { int err; LOG_INF(\"Minimal BLE Example Start\"); // Initialize the Bluetooth stack err = bt_enable(NULL); if (err) { LOG_ERR(\"Bluetooth init failed (err %d)\", err); return -1; } LOG_INF(\"Bluetooth initialized\"); // Idle loop while (1) { k_sleep(K_SECONDS(1)); } }","title":"BLE-Minimal Skeleton"},{"location":"ble-01-minimal-skeleton/#01-minimal-ble-skeleton","text":"Author: Tony Fu Date: 2025/4/3 Device: nRF52840 Dongle Toolchain: nRF Connect SDK v2.8.0 This example sets up the Bluetooth stack only \u2014 no advertising, no services, no connections. Useful as a clean starting point.","title":"01 - Minimal BLE Skeleton"},{"location":"ble-01-minimal-skeleton/#configuration-prjconf","text":"# Enable basic logging CONFIG_LOG=y # Enable Bluetooth stack CONFIG_BT=y # Optional: Set device name (not used here but required for CONFIG_BT) CONFIG_BT_DEVICE_NAME=\"Minimal_BLE\" # Increase stack sizes for stability CONFIG_SYSTEM_WORKQUEUE_STACK_SIZE=2048 CONFIG_MAIN_STACK_SIZE=2048","title":"Configuration: prj.conf"},{"location":"ble-01-minimal-skeleton/#code-structure-mainc","text":"#include <zephyr/kernel.h> #include <zephyr/logging/log.h> #include <zephyr/bluetooth/bluetooth.h> LOG_MODULE_REGISTER(minimal_ble, LOG_LEVEL_INF); int main(void) { int err; LOG_INF(\"Minimal BLE Example Start\"); // Initialize the Bluetooth stack err = bt_enable(NULL); if (err) { LOG_ERR(\"Bluetooth init failed (err %d)\", err); return -1; } LOG_INF(\"Bluetooth initialized\"); // Idle loop while (1) { k_sleep(K_SECONDS(1)); } }","title":"Code Structure: main.c"},{"location":"ble-02-advertising-simple/","text":"02 - BLE Advertising Simple Author: Tony Fu Date: 2025/4/3 Device: nRF52840 Dongle Toolchain: nRF Connect SDK v2.8.0 To advertise your device, you need to call bt_le_adv_start() with the right parameters. int bt_le_adv_start(const struct bt_le_adv_param *param, const struct bt_data *ad, size_t ad_len, const struct bt_data *sd, size_t sd_len); param : Advertising parameters (defines behavior) ad : Advertising data (broadcasted to all scanners) sd : Scan response data (optional, sent after scan request) Common Advertising Params BT_LE_ADV_CONN - Connectable undirected advertising, but still advertises to all devices after connected to a peer. This could be bad for power consumption and security. BT_LE_ADV_CONN_ONE_TIME - Connectable undirected advertising, but stops after the first connection. This is the recommended default for most applications. BT_LE_ADV_CONN_DIR - Connectable directed advertising, which is used when you know the peer address. This is faster and less power-hungry than undirected advertising. BT_LE_ADV_NCONN - Non-connectable undirected advertising, which is used when you don't want to be connected to. This is useful for beacons and other passive broadcasts. BT_LE_ADV_CONN_DIR_LOW_DUTY - Connectable directed advertising with a lower duty cycle, which is used when you don't expect to be connected to immediately but still want to reconnect with a known peer. BT_LE_ADV_NCONN_IDENTITY - Non-connectable advertising that uses the device's identity address, which is useful for testing and visibility. Note: To prevent tracking, advertising modes like BT_LE_ADV_CONN , BT_LE_ADV_CONN_ONE_TIME , and BT_LE_ADV_NCONN (params 1, 2, and 4) use Resolvable Private Addresses (RPAs) by default. RPAs are a privacy feature introduced in Bluetooth 4.2. They are generated using the device\u2019s identity address (public or static random) and a random value, and they typically change every 15 minutes. This allows trusted, bonded peers to resolve your identity, while third parties cannot track the device over time. RPA behavior is enabled by default when CONFIG_BT_PRIVACY=y , but it can be disabled if needed. To explicitly advertise with your identity address (e.g., for testing or directed advertising), use the BT_LE_ADV_OPT_USE_IDENTITY option. Advertising Data and Scan Response Data Advertising Data (ad[]) static const struct bt_data ad[] = { BT_DATA_BYTES(BT_DATA_FLAGS, (BT_LE_AD_GENERAL | BT_LE_AD_NO_BREDR)), BT_DATA(BT_DATA_NAME_COMPLETE, DEVICE_NAME, DEVICE_NAME_LEN), }; This example shows how to define advertising data using struct bt_data . struct bt_data { uint8_t type; uint8_t data_len; const uint8_t *data; }; However, we typically don't define `struct bt_data` directly. Instead, we use macros to simplify the process. ```c BT_DATA(type, data, data_len) // Use with a pointer and explicit size BT_DATA_BYTES(type, byte1, byte2...) // Inline declaration with raw bytes In advertising data, we must always include the following fields: BT_DATA_BYTES(BT_DATA_FLAGS, (BT_LE_AD_GENERAL | BT_LE_AD_NO_BREDR)) This is always used on Nordic devices because Nordic only supports BLE (not BR/EDR), and this is why we include <zephyr/bluetooth/gap.h> for the bitmasks. and BT_DATA(BT_DATA_NAME_COMPLETE, DEVICE_NAME, DEVICE_NAME_LEN) Scan Response Data (sd[]) Use scan response (sd) when you want to include optional, larger data like a full device name or a URL. Advertising data is always broadcast; scan response is only sent when a scanner asks for it, making it more power-efficient and less crowded. #define COMPANY_ID_CODE 0x0059 // Nordic Semiconductor typedef struct { uint16_t company_id; // Company ID uint8_t data[6]; // Custom Data } my_data_t; static const my_data_t my_data = { .company_id = COMPANY_ID_CODE, .data = {0x01, 0x02, 0x03, 0x04, 0x05, 0x06}}; When the advertising data is too large to fit in advertising packets, the scanner can request a scan response. This is not shown here. Common Advertising Data Types Common in ad[] (Advertising) Macro Description BT_DATA_FLAGS BLE flags (required) BT_DATA_NAME_COMPLETE Complete device name BT_DATA_UUID16_ALL List of 16-bit service UUIDs BT_DATA_UUID128_ALL List of 128-bit service UUIDs BT_DATA_MANUFACTURER_DATA Vendor-specific binary data Common in sd[] (Scan Response) Macro Description BT_DATA_URI URI string (e.g., website) BT_DATA_TX_POWER Transmission power (in dBm) BT_DATA_APPEARANCE Device appearance (e.g., watch) BT_DATA_NAME_SHORTENED Shortened name (if full name won't fit) More on service UUIDs later.","title":"BLE-Advertising Simple"},{"location":"ble-02-advertising-simple/#02-ble-advertising-simple","text":"Author: Tony Fu Date: 2025/4/3 Device: nRF52840 Dongle Toolchain: nRF Connect SDK v2.8.0 To advertise your device, you need to call bt_le_adv_start() with the right parameters. int bt_le_adv_start(const struct bt_le_adv_param *param, const struct bt_data *ad, size_t ad_len, const struct bt_data *sd, size_t sd_len); param : Advertising parameters (defines behavior) ad : Advertising data (broadcasted to all scanners) sd : Scan response data (optional, sent after scan request)","title":"02 - BLE Advertising Simple"},{"location":"ble-02-advertising-simple/#common-advertising-params","text":"BT_LE_ADV_CONN - Connectable undirected advertising, but still advertises to all devices after connected to a peer. This could be bad for power consumption and security. BT_LE_ADV_CONN_ONE_TIME - Connectable undirected advertising, but stops after the first connection. This is the recommended default for most applications. BT_LE_ADV_CONN_DIR - Connectable directed advertising, which is used when you know the peer address. This is faster and less power-hungry than undirected advertising. BT_LE_ADV_NCONN - Non-connectable undirected advertising, which is used when you don't want to be connected to. This is useful for beacons and other passive broadcasts. BT_LE_ADV_CONN_DIR_LOW_DUTY - Connectable directed advertising with a lower duty cycle, which is used when you don't expect to be connected to immediately but still want to reconnect with a known peer. BT_LE_ADV_NCONN_IDENTITY - Non-connectable advertising that uses the device's identity address, which is useful for testing and visibility. Note: To prevent tracking, advertising modes like BT_LE_ADV_CONN , BT_LE_ADV_CONN_ONE_TIME , and BT_LE_ADV_NCONN (params 1, 2, and 4) use Resolvable Private Addresses (RPAs) by default. RPAs are a privacy feature introduced in Bluetooth 4.2. They are generated using the device\u2019s identity address (public or static random) and a random value, and they typically change every 15 minutes. This allows trusted, bonded peers to resolve your identity, while third parties cannot track the device over time. RPA behavior is enabled by default when CONFIG_BT_PRIVACY=y , but it can be disabled if needed. To explicitly advertise with your identity address (e.g., for testing or directed advertising), use the BT_LE_ADV_OPT_USE_IDENTITY option.","title":"Common Advertising Params"},{"location":"ble-02-advertising-simple/#advertising-data-and-scan-response-data","text":"","title":"Advertising Data and Scan Response Data"},{"location":"ble-02-advertising-simple/#advertising-data-ad","text":"static const struct bt_data ad[] = { BT_DATA_BYTES(BT_DATA_FLAGS, (BT_LE_AD_GENERAL | BT_LE_AD_NO_BREDR)), BT_DATA(BT_DATA_NAME_COMPLETE, DEVICE_NAME, DEVICE_NAME_LEN), }; This example shows how to define advertising data using struct bt_data . struct bt_data { uint8_t type; uint8_t data_len; const uint8_t *data; }; However, we typically don't define `struct bt_data` directly. Instead, we use macros to simplify the process. ```c BT_DATA(type, data, data_len) // Use with a pointer and explicit size BT_DATA_BYTES(type, byte1, byte2...) // Inline declaration with raw bytes In advertising data, we must always include the following fields: BT_DATA_BYTES(BT_DATA_FLAGS, (BT_LE_AD_GENERAL | BT_LE_AD_NO_BREDR)) This is always used on Nordic devices because Nordic only supports BLE (not BR/EDR), and this is why we include <zephyr/bluetooth/gap.h> for the bitmasks. and BT_DATA(BT_DATA_NAME_COMPLETE, DEVICE_NAME, DEVICE_NAME_LEN)","title":"Advertising Data (ad[])"},{"location":"ble-02-advertising-simple/#scan-response-data-sd","text":"Use scan response (sd) when you want to include optional, larger data like a full device name or a URL. Advertising data is always broadcast; scan response is only sent when a scanner asks for it, making it more power-efficient and less crowded. #define COMPANY_ID_CODE 0x0059 // Nordic Semiconductor typedef struct { uint16_t company_id; // Company ID uint8_t data[6]; // Custom Data } my_data_t; static const my_data_t my_data = { .company_id = COMPANY_ID_CODE, .data = {0x01, 0x02, 0x03, 0x04, 0x05, 0x06}}; When the advertising data is too large to fit in advertising packets, the scanner can request a scan response. This is not shown here.","title":"Scan Response Data (sd[])"},{"location":"ble-02-advertising-simple/#common-advertising-data-types","text":"","title":"Common Advertising Data Types"},{"location":"ble-02-advertising-simple/#common-in-ad-advertising","text":"Macro Description BT_DATA_FLAGS BLE flags (required) BT_DATA_NAME_COMPLETE Complete device name BT_DATA_UUID16_ALL List of 16-bit service UUIDs BT_DATA_UUID128_ALL List of 128-bit service UUIDs BT_DATA_MANUFACTURER_DATA Vendor-specific binary data","title":"Common in ad[] (Advertising)"},{"location":"ble-02-advertising-simple/#common-in-sd-scan-response","text":"Macro Description BT_DATA_URI URI string (e.g., website) BT_DATA_TX_POWER Transmission power (in dBm) BT_DATA_APPEARANCE Device appearance (e.g., watch) BT_DATA_NAME_SHORTENED Shortened name (if full name won't fit) More on service UUIDs later.","title":"Common in sd[] (Scan Response)"},{"location":"ble-03-advert-connectable/","text":"03 - BLE Advertising: Connectable Author: Tony Fu Date: 2025/4/5 Device: nRF52840 Dongle Toolchain: nRF Connect SDK v2.8.0 To make a device connectable, we need to enable the Bluetooth peripheral role and set the advertising parameters accordingly. Add this to your prj.conf file: CONFIG_BT_PERIPHERAL=y In previous examples, we used the predefined macro BT_LE_ADV_NCONN for non-connectable advertising. To allow connections, we need different parameters like BT_LE_ADV_CONN_ONE_TIME . We can also define our own advertising parameters with the help of the BT_LE_ADV_PARAM() macro: BT_LE_ADV_PARAM(_options, _int_min, _int_max, _peer) _options : A bitmask of advertising options (e.g., connectable, use identity, etc.) _int_min , _int_max : Advertising interval (units of 0.625 ms) _peer : Peer address; set to NULL for undirected advertising Example parameters for connectable advertising: static const struct bt_le_adv_param *adv_param = BT_LE_ADV_PARAM( (BT_LE_ADV_OPT_CONNECTABLE | BT_LE_ADV_OPT_USE_IDENTITY), /* Connectable advertising and use identity address */ BT_GAP_ADV_FAST_INT_MIN_2, /* Min Advertising Interval 100 ms */ BT_GAP_ADV_FAST_INT_MAX_2, /* Max Advertising Interval 150 ms */ NULL); /* Set to NULL for undirected advertising */ Common options flags include: BT_LE_ADV_OPT_CONNECTABLE : Allow devices to connect BT_LE_ADV_OPT_ONE_TIME : Stop advertising after one connection BT_LE_ADV_OPT_USE_IDENTITY : Use the device's identity address (not RPA) BT_LE_ADV_OPT_USE_NAME : Automatically include the GAP device name BT_LE_ADV_OPT_SCANNABLE : Enable scan response data BT_LE_ADV_OPT_EXT_ADV : Use extended advertising features (for longer range or larger data) BT_LE_ADV_OPT_FILTER_SCAN_REQ : Only respond to scanners in the filter list BT_LE_ADV_OPT_FILTER_CONN : Only allow connections from filtered peers This setup allows your device to be discoverable and accept connections from central devices like phones or PCs. However, it will continue to advertise even after a connection is established, which may not be ideal for power consumption or security. To stop advertising after the first connection, add the BT_LE_ADV_OPT_ONE_TIME option. Advertising Intervals The advertising interval controls how often your device broadcasts its advertising packets. It is set using _int_min and _int_max in BT_LE_ADV_PARAM() and is specified in units of 0.625 ms. Valid range : 20 ms to 10.24 seconds Resolution : 0.625 ms steps You can set: - min == max \u2192 Fixed interval (allowed) - min < max \u2192 Interval chosen randomly within that range (typical) A small random delay (0\u201310 ms) is added automatically to help avoid collisions between devices using similar intervals. Guidelines Short intervals (~20\u2013100 ms) : Fast discovery, higher power consumption Medium intervals (~150\u2013500 ms) : Balanced power and discovery time (good default) Long intervals (>1 s) : Low power, slower to be discovered Choose an interval based on your application: - For wearables or low-power sensors , favor longer intervals - For pairing mode or quick reconnection , use shorter intervals Some constants are defined in zephyr/bluetooth/gap.h for common intervals: GAP Advertising Parameters These are predefined intervals for legacy advertisement (connectable or scannable), used by many macros like BT_LE_ADV_CONN . Macro Hex Time (ms) BT_GAP_ADV_FAST_INT_MIN_1 0x0030 30 BT_GAP_ADV_FAST_INT_MAX_1 0x0060 60 BT_GAP_ADV_FAST_INT_MIN_2 0x00a0 100 BT_GAP_ADV_FAST_INT_MAX_2 0x00f0 150 BT_GAP_ADV_SLOW_INT_MIN 0x0640 1000 BT_GAP_ADV_SLOW_INT_MAX 0x0780 1200 GAP Periodic Advertising Parameters Periodic advertising is a Bluetooth Low Energy feature introduced in Bluetooth 5 that allows a device to broadcast data at fixed, predictable intervals without requiring a connection. Unlike legacy advertising, which is sent on the primary channels and may be missed if the scanner isn't listening at the right time, periodic advertising uses a synchronizable schedule and is transmitted on secondary channels. This allows scanners to synchronize with the advertiser and receive updates reliably with lower power consumption. It's ideal for broadcasting sensor data , location beacons , or status updates where frequent connections aren't needed but consistent updates are. Macro Hex Time (ms) BT_GAP_PER_ADV_FAST_INT_MIN_1 0x0018 30 BT_GAP_PER_ADV_FAST_INT_MAX_1 0x0030 60 BT_GAP_PER_ADV_FAST_INT_MIN_2 0x0050 100 BT_GAP_PER_ADV_FAST_INT_MAX_2 0x0078 150 BT_GAP_PER_ADV_SLOW_INT_MIN 0x0320 1000 BT_GAP_PER_ADV_SLOW_INT_MAX 0x03C0 1200 GAP Scan Parameters These define standard scan intervals and windows. The interval is how often scanning starts, and the window is how long each scan lasts. Macro Hex Time (ms) BT_GAP_SCAN_FAST_INTERVAL_MIN 0x0030 30 BT_GAP_SCAN_FAST_INTERVAL 0x0060 60 BT_GAP_SCAN_FAST_WINDOW 0x0030 30 BT_GAP_SCAN_SLOW_INTERVAL_1 0x0800 1280 BT_GAP_SCAN_SLOW_WINDOW_1 0x0012 11.25 BT_GAP_SCAN_SLOW_INTERVAL_2 0x1000 2560 BT_GAP_SCAN_SLOW_WINDOW_2 0x0012 11.25 GAP Initial Connection Parameters These define intervals used when initiating a connection (i.e., when a central connects to a peripheral). Macro Hex Time (ms) BT_GAP_INIT_CONN_INT_MIN 0x0018 30 BT_GAP_INIT_CONN_INT_MAX 0x0028 50 Additional Notes on Timing Coordination When both the advertiser and scanner are under your control, you can optimize their timing parameters to strike a balance between discovery speed , power consumption , and reliability . This is especially useful in scenarios like proprietary ecosystems, closed systems, or when designing both ends of a BLE link (e.g., a wearable + smartphone app). Understanding Scan Interval and Scan Window Scan interval is how often the scanner initiates a scan cycle. Scan window is how long the scanner listens during each scan interval. Both range from 2.5 ms to 10.24 seconds in 0.625 ms steps. In each scan interval, the scanner will scan one of the three primary advertising channels. After the interval ends, it switches to the next channel. If the scan window is equal to the scan interval, the scanner is scanning continuously (100% duty cycle). If the window is shorter than the interval, it means the scanner is off part of the time \u2014 which saves power. For example, if scan interval = 100 ms and window = 20 ms, the scanner is listening only 20% of the time. Coordinating With Advertising Intervals To improve the chances of the scanner receiving advertising packets: The advertising interval should be shorter than or equal to the scan interval. This increases the probability that an advertisement will occur during the scan window. A good rule of thumb is: advertising interval \u2264 scan interval - scan window This ensures that at least one advertisement falls within an active scan window over multiple cycles. You can also align timing using multiples, such as: - Scan interval = 3 \u00d7 advertising interval - Scan window = 50\u201380% of scan interval (for reasonable duty cycle) This is not a strict rule, but it helps statistically reduce missed advertisements due to phase misalignment. Example Timing Coordination Parameter Typical Value Advertising interval 100 ms ( 0x00A0 ) Scan interval 300 ms ( 0x018C ) Scan window 150 ms ( 0x00F0 ) This setup provides good discovery speed and balances scanner energy usage. Notes on Scan Response Timing Scan response packets are only sent if the advertiser receives a scan request . This scan request must be sent while the advertiser is listening , and only during active scanning. The non-scanning time (between windows) is not used for scan response \u2014 in fact, nothing happens during those gaps. This means larger scan windows increase the chance of triggering a scan response successfully. Power Considerations Scanning uses more power than advertising \u2014 so the scanner (usually the central) should be the device with more available energy (e.g., a phone). Peripheral devices (e.g., sensors, wearables) can advertise less frequently to save power and rely on burst scanning from the central. Summary Guidelines Ensure advertising interval \u2264 scan interval Keep scan window large enough to catch at least one advertisement Use scan window \u2248 50\u2013100% of scan interval for faster discovery For low power devices, increase advertising interval and let central scan more aggressively Aside: BLE Address Types Before we continue, let's take a moment to explore the different types of Bluetooth LE addresses. Every BLE device is identified by a 48-bit address , and they are grouped into two main categories: public and random . Random addresses are further split into static , resolvable private , and non-resolvable private types. The type used affects how your device is identified, whether it can be tracked, and whether connections or bonding are possible. 1. Public Address A globally unique address assigned by the manufacturer and stored in the device's hardware (e.g., in FICR on nRF chips). Used automatically unless you override it with a random address or enable privacy. Get the default public address: bt_addr_le_t addr; bt_id_get(&addr, NULL); 2. Random Static Address Does not change across boots \u2014 stable identity. Must follow BLE spec: the most significant two bits of the first byte must be 11 (so the first byte must be between 0xC0 and 0xFF ). Commonly used when you don't have a public address block but need a consistent identity. Set a static random address manually: #include <zephyr/bluetooth/addr.h> bt_addr_le_t addr; bt_addr_le_from_str(\"FF:00:11:22:33:44\", \"random\", &addr); addr.a.val[5] |= 0xC0; // Make sure MSBs are '11' to mark as static random int id = bt_id_create(&addr, NULL); // Must be called before bt_enable() In production, you might derive a unique static random address from the device\u2019s public address or store a pre-generated one in flash/UICR. 3. Resolvable Private Address (RPA) Changes periodically (by default every 15 minutes), but can be resolved by bonded peers using an Identity Resolving Key (IRK). Enables privacy without sacrificing the ability to reconnect or bond. I am currently not sure how to set the RPA manually, but it should be automatically generated by the stack when you enable privacy ( CONFIG_BT_PRIVACY=y ). 4. Non-Resolvable Private Address (NRPA) Also changes periodically, but cannot be resolved \u2014 not bondable or connectable. Useful for anonymous broadcasting (e.g., a privacy-focused beacon). A new NRPA is generated every time you start advertising. Set NRPA explicitly: static const struct bt_le_adv_param *adv_param = BT_LE_ADV_PARAM( BT_LE_ADV_OPT_USE_NRPA, 160, 160, NULL); Connection Callbacks To handle Bluetooth connections in Zephyr, we use the bt_conn_cb structure. This lets us register callback functions to track connection events like when a device connects or disconnects. First, include the necessary header: #include <zephyr/bluetooth/conn.h> Then, declare a connection reference to track the active connection: static struct bt_conn *my_conn = NULL; Basic Callbacks void on_connected(struct bt_conn *conn, uint8_t err) { if (err) { LOG_ERR(\"Connection failed (err %u)\", err); return; } my_conn = bt_conn_ref(conn); } void on_disconnected(struct bt_conn *conn, uint8_t reason) { LOG_INF(\"Disconnected (reason 0x%02x)\", reason); if (my_conn) { bt_conn_unref(my_conn); my_conn = NULL; } } bt_conn_ref() increases the reference count so the connection stays valid. bt_conn_unref() is called on disconnection to release the reference. bt_conn_get_dst() gets the peer device\u2019s address. Although tracking bt_conn isn't strictly necessary in this example, it becomes important when supporting multiple simultaneous connections . Keeping a reference to each connection allows you to target specific peers\u2014for example, sending data only to one device or applying per-connection security settings. Most Zephyr Bluetooth APIs accept NULL as the bt_conn argument, which simply means \u201csend to all connected peers.\u201d But for more advanced use cases, managing and using specific bt_conn pointers is essential for precise control. Registering Callbacks static struct bt_conn_cb connection_callbacks = { .connected = on_connected, .disconnected = on_disconnected, }; bt_conn_cb_register(&connection_callbacks); You must register your callback structure before or after enabling Bluetooth, and before expecting any connection events. Other Available Callbacks in bt_conn_cb You can optionally implement more callbacks: recycled : Called when a connection object is returned to the pool. le_param_req : Called when the peer requests to update connection parameters. Return true to accept or false to reject. le_param_updated : Notifies when connection parameters are updated (interval, latency, timeout). identity_resolved : (If SMP enabled) Notifies when a peer's identity address is resolved from an RPA. security_changed : (If SMP or Classic enabled) Called when connection security changes. remote_info_available : Called when info about the peer (features, roles) is available. le_phy_updated : Notifies when PHY is changed (1M, 2M, coded). le_data_len_updated : Called when the maximum payload size changes. tx_power_report : Reports transmit power changes. subrate_changed : Called when connection subrate settings change. These are mostly optional and only needed for advanced use cases. Connection and Disconnection Error Codes Both on_connected() and on_disconnected() callbacks report errors using HCI error codes defined by the Bluetooth Core Specification. These are standard codes used across the Bluetooth stack to indicate why a connection failed or was terminated. In on_connected() , the err parameter is 0 on success, or an HCI error (e.g., 0x3E for \"Connection Failed to be Established\"). In on_disconnected() , the reason parameter is also an HCI error code (e.g., 0x13 for \"Remote User Terminated Connection\"). These codes help identify common issues such as timeouts, user-initiated disconnects, or parameter mismatches. You can refer to the official list of controller error codes here: \ud83d\udd17 Bluetooth Core Spec v5.4 \u2013 Controller Error Codes","title":"BLE-Advertising Connectable"},{"location":"ble-03-advert-connectable/#03-ble-advertising-connectable","text":"Author: Tony Fu Date: 2025/4/5 Device: nRF52840 Dongle Toolchain: nRF Connect SDK v2.8.0 To make a device connectable, we need to enable the Bluetooth peripheral role and set the advertising parameters accordingly. Add this to your prj.conf file: CONFIG_BT_PERIPHERAL=y In previous examples, we used the predefined macro BT_LE_ADV_NCONN for non-connectable advertising. To allow connections, we need different parameters like BT_LE_ADV_CONN_ONE_TIME . We can also define our own advertising parameters with the help of the BT_LE_ADV_PARAM() macro: BT_LE_ADV_PARAM(_options, _int_min, _int_max, _peer) _options : A bitmask of advertising options (e.g., connectable, use identity, etc.) _int_min , _int_max : Advertising interval (units of 0.625 ms) _peer : Peer address; set to NULL for undirected advertising Example parameters for connectable advertising: static const struct bt_le_adv_param *adv_param = BT_LE_ADV_PARAM( (BT_LE_ADV_OPT_CONNECTABLE | BT_LE_ADV_OPT_USE_IDENTITY), /* Connectable advertising and use identity address */ BT_GAP_ADV_FAST_INT_MIN_2, /* Min Advertising Interval 100 ms */ BT_GAP_ADV_FAST_INT_MAX_2, /* Max Advertising Interval 150 ms */ NULL); /* Set to NULL for undirected advertising */ Common options flags include: BT_LE_ADV_OPT_CONNECTABLE : Allow devices to connect BT_LE_ADV_OPT_ONE_TIME : Stop advertising after one connection BT_LE_ADV_OPT_USE_IDENTITY : Use the device's identity address (not RPA) BT_LE_ADV_OPT_USE_NAME : Automatically include the GAP device name BT_LE_ADV_OPT_SCANNABLE : Enable scan response data BT_LE_ADV_OPT_EXT_ADV : Use extended advertising features (for longer range or larger data) BT_LE_ADV_OPT_FILTER_SCAN_REQ : Only respond to scanners in the filter list BT_LE_ADV_OPT_FILTER_CONN : Only allow connections from filtered peers This setup allows your device to be discoverable and accept connections from central devices like phones or PCs. However, it will continue to advertise even after a connection is established, which may not be ideal for power consumption or security. To stop advertising after the first connection, add the BT_LE_ADV_OPT_ONE_TIME option.","title":"03 - BLE Advertising: Connectable"},{"location":"ble-03-advert-connectable/#advertising-intervals","text":"The advertising interval controls how often your device broadcasts its advertising packets. It is set using _int_min and _int_max in BT_LE_ADV_PARAM() and is specified in units of 0.625 ms. Valid range : 20 ms to 10.24 seconds Resolution : 0.625 ms steps You can set: - min == max \u2192 Fixed interval (allowed) - min < max \u2192 Interval chosen randomly within that range (typical) A small random delay (0\u201310 ms) is added automatically to help avoid collisions between devices using similar intervals.","title":"Advertising Intervals"},{"location":"ble-03-advert-connectable/#guidelines","text":"Short intervals (~20\u2013100 ms) : Fast discovery, higher power consumption Medium intervals (~150\u2013500 ms) : Balanced power and discovery time (good default) Long intervals (>1 s) : Low power, slower to be discovered Choose an interval based on your application: - For wearables or low-power sensors , favor longer intervals - For pairing mode or quick reconnection , use shorter intervals Some constants are defined in zephyr/bluetooth/gap.h for common intervals:","title":"Guidelines"},{"location":"ble-03-advert-connectable/#gap-advertising-parameters","text":"These are predefined intervals for legacy advertisement (connectable or scannable), used by many macros like BT_LE_ADV_CONN . Macro Hex Time (ms) BT_GAP_ADV_FAST_INT_MIN_1 0x0030 30 BT_GAP_ADV_FAST_INT_MAX_1 0x0060 60 BT_GAP_ADV_FAST_INT_MIN_2 0x00a0 100 BT_GAP_ADV_FAST_INT_MAX_2 0x00f0 150 BT_GAP_ADV_SLOW_INT_MIN 0x0640 1000 BT_GAP_ADV_SLOW_INT_MAX 0x0780 1200","title":"GAP Advertising Parameters"},{"location":"ble-03-advert-connectable/#gap-periodic-advertising-parameters","text":"Periodic advertising is a Bluetooth Low Energy feature introduced in Bluetooth 5 that allows a device to broadcast data at fixed, predictable intervals without requiring a connection. Unlike legacy advertising, which is sent on the primary channels and may be missed if the scanner isn't listening at the right time, periodic advertising uses a synchronizable schedule and is transmitted on secondary channels. This allows scanners to synchronize with the advertiser and receive updates reliably with lower power consumption. It's ideal for broadcasting sensor data , location beacons , or status updates where frequent connections aren't needed but consistent updates are. Macro Hex Time (ms) BT_GAP_PER_ADV_FAST_INT_MIN_1 0x0018 30 BT_GAP_PER_ADV_FAST_INT_MAX_1 0x0030 60 BT_GAP_PER_ADV_FAST_INT_MIN_2 0x0050 100 BT_GAP_PER_ADV_FAST_INT_MAX_2 0x0078 150 BT_GAP_PER_ADV_SLOW_INT_MIN 0x0320 1000 BT_GAP_PER_ADV_SLOW_INT_MAX 0x03C0 1200","title":"GAP Periodic Advertising Parameters"},{"location":"ble-03-advert-connectable/#gap-scan-parameters","text":"These define standard scan intervals and windows. The interval is how often scanning starts, and the window is how long each scan lasts. Macro Hex Time (ms) BT_GAP_SCAN_FAST_INTERVAL_MIN 0x0030 30 BT_GAP_SCAN_FAST_INTERVAL 0x0060 60 BT_GAP_SCAN_FAST_WINDOW 0x0030 30 BT_GAP_SCAN_SLOW_INTERVAL_1 0x0800 1280 BT_GAP_SCAN_SLOW_WINDOW_1 0x0012 11.25 BT_GAP_SCAN_SLOW_INTERVAL_2 0x1000 2560 BT_GAP_SCAN_SLOW_WINDOW_2 0x0012 11.25","title":"GAP Scan Parameters"},{"location":"ble-03-advert-connectable/#gap-initial-connection-parameters","text":"These define intervals used when initiating a connection (i.e., when a central connects to a peripheral). Macro Hex Time (ms) BT_GAP_INIT_CONN_INT_MIN 0x0018 30 BT_GAP_INIT_CONN_INT_MAX 0x0028 50","title":"GAP Initial Connection Parameters"},{"location":"ble-03-advert-connectable/#additional-notes-on-timing-coordination","text":"When both the advertiser and scanner are under your control, you can optimize their timing parameters to strike a balance between discovery speed , power consumption , and reliability . This is especially useful in scenarios like proprietary ecosystems, closed systems, or when designing both ends of a BLE link (e.g., a wearable + smartphone app).","title":"Additional Notes on Timing Coordination"},{"location":"ble-03-advert-connectable/#understanding-scan-interval-and-scan-window","text":"Scan interval is how often the scanner initiates a scan cycle. Scan window is how long the scanner listens during each scan interval. Both range from 2.5 ms to 10.24 seconds in 0.625 ms steps. In each scan interval, the scanner will scan one of the three primary advertising channels. After the interval ends, it switches to the next channel. If the scan window is equal to the scan interval, the scanner is scanning continuously (100% duty cycle). If the window is shorter than the interval, it means the scanner is off part of the time \u2014 which saves power. For example, if scan interval = 100 ms and window = 20 ms, the scanner is listening only 20% of the time.","title":"Understanding Scan Interval and Scan Window"},{"location":"ble-03-advert-connectable/#coordinating-with-advertising-intervals","text":"To improve the chances of the scanner receiving advertising packets: The advertising interval should be shorter than or equal to the scan interval. This increases the probability that an advertisement will occur during the scan window. A good rule of thumb is: advertising interval \u2264 scan interval - scan window This ensures that at least one advertisement falls within an active scan window over multiple cycles. You can also align timing using multiples, such as: - Scan interval = 3 \u00d7 advertising interval - Scan window = 50\u201380% of scan interval (for reasonable duty cycle) This is not a strict rule, but it helps statistically reduce missed advertisements due to phase misalignment.","title":"Coordinating With Advertising Intervals"},{"location":"ble-03-advert-connectable/#example-timing-coordination","text":"Parameter Typical Value Advertising interval 100 ms ( 0x00A0 ) Scan interval 300 ms ( 0x018C ) Scan window 150 ms ( 0x00F0 ) This setup provides good discovery speed and balances scanner energy usage.","title":"Example Timing Coordination"},{"location":"ble-03-advert-connectable/#notes-on-scan-response-timing","text":"Scan response packets are only sent if the advertiser receives a scan request . This scan request must be sent while the advertiser is listening , and only during active scanning. The non-scanning time (between windows) is not used for scan response \u2014 in fact, nothing happens during those gaps. This means larger scan windows increase the chance of triggering a scan response successfully.","title":"Notes on Scan Response Timing"},{"location":"ble-03-advert-connectable/#power-considerations","text":"Scanning uses more power than advertising \u2014 so the scanner (usually the central) should be the device with more available energy (e.g., a phone). Peripheral devices (e.g., sensors, wearables) can advertise less frequently to save power and rely on burst scanning from the central.","title":"Power Considerations"},{"location":"ble-03-advert-connectable/#summary-guidelines","text":"Ensure advertising interval \u2264 scan interval Keep scan window large enough to catch at least one advertisement Use scan window \u2248 50\u2013100% of scan interval for faster discovery For low power devices, increase advertising interval and let central scan more aggressively","title":"Summary Guidelines"},{"location":"ble-03-advert-connectable/#aside-ble-address-types","text":"Before we continue, let's take a moment to explore the different types of Bluetooth LE addresses. Every BLE device is identified by a 48-bit address , and they are grouped into two main categories: public and random . Random addresses are further split into static , resolvable private , and non-resolvable private types. The type used affects how your device is identified, whether it can be tracked, and whether connections or bonding are possible.","title":"Aside: BLE Address Types"},{"location":"ble-03-advert-connectable/#1-public-address","text":"A globally unique address assigned by the manufacturer and stored in the device's hardware (e.g., in FICR on nRF chips). Used automatically unless you override it with a random address or enable privacy.","title":"1. Public Address"},{"location":"ble-03-advert-connectable/#get-the-default-public-address","text":"bt_addr_le_t addr; bt_id_get(&addr, NULL);","title":"Get the default public address:"},{"location":"ble-03-advert-connectable/#2-random-static-address","text":"Does not change across boots \u2014 stable identity. Must follow BLE spec: the most significant two bits of the first byte must be 11 (so the first byte must be between 0xC0 and 0xFF ). Commonly used when you don't have a public address block but need a consistent identity.","title":"2. Random Static Address"},{"location":"ble-03-advert-connectable/#set-a-static-random-address-manually","text":"#include <zephyr/bluetooth/addr.h> bt_addr_le_t addr; bt_addr_le_from_str(\"FF:00:11:22:33:44\", \"random\", &addr); addr.a.val[5] |= 0xC0; // Make sure MSBs are '11' to mark as static random int id = bt_id_create(&addr, NULL); // Must be called before bt_enable() In production, you might derive a unique static random address from the device\u2019s public address or store a pre-generated one in flash/UICR.","title":"Set a static random address manually:"},{"location":"ble-03-advert-connectable/#3-resolvable-private-address-rpa","text":"Changes periodically (by default every 15 minutes), but can be resolved by bonded peers using an Identity Resolving Key (IRK). Enables privacy without sacrificing the ability to reconnect or bond. I am currently not sure how to set the RPA manually, but it should be automatically generated by the stack when you enable privacy ( CONFIG_BT_PRIVACY=y ).","title":"3. Resolvable Private Address (RPA)"},{"location":"ble-03-advert-connectable/#4-non-resolvable-private-address-nrpa","text":"Also changes periodically, but cannot be resolved \u2014 not bondable or connectable. Useful for anonymous broadcasting (e.g., a privacy-focused beacon). A new NRPA is generated every time you start advertising.","title":"4. Non-Resolvable Private Address (NRPA)"},{"location":"ble-03-advert-connectable/#set-nrpa-explicitly","text":"static const struct bt_le_adv_param *adv_param = BT_LE_ADV_PARAM( BT_LE_ADV_OPT_USE_NRPA, 160, 160, NULL);","title":"Set NRPA explicitly:"},{"location":"ble-03-advert-connectable/#connection-callbacks","text":"To handle Bluetooth connections in Zephyr, we use the bt_conn_cb structure. This lets us register callback functions to track connection events like when a device connects or disconnects. First, include the necessary header: #include <zephyr/bluetooth/conn.h> Then, declare a connection reference to track the active connection: static struct bt_conn *my_conn = NULL;","title":"Connection Callbacks"},{"location":"ble-03-advert-connectable/#basic-callbacks","text":"void on_connected(struct bt_conn *conn, uint8_t err) { if (err) { LOG_ERR(\"Connection failed (err %u)\", err); return; } my_conn = bt_conn_ref(conn); } void on_disconnected(struct bt_conn *conn, uint8_t reason) { LOG_INF(\"Disconnected (reason 0x%02x)\", reason); if (my_conn) { bt_conn_unref(my_conn); my_conn = NULL; } } bt_conn_ref() increases the reference count so the connection stays valid. bt_conn_unref() is called on disconnection to release the reference. bt_conn_get_dst() gets the peer device\u2019s address. Although tracking bt_conn isn't strictly necessary in this example, it becomes important when supporting multiple simultaneous connections . Keeping a reference to each connection allows you to target specific peers\u2014for example, sending data only to one device or applying per-connection security settings. Most Zephyr Bluetooth APIs accept NULL as the bt_conn argument, which simply means \u201csend to all connected peers.\u201d But for more advanced use cases, managing and using specific bt_conn pointers is essential for precise control.","title":"Basic Callbacks"},{"location":"ble-03-advert-connectable/#registering-callbacks","text":"static struct bt_conn_cb connection_callbacks = { .connected = on_connected, .disconnected = on_disconnected, }; bt_conn_cb_register(&connection_callbacks); You must register your callback structure before or after enabling Bluetooth, and before expecting any connection events.","title":"Registering Callbacks"},{"location":"ble-03-advert-connectable/#other-available-callbacks-in-bt_conn_cb","text":"You can optionally implement more callbacks: recycled : Called when a connection object is returned to the pool. le_param_req : Called when the peer requests to update connection parameters. Return true to accept or false to reject. le_param_updated : Notifies when connection parameters are updated (interval, latency, timeout). identity_resolved : (If SMP enabled) Notifies when a peer's identity address is resolved from an RPA. security_changed : (If SMP or Classic enabled) Called when connection security changes. remote_info_available : Called when info about the peer (features, roles) is available. le_phy_updated : Notifies when PHY is changed (1M, 2M, coded). le_data_len_updated : Called when the maximum payload size changes. tx_power_report : Reports transmit power changes. subrate_changed : Called when connection subrate settings change. These are mostly optional and only needed for advanced use cases.","title":"Other Available Callbacks in bt_conn_cb"},{"location":"ble-03-advert-connectable/#connection-and-disconnection-error-codes","text":"Both on_connected() and on_disconnected() callbacks report errors using HCI error codes defined by the Bluetooth Core Specification. These are standard codes used across the Bluetooth stack to indicate why a connection failed or was terminated. In on_connected() , the err parameter is 0 on success, or an HCI error (e.g., 0x3E for \"Connection Failed to be Established\"). In on_disconnected() , the reason parameter is also an HCI error code (e.g., 0x13 for \"Remote User Terminated Connection\"). These codes help identify common issues such as timeouts, user-initiated disconnects, or parameter mismatches. You can refer to the official list of controller error codes here: \ud83d\udd17 Bluetooth Core Spec v5.4 \u2013 Controller Error Codes","title":"Connection and Disconnection Error Codes"},{"location":"ble-04-conn-params/","text":"04 - BLE Connection Parameters Author: Tony Fu Date: 2025/4/6 Device: nRF52840 Dongle Toolchain: nRF Connect SDK v2.8.0 Core Connection Parameters These parameters were part of the original Bluetooth LE specification , and are exchanged during connection establishment. They define the timing and reliability of the connection. 1. Connection Interval Time between consecutive connection events (when devices wake up to communicate). Typical range: 7.5 ms to 4 s, in steps of 1.25 ms. Lower values = lower latency, higher power use. Higher values = longer sleep time, lower power use. 2. Supervision Timeout Max time allowed without successful packet reception before the connection is considered lost. Typical range: 100 ms to 32 s, in steps of 10 ms. Must be > (1 + peripheral latency) \u00d7 connection interval \u00d7 2. 3. Peripheral Latency Number of connection events the peripheral can skip if it has nothing to send. Typical values: 0\u2013499 (unitless). Allows the peripheral to save power while remaining in the connection. Note: The name is misleading \u2014 this is not a time duration , but a count of skipped events. In Action In the on_connect callback, we can print the 3 connection parameters: static void on_conn_established(struct bt_conn *conn, uint8_t err) { // ... other code active_conn = bt_conn_ref(conn); struct bt_conn_info info; if (bt_conn_get_info(conn, &info) == 0) { double int_ms = info.le.interval * 1.25; uint16_t timeout_ms = info.le.timeout * 10; LOG_INF(\"Initial conn params: %.2f ms, latency %u, timeout %u ms\", int_ms, info.le.latency, timeout_ms); } // ... other code } Note: Floating point math is not enabled by default, so we need to add CONFIG_FPU=y to the prj.conf file. Those parameters are typically first determined by the central device, and then the peripheral can request changes. To define our (i.e., the peripheral's) connection parameters, we can override the default values in the prj.conf file: # Set preferred connection parameters (units: 1.25ms for interval, 10ms for timeout) CONFIG_BT_PERIPHERAL_PREF_MIN_INT=320 CONFIG_BT_PERIPHERAL_PREF_MAX_INT=400 CONFIG_BT_PERIPHERAL_PREF_LATENCY=3 CONFIG_BT_PERIPHERAL_PREF_TIMEOUT=500 CONFIG_BT_GAP_AUTO_UPDATE_CONN_PARAMS=y The last line may be redundant, as it is enabled by default. It allows the peripheral to request a change in connection parameters after the initial connection. To get notified of the new parameters, we can implement the on_conn_param_update callback: static void handle_conn_param_change(struct bt_conn *conn, uint16_t interval, uint16_t latency, uint16_t timeout) { double interval_ms = interval * 1.25; uint16_t timeout_ms = timeout * 10; LOG_INF(\"Params changed: %.2f ms, latency %u, timeout %u ms\", interval_ms, latency, timeout_ms); } PHY Radio Modes The default mode is 1M PHY (1 Mbps), which is used for compatibility. 2M PHY (2 Mbps): Doubles throughput, reduces time on air, but may shorten range. Coded PHY : Increases range using redundancy, but at a lower data rate (125 kbps or 500 kbps). In Action First, we need to enable the PHY feature in the prj.conf file: CONFIG_BT_USER_PHY_UPDATE=y We can set the PHY mode again in the on_connect callback: static void on_conn_established(struct bt_conn *conn, uint8_t err) { // ... other code const struct bt_conn_le_phy_param phy_pref = { .options = BT_CONN_LE_PHY_OPT_NONE, .pref_rx_phy = BT_GAP_LE_PHY_2M, .pref_tx_phy = BT_GAP_LE_PHY_2M, }; int err = bt_conn_le_phy_update(conn, &phy_pref); if (err) { LOG_ERR(\"PHY update failed (%d)\", err); } // ... other code } To get notified of the PHY change, we can implement the on_phy_update callback: static void handle_phy_change(struct bt_conn *conn, struct bt_conn_le_phy_info *info) { switch (info->tx_phy) { case BT_CONN_LE_TX_POWER_PHY_1M: LOG_INF(\"PHY switched to 1M\"); break; case BT_CONN_LE_TX_POWER_PHY_2M: LOG_INF(\"PHY switched to 2M\"); break; case BT_CONN_LE_TX_POWER_PHY_CODED_S8: LOG_INF(\"PHY switched to Long Range\"); break; default: LOG_INF(\"PHY changed to unknown mode\"); break; } } Data Length vs MTU To understand how these differ, it's helpful to recall the Bluetooth LE stack layers : - GATT (Generic Attribute Profile): Application layer. You usually interact here. - L2CAP : Handles segmentation and reassembly of packets. - Link Layer : The lowest level; handles actual radio transmission. MTU (Maximum Transmission Unit) Maximum size of a single GATT operation (covered in next page). Default: 23 bytes. Can be increased after connection using MTU Exchange . Operates at the GATT / L2CAP level . You configure the maximum value with: Kconfig CONFIG_BT_L2CAP_TX_MTU=247 Data Length Maximum size of a single Link Layer PDU (packet). Default: 27 bytes. With BLE 4.2+, it can go up to 251 bytes . Controlled via Data Length Extension (DLE) . Even with a high MTU, a small data length will result in packet fragmentation . Configure this with: Kconfig CONFIG_BT_CTLR_DATA_LENGTH_MAX=251 CONFIG_BT_BUF_ACL_TX_SIZE=251 CONFIG_BT_BUF_ACL_RX_SIZE=251 Negotiating MTU and Data Length in Code Make sure data length updates are enabled: CONFIG_BT_USER_DATA_LEN_UPDATE=y Then, in your on_connected() callback: // Request a data length update (TX only) struct bt_conn_le_data_len_param len_params = { .tx_max_len = BT_GAP_DATA_LEN_MAX, // Usually 251 .tx_max_time = BT_GAP_DATA_TIME_MAX, // Usually 0x4290 (17040 \u00b5s) }; int err = bt_conn_le_data_len_update(conn, &len_params); if (err) { LOG_ERR(\"Failed to update data length (%d)\", err); } Why only TX? Because you can only propose values for your side of the connection. The peer will reply with what it supports for both TX and RX. The callback later gives you the final values for both ends. To negotiate the MTU: // Start MTU exchange \u2014 no need to specify desired MTU static struct bt_gatt_exchange_params params = { .func = mtu_exchange_cb // Called when negotiation is done }; err = bt_gatt_exchange_mtu(conn, &params); if (err) { LOG_ERR(\"MTU exchange failed (%d)\", err); } \ud83d\udcdd Why don't we set a value in params ? You don\u2019t pass the MTU manually. The stack reads CONFIG_BT_L2CAP_TX_MTU and automatically includes that in the ATT_Exchange_MTU_Request . The negotiated MTU is then: c min(our_mtu, peer_mtu) The callback: static void mtu_exchange_cb(struct bt_conn *conn, uint8_t err, struct bt_gatt_exchange_params *params) { if (!err) { uint16_t app_mtu = bt_gatt_get_mtu(conn) - 3; // 3 bytes = ATT header LOG_INF(\"MTU negotiated: %u bytes\", app_mtu); } else { LOG_ERR(\"MTU exchange failed (ATT err %u)\", err); } } Result: Callback confirms what was accepted static void handle_data_len_change(struct bt_conn *conn, struct bt_conn_le_data_len_info *info) { LOG_INF(\"Data len: TX=%u (%uus), RX=%u (%uus)\", info->tx_max_len, info->tx_max_time, info->rx_max_len, info->rx_max_time); } \ud83d\udcdd This tells you what both sides agreed on after negotiation \u2014 your request vs. what the peer supports. - TX: What you send - RX: What you receive","title":"BLE-Connection Parameters"},{"location":"ble-04-conn-params/#04-ble-connection-parameters","text":"Author: Tony Fu Date: 2025/4/6 Device: nRF52840 Dongle Toolchain: nRF Connect SDK v2.8.0","title":"04 - BLE Connection Parameters"},{"location":"ble-04-conn-params/#core-connection-parameters","text":"These parameters were part of the original Bluetooth LE specification , and are exchanged during connection establishment. They define the timing and reliability of the connection.","title":"Core Connection Parameters"},{"location":"ble-04-conn-params/#1-connection-interval","text":"Time between consecutive connection events (when devices wake up to communicate). Typical range: 7.5 ms to 4 s, in steps of 1.25 ms. Lower values = lower latency, higher power use. Higher values = longer sleep time, lower power use.","title":"1. Connection Interval"},{"location":"ble-04-conn-params/#2-supervision-timeout","text":"Max time allowed without successful packet reception before the connection is considered lost. Typical range: 100 ms to 32 s, in steps of 10 ms. Must be > (1 + peripheral latency) \u00d7 connection interval \u00d7 2.","title":"2. Supervision Timeout"},{"location":"ble-04-conn-params/#3-peripheral-latency","text":"Number of connection events the peripheral can skip if it has nothing to send. Typical values: 0\u2013499 (unitless). Allows the peripheral to save power while remaining in the connection. Note: The name is misleading \u2014 this is not a time duration , but a count of skipped events.","title":"3. Peripheral Latency"},{"location":"ble-04-conn-params/#in-action","text":"In the on_connect callback, we can print the 3 connection parameters: static void on_conn_established(struct bt_conn *conn, uint8_t err) { // ... other code active_conn = bt_conn_ref(conn); struct bt_conn_info info; if (bt_conn_get_info(conn, &info) == 0) { double int_ms = info.le.interval * 1.25; uint16_t timeout_ms = info.le.timeout * 10; LOG_INF(\"Initial conn params: %.2f ms, latency %u, timeout %u ms\", int_ms, info.le.latency, timeout_ms); } // ... other code } Note: Floating point math is not enabled by default, so we need to add CONFIG_FPU=y to the prj.conf file. Those parameters are typically first determined by the central device, and then the peripheral can request changes. To define our (i.e., the peripheral's) connection parameters, we can override the default values in the prj.conf file: # Set preferred connection parameters (units: 1.25ms for interval, 10ms for timeout) CONFIG_BT_PERIPHERAL_PREF_MIN_INT=320 CONFIG_BT_PERIPHERAL_PREF_MAX_INT=400 CONFIG_BT_PERIPHERAL_PREF_LATENCY=3 CONFIG_BT_PERIPHERAL_PREF_TIMEOUT=500 CONFIG_BT_GAP_AUTO_UPDATE_CONN_PARAMS=y The last line may be redundant, as it is enabled by default. It allows the peripheral to request a change in connection parameters after the initial connection. To get notified of the new parameters, we can implement the on_conn_param_update callback: static void handle_conn_param_change(struct bt_conn *conn, uint16_t interval, uint16_t latency, uint16_t timeout) { double interval_ms = interval * 1.25; uint16_t timeout_ms = timeout * 10; LOG_INF(\"Params changed: %.2f ms, latency %u, timeout %u ms\", interval_ms, latency, timeout_ms); }","title":"In Action"},{"location":"ble-04-conn-params/#phy-radio-modes","text":"The default mode is 1M PHY (1 Mbps), which is used for compatibility. 2M PHY (2 Mbps): Doubles throughput, reduces time on air, but may shorten range. Coded PHY : Increases range using redundancy, but at a lower data rate (125 kbps or 500 kbps).","title":"PHY Radio Modes"},{"location":"ble-04-conn-params/#in-action_1","text":"First, we need to enable the PHY feature in the prj.conf file: CONFIG_BT_USER_PHY_UPDATE=y We can set the PHY mode again in the on_connect callback: static void on_conn_established(struct bt_conn *conn, uint8_t err) { // ... other code const struct bt_conn_le_phy_param phy_pref = { .options = BT_CONN_LE_PHY_OPT_NONE, .pref_rx_phy = BT_GAP_LE_PHY_2M, .pref_tx_phy = BT_GAP_LE_PHY_2M, }; int err = bt_conn_le_phy_update(conn, &phy_pref); if (err) { LOG_ERR(\"PHY update failed (%d)\", err); } // ... other code } To get notified of the PHY change, we can implement the on_phy_update callback: static void handle_phy_change(struct bt_conn *conn, struct bt_conn_le_phy_info *info) { switch (info->tx_phy) { case BT_CONN_LE_TX_POWER_PHY_1M: LOG_INF(\"PHY switched to 1M\"); break; case BT_CONN_LE_TX_POWER_PHY_2M: LOG_INF(\"PHY switched to 2M\"); break; case BT_CONN_LE_TX_POWER_PHY_CODED_S8: LOG_INF(\"PHY switched to Long Range\"); break; default: LOG_INF(\"PHY changed to unknown mode\"); break; } }","title":"In Action"},{"location":"ble-04-conn-params/#data-length-vs-mtu","text":"To understand how these differ, it's helpful to recall the Bluetooth LE stack layers : - GATT (Generic Attribute Profile): Application layer. You usually interact here. - L2CAP : Handles segmentation and reassembly of packets. - Link Layer : The lowest level; handles actual radio transmission.","title":"Data Length vs MTU"},{"location":"ble-04-conn-params/#mtu-maximum-transmission-unit","text":"Maximum size of a single GATT operation (covered in next page). Default: 23 bytes. Can be increased after connection using MTU Exchange . Operates at the GATT / L2CAP level . You configure the maximum value with: Kconfig CONFIG_BT_L2CAP_TX_MTU=247","title":"MTU (Maximum Transmission Unit)"},{"location":"ble-04-conn-params/#data-length","text":"Maximum size of a single Link Layer PDU (packet). Default: 27 bytes. With BLE 4.2+, it can go up to 251 bytes . Controlled via Data Length Extension (DLE) . Even with a high MTU, a small data length will result in packet fragmentation . Configure this with: Kconfig CONFIG_BT_CTLR_DATA_LENGTH_MAX=251 CONFIG_BT_BUF_ACL_TX_SIZE=251 CONFIG_BT_BUF_ACL_RX_SIZE=251","title":"Data Length"},{"location":"ble-04-conn-params/#negotiating-mtu-and-data-length-in-code","text":"Make sure data length updates are enabled: CONFIG_BT_USER_DATA_LEN_UPDATE=y Then, in your on_connected() callback: // Request a data length update (TX only) struct bt_conn_le_data_len_param len_params = { .tx_max_len = BT_GAP_DATA_LEN_MAX, // Usually 251 .tx_max_time = BT_GAP_DATA_TIME_MAX, // Usually 0x4290 (17040 \u00b5s) }; int err = bt_conn_le_data_len_update(conn, &len_params); if (err) { LOG_ERR(\"Failed to update data length (%d)\", err); } Why only TX? Because you can only propose values for your side of the connection. The peer will reply with what it supports for both TX and RX. The callback later gives you the final values for both ends. To negotiate the MTU: // Start MTU exchange \u2014 no need to specify desired MTU static struct bt_gatt_exchange_params params = { .func = mtu_exchange_cb // Called when negotiation is done }; err = bt_gatt_exchange_mtu(conn, &params); if (err) { LOG_ERR(\"MTU exchange failed (%d)\", err); } \ud83d\udcdd Why don't we set a value in params ? You don\u2019t pass the MTU manually. The stack reads CONFIG_BT_L2CAP_TX_MTU and automatically includes that in the ATT_Exchange_MTU_Request . The negotiated MTU is then: c min(our_mtu, peer_mtu) The callback: static void mtu_exchange_cb(struct bt_conn *conn, uint8_t err, struct bt_gatt_exchange_params *params) { if (!err) { uint16_t app_mtu = bt_gatt_get_mtu(conn) - 3; // 3 bytes = ATT header LOG_INF(\"MTU negotiated: %u bytes\", app_mtu); } else { LOG_ERR(\"MTU exchange failed (ATT err %u)\", err); } }","title":"Negotiating MTU and Data Length in Code"},{"location":"ble-04-conn-params/#result-callback-confirms-what-was-accepted","text":"static void handle_data_len_change(struct bt_conn *conn, struct bt_conn_le_data_len_info *info) { LOG_INF(\"Data len: TX=%u (%uus), RX=%u (%uus)\", info->tx_max_len, info->tx_max_time, info->rx_max_len, info->rx_max_time); } \ud83d\udcdd This tells you what both sides agreed on after negotiation \u2014 your request vs. what the peer supports. - TX: What you send - RX: What you receive","title":"Result: Callback confirms what was accepted"},{"location":"ble-05-gatt-client/","text":"05 - BLE GATT Client-Initiated Operations Author: Tony Fu Date: 2025/4/6 Device: nRF52840 Dongle Toolchain: nRF Connect SDK v2.8.0 In the GATT protocol, the server holds the data. The client can request the server to perform operations such as read , write , or write without response \u2014 these are known as client-initiated operations . Alternatively, the client can subscribe to notifications or indications , which are server-initiated operations . This note focuses on client-initiated operations . The server-side implementation will be covered in a later note. We will walk through how to define a custom 128-bit UUID GATT service with both readable and writable characteristics in Zephyr, using the Nordic SDK style. 1. Create a File: my_service.h This header will define the UUIDs, callback types, and initialization function needed for the custom service. 2. Encode the UUIDs Using BT_UUID_128_ENCODE Zephyr provides a helper macro to define a 128-bit UUID: BT_UUID_128_ENCODE(w32, w1, w2, w3, w48) This macro converts your UUID into little-endian byte order suitable for Zephyr\u2019s internal structures. It's commonly used when defining: - Service UUIDs - Characteristic UUIDs - Advertising UUIDs Parameters: Param Size Description w32 32b First field of the UUID w1 16b Second field w2 16b Third field w3 16b Fourth field w48 48b Final field (usually vendor part) Just take your UUID, replace the dashes with commas, and prefix each value with 0x . Example: If your 128-bit UUID is: 12345678-9abc-def0-1234-56789abcdef0 You can encode it like: #define BT_UUID_MY_SERVICE_VAL \\ BT_UUID_128_ENCODE(0x12345678, 0x9abc, 0xdef0, 0x1234, 0x56789abcdef0) And then define characteristics with similar base UUIDs: #define BT_UUID_MY_CHAR_READ_VAL \\ BT_UUID_128_ENCODE(0x12345678, 0x9abc, 0xdef0, 0x1234, 0x56789abcdef1) #define BT_UUID_MY_CHAR_WRITE_VAL \\ BT_UUID_128_ENCODE(0x12345678, 0x9abc, 0xdef0, 0x1234, 0x56789abcdef2) \ud83d\udca1 Naming convention (rule of thumb): - The first few fields can vary by purpose (e.g., 1 service, multiple characteristics). - The final 48 bits are often treated as the vendor-defined base. - No strict rules \u2014 just make sure they\u2019re unique. 3. Declare the UUIDs Encoding a UUID gives you a byte array. To use them in APIs like BT_GATT_PRIMARY_SERVICE() or BT_GATT_CHARACTERISTIC() , you must wrap them with BT_UUID_DECLARE_128() : #define BT_UUID_MY_SERVICE BT_UUID_DECLARE_128(BT_UUID_MY_SERVICE_VAL) #define BT_UUID_MY_CHAR_READ BT_UUID_DECLARE_128(BT_UUID_MY_CHAR_READ_VAL) #define BT_UUID_MY_CHAR_WRITE BT_UUID_DECLARE_128(BT_UUID_MY_CHAR_WRITE_VAL) This declares each UUID as a const struct bt_uuid * that can be used with Zephyr\u2019s GATT API. 4. Create a File: my_service.c This file implements the callbacks, the internal state, and defines the GATT service. 5. Implement the Read Callback Include the needed headers: #include <zephyr/bluetooth/bluetooth.h> #include <zephyr/bluetooth/gatt.h> Implement the read callback: static uint8_t stored_value; static ssize_t on_read(struct bt_conn *conn, const struct bt_gatt_attr *attr, void *buf, uint16_t len, uint16_t offset) { LOG_INF(\"Read request received\"); return bt_gatt_attr_read(conn, attr, buf, len, offset, &stored_value, sizeof(stored_value)); } bt_gatt_attr_read() is a helper that reads from a memory buffer and does bounds checking for you. 6. Implement the Write Callback static struct my_service_cb service_cb; static ssize_t on_write(struct bt_conn *conn, const struct bt_gatt_attr *attr, const void *buf, uint16_t len, uint16_t offset, uint8_t flags) { if (offset != 0 || len != 1) { return BT_GATT_ERR(BT_ATT_ERR_INVALID_ATTRIBUTE_LEN); } uint8_t val = *((uint8_t *)buf); stored_value = val; LOG_INF(\"New value written: %d\", stored_value); if (service_cb.on_write) { service_cb.on_write(val); } return len; } You can choose to act immediately on the written value, or store it for later use. 7. Define a Callback Struct and Init Function Define the callback type and storage: typedef void (*my_write_cb_t)(uint8_t new_value); struct my_service_cb { my_write_cb_t on_write; }; Then implement a simple init function: int my_service_init(struct my_service_cb *cb) { if (cb) { service_cb = *cb; } LOG_INF(\"Custom service initialized\"); return 0; } This lets users register custom application logic on writes. 8. Define the GATT Service Declare your service and characteristics using BT_GATT_SERVICE_DEFINE : BT_GATT_SERVICE_DEFINE(my_svc, BT_GATT_PRIMARY_SERVICE(BT_UUID_MY_SERVICE), BT_GATT_CHARACTERISTIC(BT_UUID_MY_CHAR_READ, BT_GATT_CHRC_READ, BT_GATT_PERM_READ, on_read, NULL, &stored_value), BT_GATT_CHARACTERISTIC(BT_UUID_MY_CHAR_WRITE, BT_GATT_CHRC_WRITE, BT_GATT_PERM_WRITE, NULL, on_write, NULL) ); 9. Use the Service in main.c Register your service in main() : #include \"my_service.h\" void my_write_handler(uint8_t value) { LOG_INF(\"Value changed by client to %d\", value); } void main(void) { bt_enable(NULL); struct my_service_cb cb = { .on_write = my_write_handler, }; my_service_init(&cb); bt_le_adv_start(BT_LE_ADV_CONN, ad, ARRAY_SIZE(ad), sd, ARRAY_SIZE(sd)); }","title":"BLE-GATT Client Operations"},{"location":"ble-05-gatt-client/#05-ble-gatt-client-initiated-operations","text":"Author: Tony Fu Date: 2025/4/6 Device: nRF52840 Dongle Toolchain: nRF Connect SDK v2.8.0 In the GATT protocol, the server holds the data. The client can request the server to perform operations such as read , write , or write without response \u2014 these are known as client-initiated operations . Alternatively, the client can subscribe to notifications or indications , which are server-initiated operations . This note focuses on client-initiated operations . The server-side implementation will be covered in a later note. We will walk through how to define a custom 128-bit UUID GATT service with both readable and writable characteristics in Zephyr, using the Nordic SDK style.","title":"05 - BLE GATT Client-Initiated Operations"},{"location":"ble-05-gatt-client/#1-create-a-file-my_serviceh","text":"This header will define the UUIDs, callback types, and initialization function needed for the custom service.","title":"1. Create a File: my_service.h"},{"location":"ble-05-gatt-client/#2-encode-the-uuids-using-bt_uuid_128_encode","text":"Zephyr provides a helper macro to define a 128-bit UUID: BT_UUID_128_ENCODE(w32, w1, w2, w3, w48) This macro converts your UUID into little-endian byte order suitable for Zephyr\u2019s internal structures. It's commonly used when defining: - Service UUIDs - Characteristic UUIDs - Advertising UUIDs","title":"2. Encode the UUIDs Using BT_UUID_128_ENCODE"},{"location":"ble-05-gatt-client/#parameters","text":"Param Size Description w32 32b First field of the UUID w1 16b Second field w2 16b Third field w3 16b Fourth field w48 48b Final field (usually vendor part) Just take your UUID, replace the dashes with commas, and prefix each value with 0x .","title":"Parameters:"},{"location":"ble-05-gatt-client/#example","text":"If your 128-bit UUID is: 12345678-9abc-def0-1234-56789abcdef0 You can encode it like: #define BT_UUID_MY_SERVICE_VAL \\ BT_UUID_128_ENCODE(0x12345678, 0x9abc, 0xdef0, 0x1234, 0x56789abcdef0) And then define characteristics with similar base UUIDs: #define BT_UUID_MY_CHAR_READ_VAL \\ BT_UUID_128_ENCODE(0x12345678, 0x9abc, 0xdef0, 0x1234, 0x56789abcdef1) #define BT_UUID_MY_CHAR_WRITE_VAL \\ BT_UUID_128_ENCODE(0x12345678, 0x9abc, 0xdef0, 0x1234, 0x56789abcdef2) \ud83d\udca1 Naming convention (rule of thumb): - The first few fields can vary by purpose (e.g., 1 service, multiple characteristics). - The final 48 bits are often treated as the vendor-defined base. - No strict rules \u2014 just make sure they\u2019re unique.","title":"Example:"},{"location":"ble-05-gatt-client/#3-declare-the-uuids","text":"Encoding a UUID gives you a byte array. To use them in APIs like BT_GATT_PRIMARY_SERVICE() or BT_GATT_CHARACTERISTIC() , you must wrap them with BT_UUID_DECLARE_128() : #define BT_UUID_MY_SERVICE BT_UUID_DECLARE_128(BT_UUID_MY_SERVICE_VAL) #define BT_UUID_MY_CHAR_READ BT_UUID_DECLARE_128(BT_UUID_MY_CHAR_READ_VAL) #define BT_UUID_MY_CHAR_WRITE BT_UUID_DECLARE_128(BT_UUID_MY_CHAR_WRITE_VAL) This declares each UUID as a const struct bt_uuid * that can be used with Zephyr\u2019s GATT API.","title":"3. Declare the UUIDs"},{"location":"ble-05-gatt-client/#4-create-a-file-my_servicec","text":"This file implements the callbacks, the internal state, and defines the GATT service.","title":"4. Create a File: my_service.c"},{"location":"ble-05-gatt-client/#5-implement-the-read-callback","text":"Include the needed headers: #include <zephyr/bluetooth/bluetooth.h> #include <zephyr/bluetooth/gatt.h> Implement the read callback: static uint8_t stored_value; static ssize_t on_read(struct bt_conn *conn, const struct bt_gatt_attr *attr, void *buf, uint16_t len, uint16_t offset) { LOG_INF(\"Read request received\"); return bt_gatt_attr_read(conn, attr, buf, len, offset, &stored_value, sizeof(stored_value)); } bt_gatt_attr_read() is a helper that reads from a memory buffer and does bounds checking for you.","title":"5. Implement the Read Callback"},{"location":"ble-05-gatt-client/#6-implement-the-write-callback","text":"static struct my_service_cb service_cb; static ssize_t on_write(struct bt_conn *conn, const struct bt_gatt_attr *attr, const void *buf, uint16_t len, uint16_t offset, uint8_t flags) { if (offset != 0 || len != 1) { return BT_GATT_ERR(BT_ATT_ERR_INVALID_ATTRIBUTE_LEN); } uint8_t val = *((uint8_t *)buf); stored_value = val; LOG_INF(\"New value written: %d\", stored_value); if (service_cb.on_write) { service_cb.on_write(val); } return len; } You can choose to act immediately on the written value, or store it for later use.","title":"6. Implement the Write Callback"},{"location":"ble-05-gatt-client/#7-define-a-callback-struct-and-init-function","text":"Define the callback type and storage: typedef void (*my_write_cb_t)(uint8_t new_value); struct my_service_cb { my_write_cb_t on_write; }; Then implement a simple init function: int my_service_init(struct my_service_cb *cb) { if (cb) { service_cb = *cb; } LOG_INF(\"Custom service initialized\"); return 0; } This lets users register custom application logic on writes.","title":"7. Define a Callback Struct and Init Function"},{"location":"ble-05-gatt-client/#8-define-the-gatt-service","text":"Declare your service and characteristics using BT_GATT_SERVICE_DEFINE : BT_GATT_SERVICE_DEFINE(my_svc, BT_GATT_PRIMARY_SERVICE(BT_UUID_MY_SERVICE), BT_GATT_CHARACTERISTIC(BT_UUID_MY_CHAR_READ, BT_GATT_CHRC_READ, BT_GATT_PERM_READ, on_read, NULL, &stored_value), BT_GATT_CHARACTERISTIC(BT_UUID_MY_CHAR_WRITE, BT_GATT_CHRC_WRITE, BT_GATT_PERM_WRITE, NULL, on_write, NULL) );","title":"8. Define the GATT Service"},{"location":"ble-05-gatt-client/#9-use-the-service-in-mainc","text":"Register your service in main() : #include \"my_service.h\" void my_write_handler(uint8_t value) { LOG_INF(\"Value changed by client to %d\", value); } void main(void) { bt_enable(NULL); struct my_service_cb cb = { .on_write = my_write_handler, }; my_service_init(&cb); bt_le_adv_start(BT_LE_ADV_CONN, ad, ARRAY_SIZE(ad), sd, ARRAY_SIZE(sd)); }","title":"9. Use the Service in main.c"},{"location":"ble-06-gatt-server/","text":"06 - BLE GATT Server-Initiated Operations Author: Tony Fu Date: 2025/4/6 Device: nRF52840 Dongle Toolchain: nRF Connect SDK v2.8.0 Before diving into server-initiated operations like notifications and indications , it\u2019s important to understand the layers beneath them: ATT and GATT . These layers form the foundation of BLE\u2019s server-client communication model. We want to get comfortable with GATT , as it\u2019s the layer most application developers interact with. But beneath GATT lies ATT , which provides the raw data transport mechanism. ATT (Attribute Protocol) ATT defines a minimal protocol for exposing data as a list of attributes on the server. Each attribute is a generic container that GATT builds upon (services, characteristics, descriptors). An ATT attribute consists of: Field Size Description Handle 2 bytes A unique ID for the attribute on the server. Used by clients to reference it. Type 2 or 16 bytes A UUID that indicates what kind of attribute this is (e.g., service, characteristic). Permission \u2014 Access control: read, write, notify, etc. Value Variable Actual data content (e.g., the characteristic's value). Common Attribute Types These are 16-bit standardized UUIDs defined by the Bluetooth SIG. They are used to define structure within a GATT service: Type (UUID) Description Meaning 0x2800 Primary Service Marks the beginning of a primary service declaration. 0x2801 Secondary Service Used to define a secondary (helper) service that is referenced by another. 0x2803 Characteristic Declaration Describes a characteristic: includes properties, handle, and UUID. 0x2901 Characteristic User Description Human-readable label (e.g., \"Heart Rate\" ). Shown in GUIs. 0x2902 Client Characteristic Configuration (CCCD) Lets clients enable notifications or indications for a characteristic. GATT uses these generic ATT attributes to structure and organize the data. The type of a characteristic is defined by its UUID, which can be a 16-bit or 128-bit value. Attribute Permissions Each attribute has a set of permissions that control how clients are allowed to interact with it \u2014 such as whether it can be read, written, or requires a secure connection. These permissions are enforced by the ATT server , regardless of what the characteristic claims to support (via its properties). Here's a mapping of common permissions: Permission Description Zephyr Macro Plain Read Client can read the attribute value. BT_GATT_PERM_READ Plain Write Client can write a new value. BT_GATT_PERM_WRITE Encrypted Read Read only allowed over an encrypted connection. BT_GATT_PERM_READ_ENCRYPT Encrypted Write Write only allowed over an encrypted connection. BT_GATT_PERM_WRITE_ENCRYPT Authenticated Read Read allowed only after authentication (e.g., MITM pairing). BT_GATT_PERM_READ_AUTHEN Authenticated Write Write allowed only after authentication (e.g., MITM pairing). BT_GATT_PERM_WRITE_AUTHEN LESC Read Read requires LE Secure Connections. BT_GATT_PERM_READ_LESC LESC Write Write requires LE Secure Connections. BT_GATT_PERM_WRITE_LESC Prepare Write Attribute supports queued writes (long/atomic writes). BT_GATT_PERM_PREPARE_WRITE \ud83d\udd10 When no appropriate permissions are granted (e.g., no BT_GATT_PERM_READ ), the server will reject the client\u2019s operation with an ATT error like Read Not Permitted . This permission layer acts independently from characteristic properties , which simply advertise what can be done \u2014 permissions control what is actually allowed at runtime. Also, here is a quick note on the different security levels (will be covered in more detail later): Encrypted access means the connection must be encrypted (e.g., after pairing). This protects data from passive eavesdropping. Authenticated access goes a step further \u2014 the connection must be encrypted and use an authenticated key (typically generated with MITM protection, like passkey entry). This defends against impersonation attacks. LESC (LE Secure Connections) is a newer pairing method introduced in Bluetooth 4.2. It uses Elliptic Curve Diffie-Hellman (ECDH) for key exchange and offers stronger protection against passive and active attacks compared to older methods. GATT (Generic Attribute Profile) The Generic Attribute Profile (GATT) defines how the low-level attributes defined by the ATT protocol are grouped and interpreted to represent meaningful data. While ATT is concerned purely with the format and transport of attributes (each with a handle, type, permissions, and value), GATT gives structure to those attributes by organizing them into logical groupings like services , characteristics , and descriptors . At its core, GATT uses multiple ATT attributes to represent each component: A Service is a collection of related characteristics (e.g., the Heart Rate Service). A Characteristic represents a data item (e.g., current heart rate) and is made up of three attributes: a declaration , a value , and optional descriptors . A Descriptor is additional metadata about a characteristic, such as a human-readable label or client configuration (e.g., enabling notifications). Each attribute is given a handle, type, permssions, and value. Handles are assgined by the server and can vary between different BLE stacks, but it is worth discussing the other three fields in more detail: 1. Service Declaration Type Permission Value 0x2800 (Primary) or 0x2801 (Secondary) Read UUID of the service (e.g., 0x180F for Battery Service) 2. Characteristic Declaration Type Permission Value 0x2803 (Characteristic Declaration) Read - Properties (1 byte): Bitfield indicating allowed operations (e.g., Read, Write, Notify). - Value Handle (2 bytes): Handle pointing to the Characteristic Value attribute. - Characteristic UUID (2 or 16 bytes): UUID of the characteristic. 3. Characteristic Value Type (UUID of Characteristic) Permission Value The UUID of the characteristic (e.g., 0x2A19 for Battery Level) Depends on characteristic (e.g., Read, Write, Notify) Raw data (e.g., sensor reading, config byte). This is the actual payload a client interacts with. 4. Descriptor Attribute (optional) Type Permission Value e.g., 0x2901 (User Description), 0x2902 (CCCD) Depends on descriptor: - 0x2901 : Read - 0x2902 : Read/Write - User Description (0x2901) : Human-readable name of the characteristic (e.g., \"Temperature\"). - CCCD (0x2902) : 2-byte bitfield that enables notifications and/or indications. - Others: May define triggers, ranges, or valid formats. Service-Initiated Operations: Indication and Notification Indication and notification are operations used to push data from a GATT server to a client. Notification is a lightweight, unacknowledged data push. It is suitable for non-critical or frequently changing data, such as sensor streams or status updates. Notifications are fast but not guaranteed to arrive. Indication is a reliable, acknowledged mechanism. Each indication must be confirmed by the client before the next can be sent. This makes it ideal for critical data or state changes that must be received. Use notification for speed and simplicity. Use indication when reliability is essential. In Action Purpose of this example This example demonstrates how to create a custom GATT service with three characteristics: Command characteristic (Write): receives a control byte from a client (e.g., phone). Critical characteristic (Indicate): used to send important data that requires acknowledgment. Non-critical characteristic (Notify): used to send less important, best-effort data. The purpose is to test how a peripheral (nRF52840 dongle) can push different types of data to a central (like a phone), depending on a command it receives. Writing 0x00 triggers a notification, while any non-zero value triggers an indication. Steps to implement Step 1. Declare UUIDs Custom 128-bit UUIDs are declared for the service and each of the three characteristics. This is just like what we have done in the previous example. #include <zephyr/types.h> #include <zephyr/bluetooth/uuid.h> #define BT_UUID_TEST_SERVICE_VAL BT_UUID_128_ENCODE(0x12345678, 0x9abc, 0xdef0, 0x1234, 0x56789abcdef0) #define BT_UUID_TEST_CMD_VAL BT_UUID_128_ENCODE(0x12345678, 0x9abc, 0xdef0, 0x1234, 0x56789abcdef1) #define BT_UUID_TEST_CRITICAL_VAL BT_UUID_128_ENCODE(0x12345678, 0x9abc, 0xdef0, 0x1234, 0x56789abcdef2) #define BT_UUID_TEST_NONCRITICAL_VAL BT_UUID_128_ENCODE(0x12345678, 0x9abc, 0xdef0, 0x1234, 0x56789abcdef3) #define BT_UUID_TEST_SERVICE BT_UUID_DECLARE_128(BT_UUID_TEST_SERVICE_VAL) #define BT_UUID_TEST_CMD BT_UUID_DECLARE_128(BT_UUID_TEST_CMD_VAL) #define BT_UUID_TEST_CRITICAL BT_UUID_DECLARE_128(BT_UUID_TEST_CRITICAL_VAL) #define BT_UUID_TEST_NONCRITICAL BT_UUID_DECLARE_128(BT_UUID_TEST_NONCRITICAL_VAL) Step 2. Define the service and characteristics Here we define the service and its characteristics using BT_GATT_SERVICE_DEFINE . Each characteristic is assigned appropriate properties ( WRITE , INDICATE , NOTIFY ) and permissions. BT_GATT_SERVICE_DEFINE(test_svc, BT_GATT_PRIMARY_SERVICE(BT_UUID_TEST_SERVICE), BT_GATT_CHARACTERISTIC(BT_UUID_TEST_CMD, BT_GATT_CHRC_WRITE, BT_GATT_PERM_WRITE, NULL, write_cmd, NULL), BT_GATT_CHARACTERISTIC(BT_UUID_TEST_CRITICAL, BT_GATT_CHRC_INDICATE, BT_GATT_PERM_NONE, NULL, NULL, NULL), BT_GATT_CCC(critical_ccc_cfg_changed, BT_GATT_PERM_READ | BT_GATT_PERM_WRITE), BT_GATT_CHARACTERISTIC(BT_UUID_TEST_NONCRITICAL, BT_GATT_CHRC_NOTIFY, BT_GATT_PERM_NONE, NULL, NULL, NULL), BT_GATT_CCC(noncritical_ccc_cfg_changed, BT_GATT_PERM_READ | BT_GATT_PERM_WRITE) ); Note : BT_GATT_CCC adds a Client Characteristic Configuration Descriptor, which allows the client to enable or disable notifications/indications. Step 3. Define the CCCD callback functions These callbacks are used in the previous step to handle changes in the CCCD values. static bool notify_enabled; static bool indicate_enabled; static void critical_ccc_cfg_changed(const struct bt_gatt_attr *attr, uint16_t value) { indicate_enabled = (value == BT_GATT_CCC_INDICATE); LOG_INF(\"Indicate enabled: %s\", indicate_enabled ? \"true\" : \"false\"); } static void noncritical_ccc_cfg_changed(const struct bt_gatt_attr *attr, uint16_t value) { notify_enabled = (value == BT_GATT_CCC_NOTIFY); LOG_INF(\"Notify enabled: %s\", notify_enabled ? \"true\" : \"false\"); } Step 4. Define the write callback function The write callback interprets the value written by the client and sends either a notification or an indication. static struct bt_gatt_indicate_params ind_params; static uint8_t dummy_cmd; static ssize_t write_cmd(struct bt_conn *conn, const struct bt_gatt_attr *attr, const void *buf, uint16_t len, uint16_t offset, uint8_t flags) { if (len != sizeof(uint8_t)) { return BT_GATT_ERR(BT_ATT_ERR_INVALID_ATTRIBUTE_LEN); } dummy_cmd = *((uint8_t *)buf); const uint32_t dummy_data = 0xAABBCCDD; if (dummy_cmd) { // Indicate critical data if (!indicate_enabled) { LOG_WRN(\"Indications not enabled\"); return -EACCES; } LOG_INF(\"Indicating critical data: %x\", dummy_data); ind_params.attr = &test_svc.attrs[3]; ind_params.func = indicate_cb; ind_params.data = &dummy_data; ind_params.len = sizeof(dummy_data); return bt_gatt_indicate(NULL, &ind_params); } else { // Notify non-critical data if (!notify_enabled) { LOG_WRN(\"Notifications not enabled\"); return -EACCES; } LOG_INF(\"Notifying non-critical data: %x\", dummy_data); return bt_gatt_notify(NULL, &test_svc.attrs[6], &dummy_data, sizeof(dummy_data)); } } Note : - bt_gatt_indicate() uses a parameter structure because it handles asynchronous acknowledgment. - bt_gatt_notify() is simpler\u2014no acknowledgment, no callback, just send. - The attr indices for .attrs[3] and .attrs[6] refer to the characteristic declaration attribute , not the value or CCCD. Remember: - Service declaration = 1 attribute - Each characteristic = 2 attributes (declaration + value) - Optional CCCD = 1 attribute - So manually counting the offsets is required unless dynamic lookup is used. Step 5. Define the indication callback This is called after the client acknowledges the indication. static void indicate_cb(struct bt_conn *conn, struct bt_gatt_indicate_params *params, uint8_t err) { LOG_DBG(\"Indication result: %s\", err == 0U ? \"success\" : \"fail\"); }","title":"BLE-GATT Server Operations"},{"location":"ble-06-gatt-server/#06-ble-gatt-server-initiated-operations","text":"Author: Tony Fu Date: 2025/4/6 Device: nRF52840 Dongle Toolchain: nRF Connect SDK v2.8.0 Before diving into server-initiated operations like notifications and indications , it\u2019s important to understand the layers beneath them: ATT and GATT . These layers form the foundation of BLE\u2019s server-client communication model. We want to get comfortable with GATT , as it\u2019s the layer most application developers interact with. But beneath GATT lies ATT , which provides the raw data transport mechanism.","title":"06 - BLE GATT Server-Initiated Operations"},{"location":"ble-06-gatt-server/#att-attribute-protocol","text":"ATT defines a minimal protocol for exposing data as a list of attributes on the server. Each attribute is a generic container that GATT builds upon (services, characteristics, descriptors). An ATT attribute consists of: Field Size Description Handle 2 bytes A unique ID for the attribute on the server. Used by clients to reference it. Type 2 or 16 bytes A UUID that indicates what kind of attribute this is (e.g., service, characteristic). Permission \u2014 Access control: read, write, notify, etc. Value Variable Actual data content (e.g., the characteristic's value).","title":"ATT (Attribute Protocol)"},{"location":"ble-06-gatt-server/#common-attribute-types","text":"These are 16-bit standardized UUIDs defined by the Bluetooth SIG. They are used to define structure within a GATT service: Type (UUID) Description Meaning 0x2800 Primary Service Marks the beginning of a primary service declaration. 0x2801 Secondary Service Used to define a secondary (helper) service that is referenced by another. 0x2803 Characteristic Declaration Describes a characteristic: includes properties, handle, and UUID. 0x2901 Characteristic User Description Human-readable label (e.g., \"Heart Rate\" ). Shown in GUIs. 0x2902 Client Characteristic Configuration (CCCD) Lets clients enable notifications or indications for a characteristic. GATT uses these generic ATT attributes to structure and organize the data. The type of a characteristic is defined by its UUID, which can be a 16-bit or 128-bit value.","title":"Common Attribute Types"},{"location":"ble-06-gatt-server/#attribute-permissions","text":"Each attribute has a set of permissions that control how clients are allowed to interact with it \u2014 such as whether it can be read, written, or requires a secure connection. These permissions are enforced by the ATT server , regardless of what the characteristic claims to support (via its properties). Here's a mapping of common permissions: Permission Description Zephyr Macro Plain Read Client can read the attribute value. BT_GATT_PERM_READ Plain Write Client can write a new value. BT_GATT_PERM_WRITE Encrypted Read Read only allowed over an encrypted connection. BT_GATT_PERM_READ_ENCRYPT Encrypted Write Write only allowed over an encrypted connection. BT_GATT_PERM_WRITE_ENCRYPT Authenticated Read Read allowed only after authentication (e.g., MITM pairing). BT_GATT_PERM_READ_AUTHEN Authenticated Write Write allowed only after authentication (e.g., MITM pairing). BT_GATT_PERM_WRITE_AUTHEN LESC Read Read requires LE Secure Connections. BT_GATT_PERM_READ_LESC LESC Write Write requires LE Secure Connections. BT_GATT_PERM_WRITE_LESC Prepare Write Attribute supports queued writes (long/atomic writes). BT_GATT_PERM_PREPARE_WRITE \ud83d\udd10 When no appropriate permissions are granted (e.g., no BT_GATT_PERM_READ ), the server will reject the client\u2019s operation with an ATT error like Read Not Permitted . This permission layer acts independently from characteristic properties , which simply advertise what can be done \u2014 permissions control what is actually allowed at runtime. Also, here is a quick note on the different security levels (will be covered in more detail later): Encrypted access means the connection must be encrypted (e.g., after pairing). This protects data from passive eavesdropping. Authenticated access goes a step further \u2014 the connection must be encrypted and use an authenticated key (typically generated with MITM protection, like passkey entry). This defends against impersonation attacks. LESC (LE Secure Connections) is a newer pairing method introduced in Bluetooth 4.2. It uses Elliptic Curve Diffie-Hellman (ECDH) for key exchange and offers stronger protection against passive and active attacks compared to older methods.","title":"Attribute Permissions"},{"location":"ble-06-gatt-server/#gatt-generic-attribute-profile","text":"The Generic Attribute Profile (GATT) defines how the low-level attributes defined by the ATT protocol are grouped and interpreted to represent meaningful data. While ATT is concerned purely with the format and transport of attributes (each with a handle, type, permissions, and value), GATT gives structure to those attributes by organizing them into logical groupings like services , characteristics , and descriptors . At its core, GATT uses multiple ATT attributes to represent each component: A Service is a collection of related characteristics (e.g., the Heart Rate Service). A Characteristic represents a data item (e.g., current heart rate) and is made up of three attributes: a declaration , a value , and optional descriptors . A Descriptor is additional metadata about a characteristic, such as a human-readable label or client configuration (e.g., enabling notifications). Each attribute is given a handle, type, permssions, and value. Handles are assgined by the server and can vary between different BLE stacks, but it is worth discussing the other three fields in more detail:","title":"GATT (Generic Attribute Profile)"},{"location":"ble-06-gatt-server/#1-service-declaration","text":"Type Permission Value 0x2800 (Primary) or 0x2801 (Secondary) Read UUID of the service (e.g., 0x180F for Battery Service)","title":"1. Service Declaration"},{"location":"ble-06-gatt-server/#2-characteristic-declaration","text":"Type Permission Value 0x2803 (Characteristic Declaration) Read - Properties (1 byte): Bitfield indicating allowed operations (e.g., Read, Write, Notify). - Value Handle (2 bytes): Handle pointing to the Characteristic Value attribute. - Characteristic UUID (2 or 16 bytes): UUID of the characteristic.","title":"2. Characteristic Declaration"},{"location":"ble-06-gatt-server/#3-characteristic-value","text":"Type (UUID of Characteristic) Permission Value The UUID of the characteristic (e.g., 0x2A19 for Battery Level) Depends on characteristic (e.g., Read, Write, Notify) Raw data (e.g., sensor reading, config byte). This is the actual payload a client interacts with.","title":"3. Characteristic Value"},{"location":"ble-06-gatt-server/#4-descriptor-attribute-optional","text":"Type Permission Value e.g., 0x2901 (User Description), 0x2902 (CCCD) Depends on descriptor: - 0x2901 : Read - 0x2902 : Read/Write - User Description (0x2901) : Human-readable name of the characteristic (e.g., \"Temperature\"). - CCCD (0x2902) : 2-byte bitfield that enables notifications and/or indications. - Others: May define triggers, ranges, or valid formats.","title":"4. Descriptor Attribute (optional)"},{"location":"ble-06-gatt-server/#service-initiated-operations-indication-and-notification","text":"Indication and notification are operations used to push data from a GATT server to a client. Notification is a lightweight, unacknowledged data push. It is suitable for non-critical or frequently changing data, such as sensor streams or status updates. Notifications are fast but not guaranteed to arrive. Indication is a reliable, acknowledged mechanism. Each indication must be confirmed by the client before the next can be sent. This makes it ideal for critical data or state changes that must be received. Use notification for speed and simplicity. Use indication when reliability is essential.","title":"Service-Initiated Operations: Indication and Notification"},{"location":"ble-06-gatt-server/#in-action","text":"","title":"In Action"},{"location":"ble-06-gatt-server/#purpose-of-this-example","text":"This example demonstrates how to create a custom GATT service with three characteristics: Command characteristic (Write): receives a control byte from a client (e.g., phone). Critical characteristic (Indicate): used to send important data that requires acknowledgment. Non-critical characteristic (Notify): used to send less important, best-effort data. The purpose is to test how a peripheral (nRF52840 dongle) can push different types of data to a central (like a phone), depending on a command it receives. Writing 0x00 triggers a notification, while any non-zero value triggers an indication.","title":"Purpose of this example"},{"location":"ble-06-gatt-server/#steps-to-implement","text":"","title":"Steps to implement"},{"location":"ble-06-gatt-server/#step-1-declare-uuids","text":"Custom 128-bit UUIDs are declared for the service and each of the three characteristics. This is just like what we have done in the previous example. #include <zephyr/types.h> #include <zephyr/bluetooth/uuid.h> #define BT_UUID_TEST_SERVICE_VAL BT_UUID_128_ENCODE(0x12345678, 0x9abc, 0xdef0, 0x1234, 0x56789abcdef0) #define BT_UUID_TEST_CMD_VAL BT_UUID_128_ENCODE(0x12345678, 0x9abc, 0xdef0, 0x1234, 0x56789abcdef1) #define BT_UUID_TEST_CRITICAL_VAL BT_UUID_128_ENCODE(0x12345678, 0x9abc, 0xdef0, 0x1234, 0x56789abcdef2) #define BT_UUID_TEST_NONCRITICAL_VAL BT_UUID_128_ENCODE(0x12345678, 0x9abc, 0xdef0, 0x1234, 0x56789abcdef3) #define BT_UUID_TEST_SERVICE BT_UUID_DECLARE_128(BT_UUID_TEST_SERVICE_VAL) #define BT_UUID_TEST_CMD BT_UUID_DECLARE_128(BT_UUID_TEST_CMD_VAL) #define BT_UUID_TEST_CRITICAL BT_UUID_DECLARE_128(BT_UUID_TEST_CRITICAL_VAL) #define BT_UUID_TEST_NONCRITICAL BT_UUID_DECLARE_128(BT_UUID_TEST_NONCRITICAL_VAL)","title":"Step 1. Declare UUIDs"},{"location":"ble-06-gatt-server/#step-2-define-the-service-and-characteristics","text":"Here we define the service and its characteristics using BT_GATT_SERVICE_DEFINE . Each characteristic is assigned appropriate properties ( WRITE , INDICATE , NOTIFY ) and permissions. BT_GATT_SERVICE_DEFINE(test_svc, BT_GATT_PRIMARY_SERVICE(BT_UUID_TEST_SERVICE), BT_GATT_CHARACTERISTIC(BT_UUID_TEST_CMD, BT_GATT_CHRC_WRITE, BT_GATT_PERM_WRITE, NULL, write_cmd, NULL), BT_GATT_CHARACTERISTIC(BT_UUID_TEST_CRITICAL, BT_GATT_CHRC_INDICATE, BT_GATT_PERM_NONE, NULL, NULL, NULL), BT_GATT_CCC(critical_ccc_cfg_changed, BT_GATT_PERM_READ | BT_GATT_PERM_WRITE), BT_GATT_CHARACTERISTIC(BT_UUID_TEST_NONCRITICAL, BT_GATT_CHRC_NOTIFY, BT_GATT_PERM_NONE, NULL, NULL, NULL), BT_GATT_CCC(noncritical_ccc_cfg_changed, BT_GATT_PERM_READ | BT_GATT_PERM_WRITE) ); Note : BT_GATT_CCC adds a Client Characteristic Configuration Descriptor, which allows the client to enable or disable notifications/indications.","title":"Step 2. Define the service and characteristics"},{"location":"ble-06-gatt-server/#step-3-define-the-cccd-callback-functions","text":"These callbacks are used in the previous step to handle changes in the CCCD values. static bool notify_enabled; static bool indicate_enabled; static void critical_ccc_cfg_changed(const struct bt_gatt_attr *attr, uint16_t value) { indicate_enabled = (value == BT_GATT_CCC_INDICATE); LOG_INF(\"Indicate enabled: %s\", indicate_enabled ? \"true\" : \"false\"); } static void noncritical_ccc_cfg_changed(const struct bt_gatt_attr *attr, uint16_t value) { notify_enabled = (value == BT_GATT_CCC_NOTIFY); LOG_INF(\"Notify enabled: %s\", notify_enabled ? \"true\" : \"false\"); }","title":"Step 3. Define the CCCD callback functions"},{"location":"ble-06-gatt-server/#step-4-define-the-write-callback-function","text":"The write callback interprets the value written by the client and sends either a notification or an indication. static struct bt_gatt_indicate_params ind_params; static uint8_t dummy_cmd; static ssize_t write_cmd(struct bt_conn *conn, const struct bt_gatt_attr *attr, const void *buf, uint16_t len, uint16_t offset, uint8_t flags) { if (len != sizeof(uint8_t)) { return BT_GATT_ERR(BT_ATT_ERR_INVALID_ATTRIBUTE_LEN); } dummy_cmd = *((uint8_t *)buf); const uint32_t dummy_data = 0xAABBCCDD; if (dummy_cmd) { // Indicate critical data if (!indicate_enabled) { LOG_WRN(\"Indications not enabled\"); return -EACCES; } LOG_INF(\"Indicating critical data: %x\", dummy_data); ind_params.attr = &test_svc.attrs[3]; ind_params.func = indicate_cb; ind_params.data = &dummy_data; ind_params.len = sizeof(dummy_data); return bt_gatt_indicate(NULL, &ind_params); } else { // Notify non-critical data if (!notify_enabled) { LOG_WRN(\"Notifications not enabled\"); return -EACCES; } LOG_INF(\"Notifying non-critical data: %x\", dummy_data); return bt_gatt_notify(NULL, &test_svc.attrs[6], &dummy_data, sizeof(dummy_data)); } } Note : - bt_gatt_indicate() uses a parameter structure because it handles asynchronous acknowledgment. - bt_gatt_notify() is simpler\u2014no acknowledgment, no callback, just send. - The attr indices for .attrs[3] and .attrs[6] refer to the characteristic declaration attribute , not the value or CCCD. Remember: - Service declaration = 1 attribute - Each characteristic = 2 attributes (declaration + value) - Optional CCCD = 1 attribute - So manually counting the offsets is required unless dynamic lookup is used.","title":"Step 4. Define the write callback function"},{"location":"ble-06-gatt-server/#step-5-define-the-indication-callback","text":"This is called after the client acknowledges the indication. static void indicate_cb(struct bt_conn *conn, struct bt_gatt_indicate_params *params, uint8_t err) { LOG_DBG(\"Indication result: %s\", err == 0U ? \"success\" : \"fail\"); }","title":"Step 5. Define the indication callback"},{"location":"ble-07-security-modes/","text":"07 - BLE Security Modes Author: Tony Fu Date: 2025/4/13 Device: nRF52840 Dongle Toolchain: nRF Connect SDK v2.8.0 Common BLE Security Threats Here are some common threats to BLE security: Identity Tracking ( ID ) Tracking a device over time using its Bluetooth address. Prevented by using resolvable private addresses with the IRK (Identity Resolving Key) to obscure the device identity. Passive Eavesdropping ( PE ) An attacker silently listens to data over the air. Prevented by encrypting the connection. Man-in-the-Middle ( MITM ) An attacker impersonates both peers, relaying and potentially modifying messages. Prevented by authenticated pairing methods that confirm peer identity (e.g., Passkey Entry, Numeric Comparison). BLE Security Levels Security Level Description Protects Against Level 1 No security: no encryption, no authentication. None Level 2 Encrypted link using unauthenticated pairing (e.g., Just Works). PE Level 3 Encrypted link with authenticated pairing (e.g., Passkey, OOB with Legacy). PE, basic MITM Level 4 Encrypted link with LE Secure Connections + authentication . PE, MITM, ID (with privacy) Notes: All connections start at Level 1 , then upgrade during pairing. Just Works leads to Level 2 \u2014 encrypted but not authenticated. Passkey Entry or OOB leads to Level 3 . Level 4 requires both devices to support LE Secure Connections and use authenticated pairing. Privacy (ID protection) is separate from these levels but essential to combat identity tracking . Connecting vs Pairing vs Bonding Before diving into BLE security modes, it's important to understand three foundational terms: connecting , pairing , and bonding . These steps form the basis of how two Bluetooth devices establish trust. While connecting simply creates a communication link, pairing is the beginning of any real security\u2014it\u2019s when encryption keys are generated and exchanged. Bonding builds on pairing by storing that trust for future sessions. Connecting Establishes a temporary link between two BLE devices. No security by default. Pairing Establishes trusted relationship for the current session. Negotiates and exchanges encryption keys. Enables secure data transfer (encryption, authentication). Bonding Saves pairing information (keys) to non-volatile memory . Allows devices to reconnect securely without re-pairing . Typically happens automatically after successful pairing if both devices support it. In short: Connect \u2192 Pair \u2192 Bond (optional but persistent) . More on Pairing The pairing process can be further divided into three distinct phases: Phase 1: Pairing Feature Exchange Initiated by the central device via a Pairing Request . The peripheral responds with a Pairing Response . Devices exchange their: I/O capabilities (e.g., keyboard, display, none). OOB and MITM flags (to determine required security). Supported authentication and encryption options . Whether they wish to bond or just pair temporarily. Based on this information, the devices will choose an appropriate pairing method in Phase 2. Phase 2: Key Generation and Authentication Devices perform cryptographic operations to generate encryption keys. Depending on the pairing mode: Legacy Pairing : Generates a Short Term Key (STK) from a Temporary Key (TK) . LE Secure Connections : Uses Elliptic Curve Diffie-Hellman (ECDH) to generate a Long Term Key (LTK) directly and securely. The actual pairing method used depends on capabilities and flags: Just Works (unauthenticated) Passkey Entry (user types in/display 6-digit code) Out-of-Band (OOB) (e.g., via NFC) Numeric Comparison (LE Secure Connections only) This phase determines how secure the pairing is \u2014 especially whether it's protected against MITM attacks. Phase 3: Key Distribution (only if bonding) If bonding is agreed upon, devices exchange and store keys: LTK (used to encrypt future connections) IRK (Identity Resolving Key for address privacy) CSRK (for signed data, optional) These keys are saved to non-volatile memory so that future reconnections can skip pairing and resume secure communication immediately. More on Phase 2: Pairing Methods The method used to perform pairing directly affects the security level . Method Authentication Requires User Interaction MITM Protection Available In Just Works \u274c No Minimal (accept prompt) \u274c No Legacy & LE Secure Connections Passkey Entry \u2705 Yes Yes (input or display) \u2705 Yes Legacy & LE Secure Connections Out of Band (OOB) \u2705 Yes External channel (e.g., NFC) \u2705 Yes Legacy & LE Secure Connections Numeric Comparison \u2705 Yes Yes (compare 6-digit number) \u2705 Yes LE Secure Connections only Details Just Works The simplest pairing method. Devices derive encryption keys without authentication. Used when neither device has a display or keyboard (e.g., most wearables). Susceptible to MITM attacks , as the user cannot verify peer identity. Results in Security Level 2 (unauthenticated encryption). Passkey Entry A 6-digit passkey is shown on one device and entered on the other. Which device displays or inputs depends on I/O capabilities. Provides authenticated pairing , resistant to MITM. Yields Security Level 3 (authenticated encryption). Out of Band (OOB) Key material is exchanged over an external medium (e.g., NFC , QR codes). Ideal for devices with limited BLE I/O but secure secondary channels. Only one device needs to support OOB for it to be used (in Secure Connections). Provides MITM protection, assuming the OOB channel is trusted. Numeric Comparison Both devices display the same 6-digit number. The user confirms if the numbers match (presses \u201cYes\u201d). Ensures that no attacker is relaying the connection. Only available in LE Secure Connections . Offers strong MITM protection and Security Level 4 . How Pairing Method is Selected Pairing method selection is automatic and based on: - Devices' I/O capabilities - OOB and MITM flags exchanged in Phase 1 - Support for LE Secure Connections If OOB is supported , it is chosen. Otherwise, if MITM is required , Passkey Entry or Numeric Comparison is used. If neither applies, Just Works is used by default. In Action In this section, we\u2019ll define two writable characteristics: - One that requires encryption to access - Another that requires authentication When you try to write to either from your phone app, the device will prompt you to pair, depending on the required security level. 1. Enable pairing support Enable the Security Manager Protocol (SMP) in your prj.conf : CONFIG_BT_SMP=y 2. Declare the characteristic UUIDs Just like in previous examples, define custom UUIDs for the service and its characteristics: #define BT_UUID_TEST_SERVICE_VAL BT_UUID_128_ENCODE(0x12345678, 0x9abc, 0xdef0, 0x1234, 0x56789abcdef0) #define BT_UUID_TEST_ENCRYPT_VAL BT_UUID_128_ENCODE(0x12345678, 0x9abc, 0xdef0, 0x1234, 0x56789abcdef1) #define BT_UUID_TEST_SERVICE BT_UUID_DECLARE_128(BT_UUID_TEST_SERVICE_VAL) #define BT_UUID_TEST_ENCRYPT BT_UUID_DECLARE_128(BT_UUID_TEST_ENCRYPT_VAL) 3. Define the characteristics We use BT_GATT_PERM_WRITE_ENCRYPT to require link encryption for writing: BT_GATT_SERVICE_DEFINE(my_svc, BT_GATT_PRIMARY_SERVICE(BT_UUID_TEST_SERVICE), // Encrypted write characteristic BT_GATT_CHARACTERISTIC(BT_UUID_TEST_ENCRYPT, BT_GATT_CHRC_WRITE, BT_GATT_PERM_WRITE_ENCRYPT, NULL, encrypt_write, NULL), ); 4. Implement the write handler Same as earlier examples (not shown here). It will be called once security is sufficient. 5. Track security level changes Use the security_changed callback to monitor when the connection is encrypted or authenticated: static void on_security_changed(struct bt_conn *conn, bt_security_t level, enum bt_security_err err) { char peer_addr[BT_ADDR_LE_STR_LEN]; bt_addr_le_to_str(bt_conn_get_dst(conn), peer_addr, sizeof(peer_addr)); if (err == 0) { LOG_INF(\"Link secured with %s (level %u)\", peer_addr, level); } else { LOG_WRN(\"Security setup failed with %s (level %u, err %d)\", peer_addr, level, err); } } struct bt_conn_cb connection_callbacks = { .connected = on_connected, .disconnected = on_disconnected, .security_changed = on_security_changed, }; 6. Attempt a write When you try to write to the encrypted characteristic, the phone will prompt you to pair. Once encrypted, the connection will be promoted to Security Level 2 . 7. Unpair before moving on To start fresh: - On your phone, unpair the device via Bluetooth settings. - In firmware, clear bonding info with: bt_unpair(BT_ID_DEFAULT, NULL); 8. Add an authenticated characteristic Now define a second characteristic that requires authentication : #define BT_UUID_TEST_AUTHEN_VAL BT_UUID_128_ENCODE(0x12345678, 0x9abc, 0xdef0, 0x1234, 0x56789abcdef2) #define BT_UUID_TEST_AUTHEN BT_UUID_DECLARE_128(BT_UUID_TEST_AUTHEN_VAL) BT_GATT_SERVICE_DEFINE(my_svc, BT_GATT_PRIMARY_SERVICE(BT_UUID_TEST_SERVICE), // Encrypted write characteristic BT_GATT_CHARACTERISTIC(BT_UUID_TEST_ENCRYPT, BT_GATT_CHRC_WRITE, BT_GATT_PERM_WRITE_ENCRYPT, NULL, encrypt_write, NULL), // Authenticated write characteristic BT_GATT_CHARACTERISTIC(BT_UUID_TEST_AUTHEN, BT_GATT_CHRC_WRITE, BT_GATT_PERM_WRITE_AUTHEN, NULL, authen_write, NULL), ); 9. Display the passkey To complete an authenticated pairing, we need to show the user a passkey. This is done using the authentication callbacks: static void display_passkey(struct bt_conn *conn, unsigned int passkey) { char peer_addr[BT_ADDR_LE_STR_LEN]; bt_addr_le_to_str(bt_conn_get_dst(conn), peer_addr, sizeof(peer_addr)); LOG_INF(\"Enter passkey on %s: %06u\", peer_addr, passkey); } static void cancel_authentication(struct bt_conn *conn) { char peer_addr[BT_ADDR_LE_STR_LEN]; bt_addr_le_to_str(bt_conn_get_dst(conn), peer_addr, sizeof(peer_addr)); LOG_INF(\"Pairing canceled by remote: %s\", peer_addr); } static const struct bt_conn_auth_cb auth_callbacks = { .passkey_display = display_passkey, .cancel = cancel_authentication, }; 10. Register authentication handlers Don't forget to register your callbacks during initialization: int main(void) { bt_unpair(BT_ID_DEFAULT, NULL); bt_conn_auth_cb_register(&auth_callbacks); bt_conn_cb_register(&connection_callbacks); bt_enable(NULL); // Other setup... }","title":"BLE-Security Modes"},{"location":"ble-07-security-modes/#07-ble-security-modes","text":"Author: Tony Fu Date: 2025/4/13 Device: nRF52840 Dongle Toolchain: nRF Connect SDK v2.8.0","title":"07 - BLE Security Modes"},{"location":"ble-07-security-modes/#common-ble-security-threats","text":"Here are some common threats to BLE security:","title":"Common BLE Security Threats"},{"location":"ble-07-security-modes/#identity-tracking-id","text":"Tracking a device over time using its Bluetooth address. Prevented by using resolvable private addresses with the IRK (Identity Resolving Key) to obscure the device identity.","title":"Identity Tracking (ID)"},{"location":"ble-07-security-modes/#passive-eavesdropping-pe","text":"An attacker silently listens to data over the air. Prevented by encrypting the connection.","title":"Passive Eavesdropping (PE)"},{"location":"ble-07-security-modes/#man-in-the-middle-mitm","text":"An attacker impersonates both peers, relaying and potentially modifying messages. Prevented by authenticated pairing methods that confirm peer identity (e.g., Passkey Entry, Numeric Comparison).","title":"Man-in-the-Middle (MITM)"},{"location":"ble-07-security-modes/#ble-security-levels","text":"Security Level Description Protects Against Level 1 No security: no encryption, no authentication. None Level 2 Encrypted link using unauthenticated pairing (e.g., Just Works). PE Level 3 Encrypted link with authenticated pairing (e.g., Passkey, OOB with Legacy). PE, basic MITM Level 4 Encrypted link with LE Secure Connections + authentication . PE, MITM, ID (with privacy)","title":"BLE Security Levels"},{"location":"ble-07-security-modes/#notes","text":"All connections start at Level 1 , then upgrade during pairing. Just Works leads to Level 2 \u2014 encrypted but not authenticated. Passkey Entry or OOB leads to Level 3 . Level 4 requires both devices to support LE Secure Connections and use authenticated pairing. Privacy (ID protection) is separate from these levels but essential to combat identity tracking .","title":"Notes:"},{"location":"ble-07-security-modes/#connecting-vs-pairing-vs-bonding","text":"Before diving into BLE security modes, it's important to understand three foundational terms: connecting , pairing , and bonding . These steps form the basis of how two Bluetooth devices establish trust. While connecting simply creates a communication link, pairing is the beginning of any real security\u2014it\u2019s when encryption keys are generated and exchanged. Bonding builds on pairing by storing that trust for future sessions. Connecting Establishes a temporary link between two BLE devices. No security by default. Pairing Establishes trusted relationship for the current session. Negotiates and exchanges encryption keys. Enables secure data transfer (encryption, authentication). Bonding Saves pairing information (keys) to non-volatile memory . Allows devices to reconnect securely without re-pairing . Typically happens automatically after successful pairing if both devices support it. In short: Connect \u2192 Pair \u2192 Bond (optional but persistent) .","title":"Connecting vs Pairing vs Bonding"},{"location":"ble-07-security-modes/#more-on-pairing","text":"The pairing process can be further divided into three distinct phases:","title":"More on Pairing"},{"location":"ble-07-security-modes/#phase-1-pairing-feature-exchange","text":"Initiated by the central device via a Pairing Request . The peripheral responds with a Pairing Response . Devices exchange their: I/O capabilities (e.g., keyboard, display, none). OOB and MITM flags (to determine required security). Supported authentication and encryption options . Whether they wish to bond or just pair temporarily. Based on this information, the devices will choose an appropriate pairing method in Phase 2.","title":"Phase 1: Pairing Feature Exchange"},{"location":"ble-07-security-modes/#phase-2-key-generation-and-authentication","text":"Devices perform cryptographic operations to generate encryption keys. Depending on the pairing mode: Legacy Pairing : Generates a Short Term Key (STK) from a Temporary Key (TK) . LE Secure Connections : Uses Elliptic Curve Diffie-Hellman (ECDH) to generate a Long Term Key (LTK) directly and securely. The actual pairing method used depends on capabilities and flags: Just Works (unauthenticated) Passkey Entry (user types in/display 6-digit code) Out-of-Band (OOB) (e.g., via NFC) Numeric Comparison (LE Secure Connections only) This phase determines how secure the pairing is \u2014 especially whether it's protected against MITM attacks.","title":"Phase 2: Key Generation and Authentication"},{"location":"ble-07-security-modes/#phase-3-key-distribution-only-if-bonding","text":"If bonding is agreed upon, devices exchange and store keys: LTK (used to encrypt future connections) IRK (Identity Resolving Key for address privacy) CSRK (for signed data, optional) These keys are saved to non-volatile memory so that future reconnections can skip pairing and resume secure communication immediately.","title":"Phase 3: Key Distribution (only if bonding)"},{"location":"ble-07-security-modes/#more-on-phase-2-pairing-methods","text":"The method used to perform pairing directly affects the security level . Method Authentication Requires User Interaction MITM Protection Available In Just Works \u274c No Minimal (accept prompt) \u274c No Legacy & LE Secure Connections Passkey Entry \u2705 Yes Yes (input or display) \u2705 Yes Legacy & LE Secure Connections Out of Band (OOB) \u2705 Yes External channel (e.g., NFC) \u2705 Yes Legacy & LE Secure Connections Numeric Comparison \u2705 Yes Yes (compare 6-digit number) \u2705 Yes LE Secure Connections only","title":"More on Phase 2: Pairing Methods"},{"location":"ble-07-security-modes/#details","text":"","title":"Details"},{"location":"ble-07-security-modes/#just-works","text":"The simplest pairing method. Devices derive encryption keys without authentication. Used when neither device has a display or keyboard (e.g., most wearables). Susceptible to MITM attacks , as the user cannot verify peer identity. Results in Security Level 2 (unauthenticated encryption).","title":"Just Works"},{"location":"ble-07-security-modes/#passkey-entry","text":"A 6-digit passkey is shown on one device and entered on the other. Which device displays or inputs depends on I/O capabilities. Provides authenticated pairing , resistant to MITM. Yields Security Level 3 (authenticated encryption).","title":"Passkey Entry"},{"location":"ble-07-security-modes/#out-of-band-oob","text":"Key material is exchanged over an external medium (e.g., NFC , QR codes). Ideal for devices with limited BLE I/O but secure secondary channels. Only one device needs to support OOB for it to be used (in Secure Connections). Provides MITM protection, assuming the OOB channel is trusted.","title":"Out of Band (OOB)"},{"location":"ble-07-security-modes/#numeric-comparison","text":"Both devices display the same 6-digit number. The user confirms if the numbers match (presses \u201cYes\u201d). Ensures that no attacker is relaying the connection. Only available in LE Secure Connections . Offers strong MITM protection and Security Level 4 .","title":"Numeric Comparison"},{"location":"ble-07-security-modes/#how-pairing-method-is-selected","text":"Pairing method selection is automatic and based on: - Devices' I/O capabilities - OOB and MITM flags exchanged in Phase 1 - Support for LE Secure Connections If OOB is supported , it is chosen. Otherwise, if MITM is required , Passkey Entry or Numeric Comparison is used. If neither applies, Just Works is used by default.","title":"How Pairing Method is Selected"},{"location":"ble-07-security-modes/#in-action","text":"In this section, we\u2019ll define two writable characteristics: - One that requires encryption to access - Another that requires authentication When you try to write to either from your phone app, the device will prompt you to pair, depending on the required security level.","title":"In Action"},{"location":"ble-07-security-modes/#1-enable-pairing-support","text":"Enable the Security Manager Protocol (SMP) in your prj.conf : CONFIG_BT_SMP=y","title":"1. Enable pairing support"},{"location":"ble-07-security-modes/#2-declare-the-characteristic-uuids","text":"Just like in previous examples, define custom UUIDs for the service and its characteristics: #define BT_UUID_TEST_SERVICE_VAL BT_UUID_128_ENCODE(0x12345678, 0x9abc, 0xdef0, 0x1234, 0x56789abcdef0) #define BT_UUID_TEST_ENCRYPT_VAL BT_UUID_128_ENCODE(0x12345678, 0x9abc, 0xdef0, 0x1234, 0x56789abcdef1) #define BT_UUID_TEST_SERVICE BT_UUID_DECLARE_128(BT_UUID_TEST_SERVICE_VAL) #define BT_UUID_TEST_ENCRYPT BT_UUID_DECLARE_128(BT_UUID_TEST_ENCRYPT_VAL)","title":"2. Declare the characteristic UUIDs"},{"location":"ble-07-security-modes/#3-define-the-characteristics","text":"We use BT_GATT_PERM_WRITE_ENCRYPT to require link encryption for writing: BT_GATT_SERVICE_DEFINE(my_svc, BT_GATT_PRIMARY_SERVICE(BT_UUID_TEST_SERVICE), // Encrypted write characteristic BT_GATT_CHARACTERISTIC(BT_UUID_TEST_ENCRYPT, BT_GATT_CHRC_WRITE, BT_GATT_PERM_WRITE_ENCRYPT, NULL, encrypt_write, NULL), );","title":"3. Define the characteristics"},{"location":"ble-07-security-modes/#4-implement-the-write-handler","text":"Same as earlier examples (not shown here). It will be called once security is sufficient.","title":"4. Implement the write handler"},{"location":"ble-07-security-modes/#5-track-security-level-changes","text":"Use the security_changed callback to monitor when the connection is encrypted or authenticated: static void on_security_changed(struct bt_conn *conn, bt_security_t level, enum bt_security_err err) { char peer_addr[BT_ADDR_LE_STR_LEN]; bt_addr_le_to_str(bt_conn_get_dst(conn), peer_addr, sizeof(peer_addr)); if (err == 0) { LOG_INF(\"Link secured with %s (level %u)\", peer_addr, level); } else { LOG_WRN(\"Security setup failed with %s (level %u, err %d)\", peer_addr, level, err); } } struct bt_conn_cb connection_callbacks = { .connected = on_connected, .disconnected = on_disconnected, .security_changed = on_security_changed, };","title":"5. Track security level changes"},{"location":"ble-07-security-modes/#6-attempt-a-write","text":"When you try to write to the encrypted characteristic, the phone will prompt you to pair. Once encrypted, the connection will be promoted to Security Level 2 .","title":"6. Attempt a write"},{"location":"ble-07-security-modes/#7-unpair-before-moving-on","text":"To start fresh: - On your phone, unpair the device via Bluetooth settings. - In firmware, clear bonding info with: bt_unpair(BT_ID_DEFAULT, NULL);","title":"7. Unpair before moving on"},{"location":"ble-07-security-modes/#8-add-an-authenticated-characteristic","text":"Now define a second characteristic that requires authentication : #define BT_UUID_TEST_AUTHEN_VAL BT_UUID_128_ENCODE(0x12345678, 0x9abc, 0xdef0, 0x1234, 0x56789abcdef2) #define BT_UUID_TEST_AUTHEN BT_UUID_DECLARE_128(BT_UUID_TEST_AUTHEN_VAL) BT_GATT_SERVICE_DEFINE(my_svc, BT_GATT_PRIMARY_SERVICE(BT_UUID_TEST_SERVICE), // Encrypted write characteristic BT_GATT_CHARACTERISTIC(BT_UUID_TEST_ENCRYPT, BT_GATT_CHRC_WRITE, BT_GATT_PERM_WRITE_ENCRYPT, NULL, encrypt_write, NULL), // Authenticated write characteristic BT_GATT_CHARACTERISTIC(BT_UUID_TEST_AUTHEN, BT_GATT_CHRC_WRITE, BT_GATT_PERM_WRITE_AUTHEN, NULL, authen_write, NULL), );","title":"8. Add an authenticated characteristic"},{"location":"ble-07-security-modes/#9-display-the-passkey","text":"To complete an authenticated pairing, we need to show the user a passkey. This is done using the authentication callbacks: static void display_passkey(struct bt_conn *conn, unsigned int passkey) { char peer_addr[BT_ADDR_LE_STR_LEN]; bt_addr_le_to_str(bt_conn_get_dst(conn), peer_addr, sizeof(peer_addr)); LOG_INF(\"Enter passkey on %s: %06u\", peer_addr, passkey); } static void cancel_authentication(struct bt_conn *conn) { char peer_addr[BT_ADDR_LE_STR_LEN]; bt_addr_le_to_str(bt_conn_get_dst(conn), peer_addr, sizeof(peer_addr)); LOG_INF(\"Pairing canceled by remote: %s\", peer_addr); } static const struct bt_conn_auth_cb auth_callbacks = { .passkey_display = display_passkey, .cancel = cancel_authentication, };","title":"9. Display the passkey"},{"location":"ble-07-security-modes/#10-register-authentication-handlers","text":"Don't forget to register your callbacks during initialization: int main(void) { bt_unpair(BT_ID_DEFAULT, NULL); bt_conn_auth_cb_register(&auth_callbacks); bt_conn_cb_register(&connection_callbacks); bt_enable(NULL); // Other setup... }","title":"10. Register authentication handlers"},{"location":"ble-08-whitelisting/","text":"08 - BLE Whitelisting Author: Tony Fu Date: 2025/04/26 Device: nRF52840 DK Toolchain: nRF Connect SDK v3.0.0 When enabling CONFIG_SETTINGS on the nRF52840 Dongle, the device consistently hangs at startup. This issue occurs because the settings subsystem, by default, places the storage area ( settings_storage ) at the end of flash memory \u2014 specifically starting around address 0xFE000 . However, on the nRF52840 Dongle, the flash layout is different: it includes a pre-programmed bootloader occupying the range 0xE0000 to 0x100000 (1 MB). Since the default application build, assuming full flash usage, writes settings data into the storage partition starting at 0xFE000 , this overlaps with the bootloader region, leading to flash corruption and a non-functional device (COM port disappears, boot fails). Due to these address conflicts and the way Partition Manager auto-generates partitions, we have opted to use the nRF52840 Development Kit (DK) instead of the Dongle for this project. For further discussion on this issue and possible workarounds, refer to the open issue at Zephyr GitHub Issue #83037 . Bonding with Persistent Storage To store Bluetooth bond information across device resets (power cycles), we must enable several configuration options in prj.conf : CONFIG_BT_SETTINGS=y CONFIG_FLASH=y CONFIG_FLASH_PAGE_LAYOUT=y CONFIG_FLASH_MAP=y CONFIG_NVS=y CONFIG_SETTINGS_NVS=y CONFIG_SETTINGS=y Setting Purpose CONFIG_BT_SETTINGS Allows the Bluetooth stack to save and restore bonding and identity information (like keys) using the settings subsystem. Without this, bonds are lost on reset. CONFIG_FLASH Provides low-level flash driver support needed to write/read from non-volatile memory. CONFIG_FLASH_PAGE_LAYOUT Abstracts how flash memory is divided into pages, allowing the system to know how to manage writes and erasures correctly. Important for portable flash handling. CONFIG_FLASH_MAP Provides logical partitioning of the flash. Required to map certain parts of flash for NVS (and others like MCUBoot, if used). CONFIG_NVS Enables a simple key-value storage system over flash, suitable for small frequent updates like Bluetooth bonding information. CONFIG_SETTINGS_NVS Makes the settings subsystem use NVS as the storage backend (instead of, for example, FCB or other flash drivers). CONFIG_SETTINGS Provides a general system for saving and loading configuration values. The Bluetooth stack uses it under the hood to store keys and other persistent information. Then, in your main.c file, you need to include the settings header: #include <zephyr/settings/settings.h> and call the following functions in your main() function to initialize the settings subsystem and load the stored settings: bt_enable(NULL); settings_load(); start_advertising(); Whitelisting (a.k.a. Filter Accept List) Whitelisting restricts which devices can connect to your Bluetooth advertiser. It is based on a list of trusted (bonded) devices, called the Filter Accept List (FAL). When a device is bonded, its address is added to the FAL. When a device tries to connect, the Bluetooth stack checks if it is in the FAL. To enable whitelisting, add these configurations in your prj.conf : CONFIG_BT_FILTER_ACCEPT_LIST=y CONFIG_BT_PRIVACY=y CONFIG_BT_MAX_PAIRED=3 Config Purpose CONFIG_BT_FILTER_ACCEPT_LIST Enables the use of an internal list of allowed devices for scanning and connection filtering. CONFIG_BT_PRIVACY Enables the use of Resolvable Private Addresses (RPAs) to protect user identity and avoid static MAC addresses. This helps when using whitelisting, because bonded devices can still recognize each other even if their addresses change. CONFIG_BT_MAX_PAIRED Limits how many bonded devices can be stored and managed by the Bluetooth stack. Advertising with Whitelisting To actually use the FAL, you must configure your advertising parameters to filter both: - Scan Requests (devices trying to get more info like UUIDs) - Connection Requests (devices trying to establish a link) You do this by adding two advertising options: BT_LE_ADV_OPT_FILTER_SCAN_REQ : only allow devices in the whitelist to send scan requests. BT_LE_ADV_OPT_FILTER_CONN : only allow devices in the whitelist to initiate connections. You can define your whitelist-enabled advertising like this: #define BT_LE_ADV_CONN_ACCEPT_LIST \\ BT_LE_ADV_PARAM(BT_LE_ADV_OPT_CONN | BT_LE_ADV_OPT_FILTER_CONN | BT_LE_ADV_OPT_FILTER_SCAN_REQ, \\ BT_GAP_ADV_FAST_INT_MIN_2, BT_GAP_ADV_FAST_INT_MAX_2, NULL) This ensures that only known, bonded devices can see your scan response and initiate a connection. Adding Devices to the Whitelist Before using the Filter Accept List (whitelist) during advertising, you must populate it with the addresses of bonded devices. This process is typically done after Bluetooth is initialized but before starting advertising. static void add_bonded_device_to_whitelist(const struct bt_bond_info *bond, void *context) { int *added_count = context; if (*added_count < 0) { return; } int ret = bt_le_filter_accept_list_add(&bond->addr); if (ret) { LOG_INF(\"Failed to add device to whitelist (err: %d)\", ret); *added_count = -EIO; } else { (*added_count)++; LOG_INF(\"Device added to whitelist: %02X %02X\", bond->addr.a.val[0], bond->addr.a.val[1]); } } We will use this callback function below to add bonded devices to the whitelist: static int configure_whitelist(uint8_t id) { int ret = bt_le_filter_accept_list_clear(); if (ret) { LOG_INF(\"Whitelist clear failed (err: %d)\", ret); return ret; } int bonded_devices = 0; bt_foreach_bond(id, add_bonded_device_to_whitelist, &bonded_devices); return bonded_devices; } This function: 1. Clears any existing whitelist. 2. Iterates over all bonded devices ( bt_foreach_bond() ). 3. Adds each bonded device to the whitelist. 4. Returns the number of devices added. Now we just need to call configure_whitelist() before starting advertising: Erasing Bonding Information Sometimes you need to remove all stored bonds, for example when: - Resetting the device for new users. - Testing new pairing procedures. You can erase all bonding information with a simple API call: int ret = bt_unpair(BT_ID_DEFAULT, BT_ADDR_LE_ANY); BT_ID_DEFAULT specifies the local identity (usually 0 unless you use multiple identities). BT_ADDR_LE_ANY means \"remove all bonded devices\" (wildcard address). If successful, all paired devices are forgotten, and the whitelist (if any) must be rebuilt. After erasing bonds, you should also clear the FAL to ensure no stale entries remain. Also, you should go to the Bluetooth settings of your central device (e.g., phone) and remove the bond from there as well.","title":"BLE-Whitelisting"},{"location":"ble-08-whitelisting/#08-ble-whitelisting","text":"Author: Tony Fu Date: 2025/04/26 Device: nRF52840 DK Toolchain: nRF Connect SDK v3.0.0 When enabling CONFIG_SETTINGS on the nRF52840 Dongle, the device consistently hangs at startup. This issue occurs because the settings subsystem, by default, places the storage area ( settings_storage ) at the end of flash memory \u2014 specifically starting around address 0xFE000 . However, on the nRF52840 Dongle, the flash layout is different: it includes a pre-programmed bootloader occupying the range 0xE0000 to 0x100000 (1 MB). Since the default application build, assuming full flash usage, writes settings data into the storage partition starting at 0xFE000 , this overlaps with the bootloader region, leading to flash corruption and a non-functional device (COM port disappears, boot fails). Due to these address conflicts and the way Partition Manager auto-generates partitions, we have opted to use the nRF52840 Development Kit (DK) instead of the Dongle for this project. For further discussion on this issue and possible workarounds, refer to the open issue at Zephyr GitHub Issue #83037 .","title":"08 - BLE Whitelisting"},{"location":"ble-08-whitelisting/#bonding-with-persistent-storage","text":"To store Bluetooth bond information across device resets (power cycles), we must enable several configuration options in prj.conf : CONFIG_BT_SETTINGS=y CONFIG_FLASH=y CONFIG_FLASH_PAGE_LAYOUT=y CONFIG_FLASH_MAP=y CONFIG_NVS=y CONFIG_SETTINGS_NVS=y CONFIG_SETTINGS=y Setting Purpose CONFIG_BT_SETTINGS Allows the Bluetooth stack to save and restore bonding and identity information (like keys) using the settings subsystem. Without this, bonds are lost on reset. CONFIG_FLASH Provides low-level flash driver support needed to write/read from non-volatile memory. CONFIG_FLASH_PAGE_LAYOUT Abstracts how flash memory is divided into pages, allowing the system to know how to manage writes and erasures correctly. Important for portable flash handling. CONFIG_FLASH_MAP Provides logical partitioning of the flash. Required to map certain parts of flash for NVS (and others like MCUBoot, if used). CONFIG_NVS Enables a simple key-value storage system over flash, suitable for small frequent updates like Bluetooth bonding information. CONFIG_SETTINGS_NVS Makes the settings subsystem use NVS as the storage backend (instead of, for example, FCB or other flash drivers). CONFIG_SETTINGS Provides a general system for saving and loading configuration values. The Bluetooth stack uses it under the hood to store keys and other persistent information. Then, in your main.c file, you need to include the settings header: #include <zephyr/settings/settings.h> and call the following functions in your main() function to initialize the settings subsystem and load the stored settings: bt_enable(NULL); settings_load(); start_advertising();","title":"Bonding with Persistent Storage"},{"location":"ble-08-whitelisting/#whitelisting-aka-filter-accept-list","text":"Whitelisting restricts which devices can connect to your Bluetooth advertiser. It is based on a list of trusted (bonded) devices, called the Filter Accept List (FAL). When a device is bonded, its address is added to the FAL. When a device tries to connect, the Bluetooth stack checks if it is in the FAL. To enable whitelisting, add these configurations in your prj.conf : CONFIG_BT_FILTER_ACCEPT_LIST=y CONFIG_BT_PRIVACY=y CONFIG_BT_MAX_PAIRED=3 Config Purpose CONFIG_BT_FILTER_ACCEPT_LIST Enables the use of an internal list of allowed devices for scanning and connection filtering. CONFIG_BT_PRIVACY Enables the use of Resolvable Private Addresses (RPAs) to protect user identity and avoid static MAC addresses. This helps when using whitelisting, because bonded devices can still recognize each other even if their addresses change. CONFIG_BT_MAX_PAIRED Limits how many bonded devices can be stored and managed by the Bluetooth stack.","title":"Whitelisting (a.k.a. Filter Accept List)"},{"location":"ble-08-whitelisting/#advertising-with-whitelisting","text":"To actually use the FAL, you must configure your advertising parameters to filter both: - Scan Requests (devices trying to get more info like UUIDs) - Connection Requests (devices trying to establish a link) You do this by adding two advertising options: BT_LE_ADV_OPT_FILTER_SCAN_REQ : only allow devices in the whitelist to send scan requests. BT_LE_ADV_OPT_FILTER_CONN : only allow devices in the whitelist to initiate connections. You can define your whitelist-enabled advertising like this: #define BT_LE_ADV_CONN_ACCEPT_LIST \\ BT_LE_ADV_PARAM(BT_LE_ADV_OPT_CONN | BT_LE_ADV_OPT_FILTER_CONN | BT_LE_ADV_OPT_FILTER_SCAN_REQ, \\ BT_GAP_ADV_FAST_INT_MIN_2, BT_GAP_ADV_FAST_INT_MAX_2, NULL) This ensures that only known, bonded devices can see your scan response and initiate a connection.","title":"Advertising with Whitelisting"},{"location":"ble-08-whitelisting/#adding-devices-to-the-whitelist","text":"Before using the Filter Accept List (whitelist) during advertising, you must populate it with the addresses of bonded devices. This process is typically done after Bluetooth is initialized but before starting advertising. static void add_bonded_device_to_whitelist(const struct bt_bond_info *bond, void *context) { int *added_count = context; if (*added_count < 0) { return; } int ret = bt_le_filter_accept_list_add(&bond->addr); if (ret) { LOG_INF(\"Failed to add device to whitelist (err: %d)\", ret); *added_count = -EIO; } else { (*added_count)++; LOG_INF(\"Device added to whitelist: %02X %02X\", bond->addr.a.val[0], bond->addr.a.val[1]); } } We will use this callback function below to add bonded devices to the whitelist: static int configure_whitelist(uint8_t id) { int ret = bt_le_filter_accept_list_clear(); if (ret) { LOG_INF(\"Whitelist clear failed (err: %d)\", ret); return ret; } int bonded_devices = 0; bt_foreach_bond(id, add_bonded_device_to_whitelist, &bonded_devices); return bonded_devices; } This function: 1. Clears any existing whitelist. 2. Iterates over all bonded devices ( bt_foreach_bond() ). 3. Adds each bonded device to the whitelist. 4. Returns the number of devices added. Now we just need to call configure_whitelist() before starting advertising:","title":"Adding Devices to the Whitelist"},{"location":"ble-08-whitelisting/#erasing-bonding-information","text":"Sometimes you need to remove all stored bonds, for example when: - Resetting the device for new users. - Testing new pairing procedures. You can erase all bonding information with a simple API call: int ret = bt_unpair(BT_ID_DEFAULT, BT_ADDR_LE_ANY); BT_ID_DEFAULT specifies the local identity (usually 0 unless you use multiple identities). BT_ADDR_LE_ANY means \"remove all bonded devices\" (wildcard address). If successful, all paired devices are forgotten, and the whitelist (if any) must be rebuilt. After erasing bonds, you should also clear the FAL to ensure no stale entries remain. Also, you should go to the Bluetooth settings of your central device (e.g., phone) and remove the bond from there as well.","title":"Erasing Bonding Information"},{"location":"setup-01-vscode/","text":"01 Setup nRF Connect SDK with VSCode Author: Tony Fu Date: 2025/04/26 Device: nRF52840 DK Toolchain: nRF Connect SDK v3.0.0 Setup nRF Connect SDK with VSCode I would recommend this tutorial series for setting up the nRF Connect SDK with VSCode. nrfutil To my suprise, the VSCode extension (and the toolchain that it install) did not include the nrfutil package. This is required for flashing the firmware. Without it, the \"flash\" action button of the VSCode extension will not work. Simply head to this website and download the latest version of nrfutil . Then add it to your PATH. Open a terminal and run the following command to see what commands are available: nrfutil search You should see something like this: Command Installed Latest Status 91 0.5.0 Not installed ble-sniffer 0.16.2 Not installed completion 1.5.0 Not installed device 2.9.0 Not installed npm 0.3.0 Not installed nrf5sdk-tools 1.1.0 1.1.0 Installed sdk-manager 1.1.0 Not installed suit 0.9.0 Not installed toolchain-manager 0.15.0 Not installed trace 3.3.1 Not installed You should install the device command. This is required for flashing the firmware. To install it, run the following command: nrfutil install device","title":"01 Setup nRF Connect SDK with VSCode"},{"location":"setup-01-vscode/#01-setup-nrf-connect-sdk-with-vscode","text":"Author: Tony Fu Date: 2025/04/26 Device: nRF52840 DK Toolchain: nRF Connect SDK v3.0.0","title":"01 Setup nRF Connect SDK with VSCode"},{"location":"setup-01-vscode/#setup-nrf-connect-sdk-with-vscode","text":"I would recommend this tutorial series for setting up the nRF Connect SDK with VSCode.","title":"Setup nRF Connect SDK with VSCode"},{"location":"setup-01-vscode/#nrfutil","text":"To my suprise, the VSCode extension (and the toolchain that it install) did not include the nrfutil package. This is required for flashing the firmware. Without it, the \"flash\" action button of the VSCode extension will not work. Simply head to this website and download the latest version of nrfutil . Then add it to your PATH. Open a terminal and run the following command to see what commands are available: nrfutil search You should see something like this: Command Installed Latest Status 91 0.5.0 Not installed ble-sniffer 0.16.2 Not installed completion 1.5.0 Not installed device 2.9.0 Not installed npm 0.3.0 Not installed nrf5sdk-tools 1.1.0 1.1.0 Installed sdk-manager 1.1.0 Not installed suit 0.9.0 Not installed toolchain-manager 0.15.0 Not installed trace 3.3.1 Not installed You should install the device command. This is required for flashing the firmware. To install it, run the following command: nrfutil install device","title":"nrfutil"}]}