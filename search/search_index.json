{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"nRF Connect SDK Notes This site contains my notes for the official courses on Nordic Developer Academy . Note: In order to not exceed the filename length limit, please make sure to clone the repository as close to the root of your filesystem as possible.","title":"Home"},{"location":"#nrf-connect-sdk-notes","text":"This site contains my notes for the official courses on Nordic Developer Academy . Note: In order to not exceed the filename length limit, please make sure to clone the repository as close to the root of your filesystem as possible.","title":"nRF Connect SDK Notes"},{"location":"01-ble-minimal-skeleton/","text":"01 - Minimal BLE Skeleton This example sets up the Bluetooth stack only \u2014 no advertising, no services, no connections. Useful as a clean starting point. Configuration: prj.conf # Enable basic logging CONFIG_LOG=y # Enable Bluetooth stack CONFIG_BT=y # Optional: Set device name (not used here but required for CONFIG_BT) CONFIG_BT_DEVICE_NAME=\"Minimal_BLE\" # Increase stack sizes for stability CONFIG_SYSTEM_WORKQUEUE_STACK_SIZE=2048 CONFIG_MAIN_STACK_SIZE=2048 Code Structure: main.c #include <zephyr/kernel.h> #include <zephyr/logging/log.h> #include <zephyr/bluetooth/bluetooth.h> LOG_MODULE_REGISTER(minimal_ble, LOG_LEVEL_INF); int main(void) { int err; LOG_INF(\"Minimal BLE Example Start\"); // Initialize the Bluetooth stack err = bt_enable(NULL); if (err) { LOG_ERR(\"Bluetooth init failed (err %d)\", err); return -1; } LOG_INF(\"Bluetooth initialized\"); // Idle loop while (1) { k_sleep(K_SECONDS(1)); } }","title":"BLE-Minimal Skeleton"},{"location":"01-ble-minimal-skeleton/#01-minimal-ble-skeleton","text":"This example sets up the Bluetooth stack only \u2014 no advertising, no services, no connections. Useful as a clean starting point.","title":"01 - Minimal BLE Skeleton"},{"location":"01-ble-minimal-skeleton/#configuration-prjconf","text":"# Enable basic logging CONFIG_LOG=y # Enable Bluetooth stack CONFIG_BT=y # Optional: Set device name (not used here but required for CONFIG_BT) CONFIG_BT_DEVICE_NAME=\"Minimal_BLE\" # Increase stack sizes for stability CONFIG_SYSTEM_WORKQUEUE_STACK_SIZE=2048 CONFIG_MAIN_STACK_SIZE=2048","title":"Configuration: prj.conf"},{"location":"01-ble-minimal-skeleton/#code-structure-mainc","text":"#include <zephyr/kernel.h> #include <zephyr/logging/log.h> #include <zephyr/bluetooth/bluetooth.h> LOG_MODULE_REGISTER(minimal_ble, LOG_LEVEL_INF); int main(void) { int err; LOG_INF(\"Minimal BLE Example Start\"); // Initialize the Bluetooth stack err = bt_enable(NULL); if (err) { LOG_ERR(\"Bluetooth init failed (err %d)\", err); return -1; } LOG_INF(\"Bluetooth initialized\"); // Idle loop while (1) { k_sleep(K_SECONDS(1)); } }","title":"Code Structure: main.c"},{"location":"02-ble-advertising-simple/","text":"02 - BLE Advertising Simple To advertise your device, you need to call bt_le_adv_start() with the right parameters. int bt_le_adv_start(const struct bt_le_adv_param *param, const struct bt_data *ad, size_t ad_len, const struct bt_data *sd, size_t sd_len); param : Advertising parameters (defines behavior) ad : Advertising data (broadcasted to all scanners) sd : Scan response data (optional, sent after scan request) Common Advertising Params BT_LE_ADV_CONN - Connectable undirected advertising, but still advertises to all devices after connected to a peer. This could be bad for power consumption and security. BT_LE_ADV_CONN_ONE_TIME - Connectable undirected advertising, but stops after the first connection. This is the recommended default for most applications. BT_LE_ADV_CONN_DIR - Connectable directed advertising, which is used when you know the peer address. This is faster and less power-hungry than undirected advertising. BT_LE_ADV_NCONN - Non-connectable undirected advertising, which is used when you don't want to be connected to. This is useful for beacons and other passive broadcasts. BT_LE_ADV_CONN_DIR_LOW_DUTY - Connectable directed advertising with a lower duty cycle, which is used when you don't expect to be connected to immediately but still want to reconnect with a known peer. BT_LE_ADV_NCONN_IDENTITY - Non-connectable advertising that uses the device's identity address, which is useful for testing and visibility. Note: To prevent tracking, advertising modes like BT_LE_ADV_CONN , BT_LE_ADV_CONN_ONE_TIME , and BT_LE_ADV_NCONN (params 1, 2, and 4) use Resolvable Private Addresses (RPAs) by default. RPAs are a privacy feature introduced in Bluetooth 4.2. They are generated using the device\u2019s identity address (public or static random) and a random value, and they typically change every 15 minutes. This allows trusted, bonded peers to resolve your identity, while third parties cannot track the device over time. RPA behavior is enabled by default when CONFIG_BT_PRIVACY=y , but it can be disabled if needed. To explicitly advertise with your identity address (e.g., for testing or directed advertising), use the BT_LE_ADV_OPT_USE_IDENTITY option. Advertising Data and Scan Response Data Advertising Data (ad[]) static const struct bt_data ad[] = { BT_DATA_BYTES(BT_DATA_FLAGS, (BT_LE_AD_GENERAL | BT_LE_AD_NO_BREDR)), BT_DATA(BT_DATA_NAME_COMPLETE, DEVICE_NAME, DEVICE_NAME_LEN), }; This example shows how to define advertising data using struct bt_data . struct bt_data { uint8_t type; uint8_t data_len; const uint8_t *data; }; However, we typically don't define `struct bt_data` directly. Instead, we use macros to simplify the process. ```c BT_DATA(type, data, data_len) // Use with a pointer and explicit size BT_DATA_BYTES(type, byte1, byte2...) // Inline declaration with raw bytes In advertising data, we must always include the following fields: BT_DATA_BYTES(BT_DATA_FLAGS, (BT_LE_AD_GENERAL | BT_LE_AD_NO_BREDR)) This is always used on Nordic devices because Nordic only supports BLE (not BR/EDR), and this is why we include <zephyr/bluetooth/gap.h> for the bitmasks. and BT_DATA(BT_DATA_NAME_COMPLETE, DEVICE_NAME, DEVICE_NAME_LEN) Scan Response Data (sd[]) Use scan response (sd) when you want to include optional, larger data like a full device name or a URL. Advertising data is always broadcast; scan response is only sent when a scanner asks for it, making it more power-efficient and less crowded. #define COMPANY_ID_CODE 0x0059 // Nordic Semiconductor typedef struct { uint16_t company_id; // Company ID uint8_t data[6]; // Custom Data } my_data_t; static const my_data_t my_data = { .company_id = COMPANY_ID_CODE, .data = {0x01, 0x02, 0x03, 0x04, 0x05, 0x06}}; When the advertising data is too large to fit in advertising packets, the scanner can request a scan response. This is not shown here. Common Advertising Data Types Common in ad[] (Advertising) Macro Description BT_DATA_FLAGS BLE flags (required) BT_DATA_NAME_COMPLETE Complete device name BT_DATA_UUID16_ALL List of 16-bit service UUIDs BT_DATA_UUID128_ALL List of 128-bit service UUIDs BT_DATA_MANUFACTURER_DATA Vendor-specific binary data Common in sd[] (Scan Response) Macro Description BT_DATA_URI URI string (e.g., website) BT_DATA_TX_POWER Transmission power (in dBm) BT_DATA_APPEARANCE Device appearance (e.g., watch) BT_DATA_NAME_SHORTENED Shortened name (if full name won't fit) More on service UUIDs later.","title":"BLE-Advertising Simple"},{"location":"02-ble-advertising-simple/#02-ble-advertising-simple","text":"To advertise your device, you need to call bt_le_adv_start() with the right parameters. int bt_le_adv_start(const struct bt_le_adv_param *param, const struct bt_data *ad, size_t ad_len, const struct bt_data *sd, size_t sd_len); param : Advertising parameters (defines behavior) ad : Advertising data (broadcasted to all scanners) sd : Scan response data (optional, sent after scan request)","title":"02 - BLE Advertising Simple"},{"location":"02-ble-advertising-simple/#common-advertising-params","text":"BT_LE_ADV_CONN - Connectable undirected advertising, but still advertises to all devices after connected to a peer. This could be bad for power consumption and security. BT_LE_ADV_CONN_ONE_TIME - Connectable undirected advertising, but stops after the first connection. This is the recommended default for most applications. BT_LE_ADV_CONN_DIR - Connectable directed advertising, which is used when you know the peer address. This is faster and less power-hungry than undirected advertising. BT_LE_ADV_NCONN - Non-connectable undirected advertising, which is used when you don't want to be connected to. This is useful for beacons and other passive broadcasts. BT_LE_ADV_CONN_DIR_LOW_DUTY - Connectable directed advertising with a lower duty cycle, which is used when you don't expect to be connected to immediately but still want to reconnect with a known peer. BT_LE_ADV_NCONN_IDENTITY - Non-connectable advertising that uses the device's identity address, which is useful for testing and visibility. Note: To prevent tracking, advertising modes like BT_LE_ADV_CONN , BT_LE_ADV_CONN_ONE_TIME , and BT_LE_ADV_NCONN (params 1, 2, and 4) use Resolvable Private Addresses (RPAs) by default. RPAs are a privacy feature introduced in Bluetooth 4.2. They are generated using the device\u2019s identity address (public or static random) and a random value, and they typically change every 15 minutes. This allows trusted, bonded peers to resolve your identity, while third parties cannot track the device over time. RPA behavior is enabled by default when CONFIG_BT_PRIVACY=y , but it can be disabled if needed. To explicitly advertise with your identity address (e.g., for testing or directed advertising), use the BT_LE_ADV_OPT_USE_IDENTITY option.","title":"Common Advertising Params"},{"location":"02-ble-advertising-simple/#advertising-data-and-scan-response-data","text":"","title":"Advertising Data and Scan Response Data"},{"location":"02-ble-advertising-simple/#advertising-data-ad","text":"static const struct bt_data ad[] = { BT_DATA_BYTES(BT_DATA_FLAGS, (BT_LE_AD_GENERAL | BT_LE_AD_NO_BREDR)), BT_DATA(BT_DATA_NAME_COMPLETE, DEVICE_NAME, DEVICE_NAME_LEN), }; This example shows how to define advertising data using struct bt_data . struct bt_data { uint8_t type; uint8_t data_len; const uint8_t *data; }; However, we typically don't define `struct bt_data` directly. Instead, we use macros to simplify the process. ```c BT_DATA(type, data, data_len) // Use with a pointer and explicit size BT_DATA_BYTES(type, byte1, byte2...) // Inline declaration with raw bytes In advertising data, we must always include the following fields: BT_DATA_BYTES(BT_DATA_FLAGS, (BT_LE_AD_GENERAL | BT_LE_AD_NO_BREDR)) This is always used on Nordic devices because Nordic only supports BLE (not BR/EDR), and this is why we include <zephyr/bluetooth/gap.h> for the bitmasks. and BT_DATA(BT_DATA_NAME_COMPLETE, DEVICE_NAME, DEVICE_NAME_LEN)","title":"Advertising Data (ad[])"},{"location":"02-ble-advertising-simple/#scan-response-data-sd","text":"Use scan response (sd) when you want to include optional, larger data like a full device name or a URL. Advertising data is always broadcast; scan response is only sent when a scanner asks for it, making it more power-efficient and less crowded. #define COMPANY_ID_CODE 0x0059 // Nordic Semiconductor typedef struct { uint16_t company_id; // Company ID uint8_t data[6]; // Custom Data } my_data_t; static const my_data_t my_data = { .company_id = COMPANY_ID_CODE, .data = {0x01, 0x02, 0x03, 0x04, 0x05, 0x06}}; When the advertising data is too large to fit in advertising packets, the scanner can request a scan response. This is not shown here.","title":"Scan Response Data (sd[])"},{"location":"02-ble-advertising-simple/#common-advertising-data-types","text":"","title":"Common Advertising Data Types"},{"location":"02-ble-advertising-simple/#common-in-ad-advertising","text":"Macro Description BT_DATA_FLAGS BLE flags (required) BT_DATA_NAME_COMPLETE Complete device name BT_DATA_UUID16_ALL List of 16-bit service UUIDs BT_DATA_UUID128_ALL List of 128-bit service UUIDs BT_DATA_MANUFACTURER_DATA Vendor-specific binary data","title":"Common in ad[] (Advertising)"},{"location":"02-ble-advertising-simple/#common-in-sd-scan-response","text":"Macro Description BT_DATA_URI URI string (e.g., website) BT_DATA_TX_POWER Transmission power (in dBm) BT_DATA_APPEARANCE Device appearance (e.g., watch) BT_DATA_NAME_SHORTENED Shortened name (if full name won't fit) More on service UUIDs later.","title":"Common in sd[] (Scan Response)"},{"location":"03-ble-advert-connectable/","text":"03 - BLE Advertising: Connectable To make a device connectable, we need to enable the Bluetooth peripheral role and set the advertising parameters accordingly. Add this to your prj.conf file: CONFIG_BT_PERIPHERAL=y In previous examples, we used the predefined macro BT_LE_ADV_NCONN for non-connectable advertising. To allow connections, we need different parameters like BT_LE_ADV_CONN_ONE_TIME . We can also define our own advertising parameters with the help of the BT_LE_ADV_PARAM() macro: BT_LE_ADV_PARAM(_options, _int_min, _int_max, _peer) _options : A bitmask of advertising options (e.g., connectable, use identity, etc.) _int_min , _int_max : Advertising interval (units of 0.625 ms) _peer : Peer address; set to NULL for undirected advertising Example parameters for connectable advertising: static const struct bt_le_adv_param *adv_param = BT_LE_ADV_PARAM( (BT_LE_ADV_OPT_CONNECTABLE | BT_LE_ADV_OPT_USE_IDENTITY), /* Connectable advertising and use identity address */ BT_GAP_ADV_FAST_INT_MIN_2, /* Min Advertising Interval 100 ms */ BT_GAP_ADV_FAST_INT_MAX_2, /* Max Advertising Interval 150 ms */ NULL); /* Set to NULL for undirected advertising */ Common options flags include: BT_LE_ADV_OPT_CONNECTABLE : Allow devices to connect BT_LE_ADV_OPT_ONE_TIME : Stop advertising after one connection BT_LE_ADV_OPT_USE_IDENTITY : Use the device's identity address (not RPA) BT_LE_ADV_OPT_USE_NAME : Automatically include the GAP device name BT_LE_ADV_OPT_SCANNABLE : Enable scan response data BT_LE_ADV_OPT_EXT_ADV : Use extended advertising features (for longer range or larger data) BT_LE_ADV_OPT_FILTER_SCAN_REQ : Only respond to scanners in the filter list BT_LE_ADV_OPT_FILTER_CONN : Only allow connections from filtered peers This setup allows your device to be discoverable and accept connections from central devices like phones or PCs. However, it will continue to advertise even after a connection is established, which may not be ideal for power consumption or security. To stop advertising after the first connection, add the BT_LE_ADV_OPT_ONE_TIME option. Advertising Intervals The advertising interval controls how often your device broadcasts its advertising packets. It is set using _int_min and _int_max in BT_LE_ADV_PARAM() and is specified in units of 0.625 ms. Valid range : 20 ms to 10.24 seconds Resolution : 0.625 ms steps You can set: - min == max \u2192 Fixed interval (allowed) - min < max \u2192 Interval chosen randomly within that range (typical) A small random delay (0\u201310 ms) is added automatically to help avoid collisions between devices using similar intervals. Guidelines Short intervals (~20\u2013100 ms) : Fast discovery, higher power consumption Medium intervals (~150\u2013500 ms) : Balanced power and discovery time (good default) Long intervals (>1 s) : Low power, slower to be discovered Choose an interval based on your application: - For wearables or low-power sensors , favor longer intervals - For pairing mode or quick reconnection , use shorter intervals Some constants are defined in zephyr/bluetooth/gap.h for common intervals: GAP Advertising Parameters These are predefined intervals for legacy advertisement (connectable or scannable), used by many macros like BT_LE_ADV_CONN . Macro Hex Time (ms) BT_GAP_ADV_FAST_INT_MIN_1 0x0030 30 BT_GAP_ADV_FAST_INT_MAX_1 0x0060 60 BT_GAP_ADV_FAST_INT_MIN_2 0x00a0 100 BT_GAP_ADV_FAST_INT_MAX_2 0x00f0 150 BT_GAP_ADV_SLOW_INT_MIN 0x0640 1000 BT_GAP_ADV_SLOW_INT_MAX 0x0780 1200 GAP Periodic Advertising Parameters Periodic advertising is a Bluetooth Low Energy feature introduced in Bluetooth 5 that allows a device to broadcast data at fixed, predictable intervals without requiring a connection. Unlike legacy advertising, which is sent on the primary channels and may be missed if the scanner isn't listening at the right time, periodic advertising uses a synchronizable schedule and is transmitted on secondary channels. This allows scanners to synchronize with the advertiser and receive updates reliably with lower power consumption. It's ideal for broadcasting sensor data , location beacons , or status updates where frequent connections aren't needed but consistent updates are. Macro Hex Time (ms) BT_GAP_PER_ADV_FAST_INT_MIN_1 0x0018 30 BT_GAP_PER_ADV_FAST_INT_MAX_1 0x0030 60 BT_GAP_PER_ADV_FAST_INT_MIN_2 0x0050 100 BT_GAP_PER_ADV_FAST_INT_MAX_2 0x0078 150 BT_GAP_PER_ADV_SLOW_INT_MIN 0x0320 1000 BT_GAP_PER_ADV_SLOW_INT_MAX 0x03C0 1200 GAP Scan Parameters These define standard scan intervals and windows. The interval is how often scanning starts, and the window is how long each scan lasts. Macro Hex Time (ms) BT_GAP_SCAN_FAST_INTERVAL_MIN 0x0030 30 BT_GAP_SCAN_FAST_INTERVAL 0x0060 60 BT_GAP_SCAN_FAST_WINDOW 0x0030 30 BT_GAP_SCAN_SLOW_INTERVAL_1 0x0800 1280 BT_GAP_SCAN_SLOW_WINDOW_1 0x0012 11.25 BT_GAP_SCAN_SLOW_INTERVAL_2 0x1000 2560 BT_GAP_SCAN_SLOW_WINDOW_2 0x0012 11.25 GAP Initial Connection Parameters These define intervals used when initiating a connection (i.e., when a central connects to a peripheral). Macro Hex Time (ms) BT_GAP_INIT_CONN_INT_MIN 0x0018 30 BT_GAP_INIT_CONN_INT_MAX 0x0028 50 Additional Notes on Timing Coordination When both the advertiser and scanner are under your control, you can optimize their timing parameters to strike a balance between discovery speed , power consumption , and reliability . This is especially useful in scenarios like proprietary ecosystems, closed systems, or when designing both ends of a BLE link (e.g., a wearable + smartphone app). Understanding Scan Interval and Scan Window Scan interval is how often the scanner initiates a scan cycle. Scan window is how long the scanner listens during each scan interval. Both range from 2.5 ms to 10.24 seconds in 0.625 ms steps. In each scan interval, the scanner will scan one of the three primary advertising channels. After the interval ends, it switches to the next channel. If the scan window is equal to the scan interval, the scanner is scanning continuously (100% duty cycle). If the window is shorter than the interval, it means the scanner is off part of the time \u2014 which saves power. For example, if scan interval = 100 ms and window = 20 ms, the scanner is listening only 20% of the time. Coordinating With Advertising Intervals To improve the chances of the scanner receiving advertising packets: The advertising interval should be shorter than or equal to the scan interval. This increases the probability that an advertisement will occur during the scan window. A good rule of thumb is: advertising interval \u2264 scan interval - scan window This ensures that at least one advertisement falls within an active scan window over multiple cycles. You can also align timing using multiples, such as: - Scan interval = 3 \u00d7 advertising interval - Scan window = 50\u201380% of scan interval (for reasonable duty cycle) This is not a strict rule, but it helps statistically reduce missed advertisements due to phase misalignment. Example Timing Coordination Parameter Typical Value Advertising interval 100 ms ( 0x00A0 ) Scan interval 300 ms ( 0x018C ) Scan window 150 ms ( 0x00F0 ) This setup provides good discovery speed and balances scanner energy usage. Notes on Scan Response Timing Scan response packets are only sent if the advertiser receives a scan request . This scan request must be sent while the advertiser is listening , and only during active scanning. The non-scanning time (between windows) is not used for scan response \u2014 in fact, nothing happens during those gaps. This means larger scan windows increase the chance of triggering a scan response successfully. Power Considerations Scanning uses more power than advertising \u2014 so the scanner (usually the central) should be the device with more available energy (e.g., a phone). Peripheral devices (e.g., sensors, wearables) can advertise less frequently to save power and rely on burst scanning from the central. Summary Guidelines Ensure advertising interval \u2264 scan interval Keep scan window large enough to catch at least one advertisement Use scan window \u2248 50\u2013100% of scan interval for faster discovery For low power devices, increase advertising interval and let central scan more aggressively Aside: BLE Address Types Before we continue, let's take a moment to explore the different types of Bluetooth LE addresses. Every BLE device is identified by a 48-bit address , and they are grouped into two main categories: public and random . Random addresses are further split into static , resolvable private , and non-resolvable private types. The type used affects how your device is identified, whether it can be tracked, and whether connections or bonding are possible. 1. Public Address A globally unique address assigned by the manufacturer and stored in the device's hardware (e.g., in FICR on nRF chips). Used automatically unless you override it with a random address or enable privacy. Get the default public address: bt_addr_le_t addr; bt_id_get(&addr, NULL); 2. Random Static Address Does not change across boots \u2014 stable identity. Must follow BLE spec: the most significant two bits of the first byte must be 11 (so the first byte must be between 0xC0 and 0xFF ). Commonly used when you don't have a public address block but need a consistent identity. Set a static random address manually: #include <zephyr/bluetooth/addr.h> bt_addr_le_t addr; bt_addr_le_from_str(\"FF:00:11:22:33:44\", \"random\", &addr); addr.a.val[5] |= 0xC0; // Make sure MSBs are '11' to mark as static random int id = bt_id_create(&addr, NULL); // Must be called before bt_enable() In production, you might derive a unique static random address from the device\u2019s public address or store a pre-generated one in flash/UICR. 3. Resolvable Private Address (RPA) Changes periodically (by default every 15 minutes), but can be resolved by bonded peers using an Identity Resolving Key (IRK). Enables privacy without sacrificing the ability to reconnect or bond. I am currently not sure how to set the RPA manually, but it should be automatically generated by the stack when you enable privacy ( CONFIG_BT_PRIVACY=y ). 4. Non-Resolvable Private Address (NRPA) Also changes periodically, but cannot be resolved \u2014 not bondable or connectable. Useful for anonymous broadcasting (e.g., a privacy-focused beacon). A new NRPA is generated every time you start advertising. Set NRPA explicitly: static const struct bt_le_adv_param *adv_param = BT_LE_ADV_PARAM( BT_LE_ADV_OPT_USE_NRPA, 160, 160, NULL); Connection Callbacks To handle Bluetooth connections in Zephyr, we use the bt_conn_cb structure. This lets us register callback functions to track connection events like when a device connects or disconnects. First, include the necessary header: #include <zephyr/bluetooth/conn.h> Then, declare a connection reference to track the active connection: static struct bt_conn *my_conn = NULL; Basic Callbacks void on_connected(struct bt_conn *conn, uint8_t err) { if (err) { LOG_ERR(\"Connection failed (err %u)\", err); return; } my_conn = bt_conn_ref(conn); } void on_disconnected(struct bt_conn *conn, uint8_t reason) { LOG_INF(\"Disconnected (reason 0x%02x)\", reason); if (my_conn) { bt_conn_unref(my_conn); my_conn = NULL; } } bt_conn_ref() increases the reference count so the connection stays valid. bt_conn_unref() is called on disconnection to release the reference. bt_conn_get_dst() gets the peer device\u2019s address. Registering Callbacks static struct bt_conn_cb connection_callbacks = { .connected = on_connected, .disconnected = on_disconnected, }; bt_conn_cb_register(&connection_callbacks); You must register your callback structure before or after enabling Bluetooth, and before expecting any connection events. Other Available Callbacks in bt_conn_cb You can optionally implement more callbacks: recycled : Called when a connection object is returned to the pool. le_param_req : Called when the peer requests to update connection parameters. Return true to accept or false to reject. le_param_updated : Notifies when connection parameters are updated (interval, latency, timeout). identity_resolved : (If SMP enabled) Notifies when a peer's identity address is resolved from an RPA. security_changed : (If SMP or Classic enabled) Called when connection security changes. remote_info_available : Called when info about the peer (features, roles) is available. le_phy_updated : Notifies when PHY is changed (1M, 2M, coded). le_data_len_updated : Called when the maximum payload size changes. tx_power_report : Reports transmit power changes. subrate_changed : Called when connection subrate settings change. These are mostly optional and only needed for advanced use cases.","title":"BLE-Advertising Connectable"},{"location":"03-ble-advert-connectable/#03-ble-advertising-connectable","text":"To make a device connectable, we need to enable the Bluetooth peripheral role and set the advertising parameters accordingly. Add this to your prj.conf file: CONFIG_BT_PERIPHERAL=y In previous examples, we used the predefined macro BT_LE_ADV_NCONN for non-connectable advertising. To allow connections, we need different parameters like BT_LE_ADV_CONN_ONE_TIME . We can also define our own advertising parameters with the help of the BT_LE_ADV_PARAM() macro: BT_LE_ADV_PARAM(_options, _int_min, _int_max, _peer) _options : A bitmask of advertising options (e.g., connectable, use identity, etc.) _int_min , _int_max : Advertising interval (units of 0.625 ms) _peer : Peer address; set to NULL for undirected advertising Example parameters for connectable advertising: static const struct bt_le_adv_param *adv_param = BT_LE_ADV_PARAM( (BT_LE_ADV_OPT_CONNECTABLE | BT_LE_ADV_OPT_USE_IDENTITY), /* Connectable advertising and use identity address */ BT_GAP_ADV_FAST_INT_MIN_2, /* Min Advertising Interval 100 ms */ BT_GAP_ADV_FAST_INT_MAX_2, /* Max Advertising Interval 150 ms */ NULL); /* Set to NULL for undirected advertising */ Common options flags include: BT_LE_ADV_OPT_CONNECTABLE : Allow devices to connect BT_LE_ADV_OPT_ONE_TIME : Stop advertising after one connection BT_LE_ADV_OPT_USE_IDENTITY : Use the device's identity address (not RPA) BT_LE_ADV_OPT_USE_NAME : Automatically include the GAP device name BT_LE_ADV_OPT_SCANNABLE : Enable scan response data BT_LE_ADV_OPT_EXT_ADV : Use extended advertising features (for longer range or larger data) BT_LE_ADV_OPT_FILTER_SCAN_REQ : Only respond to scanners in the filter list BT_LE_ADV_OPT_FILTER_CONN : Only allow connections from filtered peers This setup allows your device to be discoverable and accept connections from central devices like phones or PCs. However, it will continue to advertise even after a connection is established, which may not be ideal for power consumption or security. To stop advertising after the first connection, add the BT_LE_ADV_OPT_ONE_TIME option.","title":"03 - BLE Advertising: Connectable"},{"location":"03-ble-advert-connectable/#advertising-intervals","text":"The advertising interval controls how often your device broadcasts its advertising packets. It is set using _int_min and _int_max in BT_LE_ADV_PARAM() and is specified in units of 0.625 ms. Valid range : 20 ms to 10.24 seconds Resolution : 0.625 ms steps You can set: - min == max \u2192 Fixed interval (allowed) - min < max \u2192 Interval chosen randomly within that range (typical) A small random delay (0\u201310 ms) is added automatically to help avoid collisions between devices using similar intervals.","title":"Advertising Intervals"},{"location":"03-ble-advert-connectable/#guidelines","text":"Short intervals (~20\u2013100 ms) : Fast discovery, higher power consumption Medium intervals (~150\u2013500 ms) : Balanced power and discovery time (good default) Long intervals (>1 s) : Low power, slower to be discovered Choose an interval based on your application: - For wearables or low-power sensors , favor longer intervals - For pairing mode or quick reconnection , use shorter intervals Some constants are defined in zephyr/bluetooth/gap.h for common intervals:","title":"Guidelines"},{"location":"03-ble-advert-connectable/#gap-advertising-parameters","text":"These are predefined intervals for legacy advertisement (connectable or scannable), used by many macros like BT_LE_ADV_CONN . Macro Hex Time (ms) BT_GAP_ADV_FAST_INT_MIN_1 0x0030 30 BT_GAP_ADV_FAST_INT_MAX_1 0x0060 60 BT_GAP_ADV_FAST_INT_MIN_2 0x00a0 100 BT_GAP_ADV_FAST_INT_MAX_2 0x00f0 150 BT_GAP_ADV_SLOW_INT_MIN 0x0640 1000 BT_GAP_ADV_SLOW_INT_MAX 0x0780 1200","title":"GAP Advertising Parameters"},{"location":"03-ble-advert-connectable/#gap-periodic-advertising-parameters","text":"Periodic advertising is a Bluetooth Low Energy feature introduced in Bluetooth 5 that allows a device to broadcast data at fixed, predictable intervals without requiring a connection. Unlike legacy advertising, which is sent on the primary channels and may be missed if the scanner isn't listening at the right time, periodic advertising uses a synchronizable schedule and is transmitted on secondary channels. This allows scanners to synchronize with the advertiser and receive updates reliably with lower power consumption. It's ideal for broadcasting sensor data , location beacons , or status updates where frequent connections aren't needed but consistent updates are. Macro Hex Time (ms) BT_GAP_PER_ADV_FAST_INT_MIN_1 0x0018 30 BT_GAP_PER_ADV_FAST_INT_MAX_1 0x0030 60 BT_GAP_PER_ADV_FAST_INT_MIN_2 0x0050 100 BT_GAP_PER_ADV_FAST_INT_MAX_2 0x0078 150 BT_GAP_PER_ADV_SLOW_INT_MIN 0x0320 1000 BT_GAP_PER_ADV_SLOW_INT_MAX 0x03C0 1200","title":"GAP Periodic Advertising Parameters"},{"location":"03-ble-advert-connectable/#gap-scan-parameters","text":"These define standard scan intervals and windows. The interval is how often scanning starts, and the window is how long each scan lasts. Macro Hex Time (ms) BT_GAP_SCAN_FAST_INTERVAL_MIN 0x0030 30 BT_GAP_SCAN_FAST_INTERVAL 0x0060 60 BT_GAP_SCAN_FAST_WINDOW 0x0030 30 BT_GAP_SCAN_SLOW_INTERVAL_1 0x0800 1280 BT_GAP_SCAN_SLOW_WINDOW_1 0x0012 11.25 BT_GAP_SCAN_SLOW_INTERVAL_2 0x1000 2560 BT_GAP_SCAN_SLOW_WINDOW_2 0x0012 11.25","title":"GAP Scan Parameters"},{"location":"03-ble-advert-connectable/#gap-initial-connection-parameters","text":"These define intervals used when initiating a connection (i.e., when a central connects to a peripheral). Macro Hex Time (ms) BT_GAP_INIT_CONN_INT_MIN 0x0018 30 BT_GAP_INIT_CONN_INT_MAX 0x0028 50","title":"GAP Initial Connection Parameters"},{"location":"03-ble-advert-connectable/#additional-notes-on-timing-coordination","text":"When both the advertiser and scanner are under your control, you can optimize their timing parameters to strike a balance between discovery speed , power consumption , and reliability . This is especially useful in scenarios like proprietary ecosystems, closed systems, or when designing both ends of a BLE link (e.g., a wearable + smartphone app).","title":"Additional Notes on Timing Coordination"},{"location":"03-ble-advert-connectable/#understanding-scan-interval-and-scan-window","text":"Scan interval is how often the scanner initiates a scan cycle. Scan window is how long the scanner listens during each scan interval. Both range from 2.5 ms to 10.24 seconds in 0.625 ms steps. In each scan interval, the scanner will scan one of the three primary advertising channels. After the interval ends, it switches to the next channel. If the scan window is equal to the scan interval, the scanner is scanning continuously (100% duty cycle). If the window is shorter than the interval, it means the scanner is off part of the time \u2014 which saves power. For example, if scan interval = 100 ms and window = 20 ms, the scanner is listening only 20% of the time.","title":"Understanding Scan Interval and Scan Window"},{"location":"03-ble-advert-connectable/#coordinating-with-advertising-intervals","text":"To improve the chances of the scanner receiving advertising packets: The advertising interval should be shorter than or equal to the scan interval. This increases the probability that an advertisement will occur during the scan window. A good rule of thumb is: advertising interval \u2264 scan interval - scan window This ensures that at least one advertisement falls within an active scan window over multiple cycles. You can also align timing using multiples, such as: - Scan interval = 3 \u00d7 advertising interval - Scan window = 50\u201380% of scan interval (for reasonable duty cycle) This is not a strict rule, but it helps statistically reduce missed advertisements due to phase misalignment.","title":"Coordinating With Advertising Intervals"},{"location":"03-ble-advert-connectable/#example-timing-coordination","text":"Parameter Typical Value Advertising interval 100 ms ( 0x00A0 ) Scan interval 300 ms ( 0x018C ) Scan window 150 ms ( 0x00F0 ) This setup provides good discovery speed and balances scanner energy usage.","title":"Example Timing Coordination"},{"location":"03-ble-advert-connectable/#notes-on-scan-response-timing","text":"Scan response packets are only sent if the advertiser receives a scan request . This scan request must be sent while the advertiser is listening , and only during active scanning. The non-scanning time (between windows) is not used for scan response \u2014 in fact, nothing happens during those gaps. This means larger scan windows increase the chance of triggering a scan response successfully.","title":"Notes on Scan Response Timing"},{"location":"03-ble-advert-connectable/#power-considerations","text":"Scanning uses more power than advertising \u2014 so the scanner (usually the central) should be the device with more available energy (e.g., a phone). Peripheral devices (e.g., sensors, wearables) can advertise less frequently to save power and rely on burst scanning from the central.","title":"Power Considerations"},{"location":"03-ble-advert-connectable/#summary-guidelines","text":"Ensure advertising interval \u2264 scan interval Keep scan window large enough to catch at least one advertisement Use scan window \u2248 50\u2013100% of scan interval for faster discovery For low power devices, increase advertising interval and let central scan more aggressively","title":"Summary Guidelines"},{"location":"03-ble-advert-connectable/#aside-ble-address-types","text":"Before we continue, let's take a moment to explore the different types of Bluetooth LE addresses. Every BLE device is identified by a 48-bit address , and they are grouped into two main categories: public and random . Random addresses are further split into static , resolvable private , and non-resolvable private types. The type used affects how your device is identified, whether it can be tracked, and whether connections or bonding are possible.","title":"Aside: BLE Address Types"},{"location":"03-ble-advert-connectable/#1-public-address","text":"A globally unique address assigned by the manufacturer and stored in the device's hardware (e.g., in FICR on nRF chips). Used automatically unless you override it with a random address or enable privacy.","title":"1. Public Address"},{"location":"03-ble-advert-connectable/#get-the-default-public-address","text":"bt_addr_le_t addr; bt_id_get(&addr, NULL);","title":"Get the default public address:"},{"location":"03-ble-advert-connectable/#2-random-static-address","text":"Does not change across boots \u2014 stable identity. Must follow BLE spec: the most significant two bits of the first byte must be 11 (so the first byte must be between 0xC0 and 0xFF ). Commonly used when you don't have a public address block but need a consistent identity.","title":"2. Random Static Address"},{"location":"03-ble-advert-connectable/#set-a-static-random-address-manually","text":"#include <zephyr/bluetooth/addr.h> bt_addr_le_t addr; bt_addr_le_from_str(\"FF:00:11:22:33:44\", \"random\", &addr); addr.a.val[5] |= 0xC0; // Make sure MSBs are '11' to mark as static random int id = bt_id_create(&addr, NULL); // Must be called before bt_enable() In production, you might derive a unique static random address from the device\u2019s public address or store a pre-generated one in flash/UICR.","title":"Set a static random address manually:"},{"location":"03-ble-advert-connectable/#3-resolvable-private-address-rpa","text":"Changes periodically (by default every 15 minutes), but can be resolved by bonded peers using an Identity Resolving Key (IRK). Enables privacy without sacrificing the ability to reconnect or bond. I am currently not sure how to set the RPA manually, but it should be automatically generated by the stack when you enable privacy ( CONFIG_BT_PRIVACY=y ).","title":"3. Resolvable Private Address (RPA)"},{"location":"03-ble-advert-connectable/#4-non-resolvable-private-address-nrpa","text":"Also changes periodically, but cannot be resolved \u2014 not bondable or connectable. Useful for anonymous broadcasting (e.g., a privacy-focused beacon). A new NRPA is generated every time you start advertising.","title":"4. Non-Resolvable Private Address (NRPA)"},{"location":"03-ble-advert-connectable/#set-nrpa-explicitly","text":"static const struct bt_le_adv_param *adv_param = BT_LE_ADV_PARAM( BT_LE_ADV_OPT_USE_NRPA, 160, 160, NULL);","title":"Set NRPA explicitly:"},{"location":"03-ble-advert-connectable/#connection-callbacks","text":"To handle Bluetooth connections in Zephyr, we use the bt_conn_cb structure. This lets us register callback functions to track connection events like when a device connects or disconnects. First, include the necessary header: #include <zephyr/bluetooth/conn.h> Then, declare a connection reference to track the active connection: static struct bt_conn *my_conn = NULL;","title":"Connection Callbacks"},{"location":"03-ble-advert-connectable/#basic-callbacks","text":"void on_connected(struct bt_conn *conn, uint8_t err) { if (err) { LOG_ERR(\"Connection failed (err %u)\", err); return; } my_conn = bt_conn_ref(conn); } void on_disconnected(struct bt_conn *conn, uint8_t reason) { LOG_INF(\"Disconnected (reason 0x%02x)\", reason); if (my_conn) { bt_conn_unref(my_conn); my_conn = NULL; } } bt_conn_ref() increases the reference count so the connection stays valid. bt_conn_unref() is called on disconnection to release the reference. bt_conn_get_dst() gets the peer device\u2019s address.","title":"Basic Callbacks"},{"location":"03-ble-advert-connectable/#registering-callbacks","text":"static struct bt_conn_cb connection_callbacks = { .connected = on_connected, .disconnected = on_disconnected, }; bt_conn_cb_register(&connection_callbacks); You must register your callback structure before or after enabling Bluetooth, and before expecting any connection events.","title":"Registering Callbacks"},{"location":"03-ble-advert-connectable/#other-available-callbacks-in-bt_conn_cb","text":"You can optionally implement more callbacks: recycled : Called when a connection object is returned to the pool. le_param_req : Called when the peer requests to update connection parameters. Return true to accept or false to reject. le_param_updated : Notifies when connection parameters are updated (interval, latency, timeout). identity_resolved : (If SMP enabled) Notifies when a peer's identity address is resolved from an RPA. security_changed : (If SMP or Classic enabled) Called when connection security changes. remote_info_available : Called when info about the peer (features, roles) is available. le_phy_updated : Notifies when PHY is changed (1M, 2M, coded). le_data_len_updated : Called when the maximum payload size changes. tx_power_report : Reports transmit power changes. subrate_changed : Called when connection subrate settings change. These are mostly optional and only needed for advanced use cases.","title":"Other Available Callbacks in bt_conn_cb"},{"location":"04-ble-conn-params/","text":"04 - BLE Connection Parameters Core Connection Parameters These parameters were part of the original Bluetooth LE specification , and are exchanged during connection establishment. They define the timing and reliability of the connection. 1. Connection Interval Time between consecutive connection events (when devices wake up to communicate). Typical range: 7.5 ms to 4 s, in steps of 1.25 ms. Lower values = lower latency, higher power use. Higher values = longer sleep time, lower power use. 2. Supervision Timeout Max time allowed without successful packet reception before the connection is considered lost. Typical range: 100 ms to 32 s, in steps of 10 ms. Must be > (1 + peripheral latency) \u00d7 connection interval \u00d7 2. 3. Peripheral Latency Number of connection events the peripheral can skip if it has nothing to send. Typical values: 0\u2013499 (unitless). Allows the peripheral to save power while remaining in the connection. Note: The name is misleading \u2014 this is not a time duration , but a count of skipped events. In Action In the on_connect callback, we can print the 3 connection parameters: static void on_conn_established(struct bt_conn *conn, uint8_t err) { // ... other code active_conn = bt_conn_ref(conn); struct bt_conn_info info; if (bt_conn_get_info(conn, &info) == 0) { double int_ms = info.le.interval * 1.25; uint16_t timeout_ms = info.le.timeout * 10; LOG_INF(\"Initial conn params: %.2f ms, latency %u, timeout %u ms\", int_ms, info.le.latency, timeout_ms); } // ... other code } Note: Floating point math is not enabled by default, so we need to add CONFIG_FPU=y to the prj.conf file. Those parameters are typically first determined by the central device, and then the peripheral can request changes. To define our (i.e., the peripheral's) connection parameters, we can override the default values in the prj.conf file: # Set preferred connection parameters (units: 1.25ms for interval, 10ms for timeout) CONFIG_BT_PERIPHERAL_PREF_MIN_INT=320 CONFIG_BT_PERIPHERAL_PREF_MAX_INT=400 CONFIG_BT_PERIPHERAL_PREF_LATENCY=3 CONFIG_BT_PERIPHERAL_PREF_TIMEOUT=500 CONFIG_BT_GAP_AUTO_UPDATE_CONN_PARAMS=y The last line may be redundant, as it is enabled by default. It allows the peripheral to request a change in connection parameters after the initial connection. To get notified of the new parameters, we can implement the on_conn_param_update callback: static void handle_conn_param_change(struct bt_conn *conn, uint16_t interval, uint16_t latency, uint16_t timeout) { double interval_ms = interval * 1.25; uint16_t timeout_ms = timeout * 10; LOG_INF(\"Params changed: %.2f ms, latency %u, timeout %u ms\", interval_ms, latency, timeout_ms); } PHY Radio Modes The default mode is 1M PHY (1 Mbps), which is used for compatibility. 2M PHY (2 Mbps): Doubles throughput, reduces time on air, but may shorten range. Coded PHY : Increases range using redundancy, but at a lower data rate (125 kbps or 500 kbps). In Action We can set the PHY mode again in the on_connect callback: static void on_conn_established(struct bt_conn *conn, uint8_t err) { // ... other code const struct bt_conn_le_phy_param phy_pref = { .options = BT_CONN_LE_PHY_OPT_NONE, .pref_rx_phy = BT_GAP_LE_PHY_2M, .pref_tx_phy = BT_GAP_LE_PHY_2M, }; int err = bt_conn_le_phy_update(conn, &phy_pref); if (err) { LOG_ERR(\"PHY update failed (%d)\", err); } // ... other code } To get notified of the PHY change, we can implement the on_phy_update callback: static void handle_phy_change(struct bt_conn *conn, struct bt_conn_le_phy_info *info) { switch (info->tx_phy) { case BT_CONN_LE_TX_POWER_PHY_1M: LOG_INF(\"PHY switched to 1M\"); break; case BT_CONN_LE_TX_POWER_PHY_2M: LOG_INF(\"PHY switched to 2M\"); break; case BT_CONN_LE_TX_POWER_PHY_CODED_S8: LOG_INF(\"PHY switched to Long Range\"); break; default: LOG_INF(\"PHY changed to unknown mode\"); break; } } Data Length vs MTU To understand how these differ, it's helpful to recall the Bluetooth LE stack layers : - GATT (Generic Attribute Profile) sits at the top \u2014 this is where most application developers work. - Beneath that, L2CAP segments and reassembles data. - At the base, the Link Layer is responsible for actual over-the-air packets. 4. MTU (Maximum Transmission Unit) Max number of bytes in a single GATT operation (e.g., read/write). Default: 23 bytes. Can be increased via MTU exchange after connection. Operates at the GATT/L2CAP level . 5. Data Length Max number of bytes that can be sent in a single Link Layer PDU (packet). Default: 27 bytes. Can be increased up to 251 bytes (BLE 4.2+). Negotiated via Data Length Extension (DLE) . Even with a large MTU, if the data length is low, data is split into multiple packets. In Action Again, we can set the data length and MTU in the on_connect callback: static void mtu_exchange_cb(struct bt_conn *conn, uint8_t err, struct bt_gatt_exchange_params *params) { if (!err) { uint16_t app_mtu = bt_gatt_get_mtu(conn) - 3; LOG_INF(\"MTU negotiated: %u bytes\", app_mtu); } else { LOG_ERR(\"MTU exchange failed (ATT err %u)\", err); } } static void on_conn_established(struct bt_conn *conn, uint8_t err) { // ... other code // Update data length struct bt_conn_le_data_len_param len_params = { .tx_max_len = BT_GAP_DATA_LEN_MAX, .tx_max_time = BT_GAP_DATA_TIME_MAX, }; int err = bt_conn_le_data_len_update(conn, &len_params); if (err) { LOG_ERR(\"Failed to update data length (%d)\", err); } // Update MTU static struct bt_gatt_exchange_params params = { .func = mtu_exchange_cb }; int err = bt_gatt_exchange_mtu(conn, &params); if (err) { LOG_ERR(\"MTU exchange failed (%d)\", err); } // ... other code } And we can get notified of the data length change with the le_data_len_updated callback: static void handle_data_len_change(struct bt_conn *conn, struct bt_conn_le_data_len_info *info) { LOG_INF(\"Data len: TX=%u (%uus), RX=%u (%uus)\", info->tx_max_len, info->tx_max_time, info->rx_max_len, info->rx_max_time); }","title":"BLE-Connection Parameters"},{"location":"04-ble-conn-params/#04-ble-connection-parameters","text":"","title":"04 - BLE Connection Parameters"},{"location":"04-ble-conn-params/#core-connection-parameters","text":"These parameters were part of the original Bluetooth LE specification , and are exchanged during connection establishment. They define the timing and reliability of the connection.","title":"Core Connection Parameters"},{"location":"04-ble-conn-params/#1-connection-interval","text":"Time between consecutive connection events (when devices wake up to communicate). Typical range: 7.5 ms to 4 s, in steps of 1.25 ms. Lower values = lower latency, higher power use. Higher values = longer sleep time, lower power use.","title":"1. Connection Interval"},{"location":"04-ble-conn-params/#2-supervision-timeout","text":"Max time allowed without successful packet reception before the connection is considered lost. Typical range: 100 ms to 32 s, in steps of 10 ms. Must be > (1 + peripheral latency) \u00d7 connection interval \u00d7 2.","title":"2. Supervision Timeout"},{"location":"04-ble-conn-params/#3-peripheral-latency","text":"Number of connection events the peripheral can skip if it has nothing to send. Typical values: 0\u2013499 (unitless). Allows the peripheral to save power while remaining in the connection. Note: The name is misleading \u2014 this is not a time duration , but a count of skipped events.","title":"3. Peripheral Latency"},{"location":"04-ble-conn-params/#in-action","text":"In the on_connect callback, we can print the 3 connection parameters: static void on_conn_established(struct bt_conn *conn, uint8_t err) { // ... other code active_conn = bt_conn_ref(conn); struct bt_conn_info info; if (bt_conn_get_info(conn, &info) == 0) { double int_ms = info.le.interval * 1.25; uint16_t timeout_ms = info.le.timeout * 10; LOG_INF(\"Initial conn params: %.2f ms, latency %u, timeout %u ms\", int_ms, info.le.latency, timeout_ms); } // ... other code } Note: Floating point math is not enabled by default, so we need to add CONFIG_FPU=y to the prj.conf file. Those parameters are typically first determined by the central device, and then the peripheral can request changes. To define our (i.e., the peripheral's) connection parameters, we can override the default values in the prj.conf file: # Set preferred connection parameters (units: 1.25ms for interval, 10ms for timeout) CONFIG_BT_PERIPHERAL_PREF_MIN_INT=320 CONFIG_BT_PERIPHERAL_PREF_MAX_INT=400 CONFIG_BT_PERIPHERAL_PREF_LATENCY=3 CONFIG_BT_PERIPHERAL_PREF_TIMEOUT=500 CONFIG_BT_GAP_AUTO_UPDATE_CONN_PARAMS=y The last line may be redundant, as it is enabled by default. It allows the peripheral to request a change in connection parameters after the initial connection. To get notified of the new parameters, we can implement the on_conn_param_update callback: static void handle_conn_param_change(struct bt_conn *conn, uint16_t interval, uint16_t latency, uint16_t timeout) { double interval_ms = interval * 1.25; uint16_t timeout_ms = timeout * 10; LOG_INF(\"Params changed: %.2f ms, latency %u, timeout %u ms\", interval_ms, latency, timeout_ms); }","title":"In Action"},{"location":"04-ble-conn-params/#phy-radio-modes","text":"The default mode is 1M PHY (1 Mbps), which is used for compatibility. 2M PHY (2 Mbps): Doubles throughput, reduces time on air, but may shorten range. Coded PHY : Increases range using redundancy, but at a lower data rate (125 kbps or 500 kbps).","title":"PHY Radio Modes"},{"location":"04-ble-conn-params/#in-action_1","text":"We can set the PHY mode again in the on_connect callback: static void on_conn_established(struct bt_conn *conn, uint8_t err) { // ... other code const struct bt_conn_le_phy_param phy_pref = { .options = BT_CONN_LE_PHY_OPT_NONE, .pref_rx_phy = BT_GAP_LE_PHY_2M, .pref_tx_phy = BT_GAP_LE_PHY_2M, }; int err = bt_conn_le_phy_update(conn, &phy_pref); if (err) { LOG_ERR(\"PHY update failed (%d)\", err); } // ... other code } To get notified of the PHY change, we can implement the on_phy_update callback: static void handle_phy_change(struct bt_conn *conn, struct bt_conn_le_phy_info *info) { switch (info->tx_phy) { case BT_CONN_LE_TX_POWER_PHY_1M: LOG_INF(\"PHY switched to 1M\"); break; case BT_CONN_LE_TX_POWER_PHY_2M: LOG_INF(\"PHY switched to 2M\"); break; case BT_CONN_LE_TX_POWER_PHY_CODED_S8: LOG_INF(\"PHY switched to Long Range\"); break; default: LOG_INF(\"PHY changed to unknown mode\"); break; } }","title":"In Action"},{"location":"04-ble-conn-params/#data-length-vs-mtu","text":"To understand how these differ, it's helpful to recall the Bluetooth LE stack layers : - GATT (Generic Attribute Profile) sits at the top \u2014 this is where most application developers work. - Beneath that, L2CAP segments and reassembles data. - At the base, the Link Layer is responsible for actual over-the-air packets.","title":"Data Length vs MTU"},{"location":"04-ble-conn-params/#4-mtu-maximum-transmission-unit","text":"Max number of bytes in a single GATT operation (e.g., read/write). Default: 23 bytes. Can be increased via MTU exchange after connection. Operates at the GATT/L2CAP level .","title":"4. MTU (Maximum Transmission Unit)"},{"location":"04-ble-conn-params/#5-data-length","text":"Max number of bytes that can be sent in a single Link Layer PDU (packet). Default: 27 bytes. Can be increased up to 251 bytes (BLE 4.2+). Negotiated via Data Length Extension (DLE) . Even with a large MTU, if the data length is low, data is split into multiple packets.","title":"5. Data Length"},{"location":"04-ble-conn-params/#in-action_2","text":"Again, we can set the data length and MTU in the on_connect callback: static void mtu_exchange_cb(struct bt_conn *conn, uint8_t err, struct bt_gatt_exchange_params *params) { if (!err) { uint16_t app_mtu = bt_gatt_get_mtu(conn) - 3; LOG_INF(\"MTU negotiated: %u bytes\", app_mtu); } else { LOG_ERR(\"MTU exchange failed (ATT err %u)\", err); } } static void on_conn_established(struct bt_conn *conn, uint8_t err) { // ... other code // Update data length struct bt_conn_le_data_len_param len_params = { .tx_max_len = BT_GAP_DATA_LEN_MAX, .tx_max_time = BT_GAP_DATA_TIME_MAX, }; int err = bt_conn_le_data_len_update(conn, &len_params); if (err) { LOG_ERR(\"Failed to update data length (%d)\", err); } // Update MTU static struct bt_gatt_exchange_params params = { .func = mtu_exchange_cb }; int err = bt_gatt_exchange_mtu(conn, &params); if (err) { LOG_ERR(\"MTU exchange failed (%d)\", err); } // ... other code } And we can get notified of the data length change with the le_data_len_updated callback: static void handle_data_len_change(struct bt_conn *conn, struct bt_conn_le_data_len_info *info) { LOG_INF(\"Data len: TX=%u (%uus), RX=%u (%uus)\", info->tx_max_len, info->tx_max_time, info->rx_max_len, info->rx_max_time); }","title":"In Action"}]}